
/****************************************************************************************************//**
 * @file     MCHP_CEC1702_C0.h
 *
 * @brief    CMSIS Cortex-M4 Peripheral Access Layer Header File for
 *           MCHP_CEC1702_C0 from Microchip Technology Inc..
 *
 * @version  V1.0
 * @date     22. June 2016
 *
 * @note     Generated with SVDConv V2.87e
 *           from CMSIS SVD File 'MCHP_CEC1702_C0.svd' Version 1.0,
 *
 * @par      ARM Limited (ARM) is supplying this software for use with Cortex-M
 *           processor based microcontroller, but can be equally used for other
 *           suitable processor architectures. This file can be freely distributed.
 *           Modifications to this file shall be clearly marked.
 *
 *           THIS SOFTWARE IS PROVIDED "AS IS". NO WARRANTIES, WHETHER EXPRESS, IMPLIED
 *           OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
 *           MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
 *           ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
 *           CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
 *
 *******************************************************************************************************/



/** @addtogroup Microchip Technology Inc.
  * @{
  */

/** @addtogroup MCHP_CEC1702_C0
  * @{
  */

#ifndef MCHP_CEC1702_C0_H
#define MCHP_CEC1702_C0_H

#ifdef __cplusplus
extern "C" {
#endif


/* -------------------------  Interrupt Number Definition  ------------------------ */

typedef enum {
/* -------------------  Cortex-M4 Processor Exceptions Numbers  ------------------- */
  Reset_IRQn                    = -15,              /*!<   1  Reset Vector, invoked on Power up and warm reset                 */
  NonMaskableInt_IRQn           = -14,              /*!<   2  Non maskable Interrupt, cannot be stopped or preempted           */
  HardFault_IRQn                = -13,              /*!<   3  Hard Fault, all classes of Fault                                 */
  MemoryManagement_IRQn         = -12,              /*!<   4  Memory Management, MPU mismatch, including Access Violation
                                                         and No Match                                                          */
  BusFault_IRQn                 = -11,              /*!<   5  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory
                                                         related Fault                                                         */
  UsageFault_IRQn               = -10,              /*!<   6  Usage Fault, i.e. Undef Instruction, Illegal State Transition    */
  SVCall_IRQn                   =  -5,              /*!<  11  System Service Call via SVC instruction                          */
  DebugMonitor_IRQn             =  -4,              /*!<  12  Debug Monitor                                                    */
  PendSV_IRQn                   =  -2,              /*!<  14  Pendable request for system service                              */
  SysTick_IRQn                  =  -1,              /*!<  15  System Tick Timer                                                */
/* -----------------  MCHP_CEC1702_C0 Specific Interrupt Numbers  ----------------- */
  GPIO_140_176_IRQn             =   0,              /*!<   0  GPIO[140:176], GIRQ08                                            */
  GPIO_100_137_IRQn             =   1,              /*!<   1  GPIO[100:137], GIRQ09                                            */
  GPIO_040_076_IRQn             =   2,              /*!<   2  GPIO[040:076], GIRQ10                                            */
  GPIO_000_036_IRQn             =   3,              /*!<   3  GPIO[000:036], GIRQ11                                            */
  GPIO_200_236_IRQn             =   4,              /*!<   4  GPIO[200:236], GIRQ12                                            */
  GPIO_240_257_IRQn             =  17,              /*!<  17  GPIO[240:257], GIRQ26                                            */
  SMB_0_IRQn                    =  20,              /*!<  20  SMB0, GIRQ 13.0                                                  */
  SMB_1_IRQn                    =  21,              /*!<  21  SMB_1                                                            */
  SMB_2_IRQn                    =  22,              /*!<  22  SMB_2                                                            */
  SMB_3_IRQn                    =  23,              /*!<  23  SMB_3                                                            */
  DMA0_IRQn                     =  24,              /*!<  24  DMA0, GIRQ14.0                                                   */
  DMA1_IRQn                     =  25,              /*!<  25  DMA1                                                             */
  DMA2_IRQn                     =  26,              /*!<  26  DMA2                                                             */
  DMA3_IRQn                     =  27,              /*!<  27  DMA3                                                             */
  DMA4_IRQn                     =  28,              /*!<  28  DMA4                                                             */
  DMA5_IRQn                     =  29,              /*!<  29  DMA5                                                             */
  DMA6_IRQn                     =  30,              /*!<  30  DMA6                                                             */
  DMA7_IRQn                     =  31,              /*!<  31  DMA7                                                             */
  DMA8_IRQn                     =  32,              /*!<  32  DMA8                                                             */
  DMA9_IRQn                     =  33,              /*!<  33  DMA9                                                             */
  DMA10_IRQn                    =  34,              /*!<  34  DMA10                                                            */
  DMA11_IRQn                    =  35,              /*!<  35  DMA11                                                            */
  DMA12_IRQn                    =  36,              /*!<  36  DMA12                                                            */
  DMA13_IRQn                    =  37,              /*!<  37  DMA13                                                            */
  UART_0_IRQn                   =  40,              /*!<  40  UART 0, GIRQ 15.0                                                */
  UART_1_IRQn                   =  41,              /*!<  41  UART 1, GIRQ 15.1                                                */
  TACH_0_IRQn                   =  71,              /*!<  71  TACH_0, GIRQ 17.1                                                */
  TACH_1_IRQn                   =  72,              /*!<  72  TACH_1, GIRQ 17.2                                                */
  TACH_2_IRQn                   =  73,              /*!<  73  TACH_2, GIRQ 17.3                                                */
  RPM2PWM_0_FAIL_IRQn           =  74,              /*!<  74  RPM2PWM_0 Fail, GIRQ 17.4                                        */
  RPM2PWM_0_STALL_IRQn          =  75,              /*!<  75  RPM2PWM_0 Stall, GIRQ 17.5                                       */
  RPM2PWM_1_FAIL_IRQn           =  76,              /*!<  76  RPM2PWM_1 Fail, GIRQ 17.6                                        */
  RPM2PWM_1_STALL_IRQn          =  77,              /*!<  77  RPM2PWM_1 Stall, GIRQ 17.7                                       */
  ADC_SNGL_IRQn                 =  78,              /*!<  78  ADC_SNGL, GIRQ 17.8                                              */
  ADC_RPT_IRQn                  =  79,              /*!<  79  ADC_RPT, GIRQ 17.9                                               */
  RC_ID_0_IRQn                  =  80,              /*!<  80  RC_ID_0, GIRQ 17.10                                              */
  RC_ID_1_IRQn                  =  81,              /*!<  81  RC_ID_1, GIRQ 17.11                                              */
  RC_ID_2_IRQn                  =  82,              /*!<  82  RC_ID_2, GIRQ 17.12                                              */
  LED_0_IRQn                    =  83,              /*!<  83  Breathing LED 0, GIRQ 17.13                                      */
  LED_1_IRQn                    =  84,              /*!<  84  Breathing LED 1, GIRQ 17.14                                      */
  LED_2_IRQn                    =  85,              /*!<  85  Breathing LED 2, GIRQ 17.15                                      */
  LED_3_IRQn                    =  86,              /*!<  86  Breathing LED 3, GIRQ 17.16                                      */
  QMSPI_INT_IRQn                =  91,              /*!<  91  QMSPI, GIRQ 18.1                                                 */
  SPI0_TX_IRQn                  =  92,              /*!<  92  SPI0 TX, GIRQ 18.2                                               */
  SPI0_RX_IRQn                  =  93,              /*!<  93  SPI0 RX, GIRQ 18.3                                               */
  SPI1_TX_IRQn                  =  94,              /*!<  94  SPI1 TX, GIRQ 18.4                                               */
  SPI1_RX_IRQn                  =  95,              /*!<  95  SPI1 RX, GIRQ 18.5                                               */
  RTOS_TIMER_IRQn               = 111,              /*!< 111  RTOS_TIMER, GIRQ 21.0                                            */
  HTIMER0_IRQn                  = 112,              /*!< 112  HTIMER0, GIRQ 21.1                                               */
  HTIMER1_IRQn                  = 113,              /*!< 113  HTIMER1, GIRQ 21.2                                               */
  WEEK_ALARM_INT_IRQn           = 114,              /*!< 114  WEEK_ALARM_INT, GIRQ 21.3                                        */
  SUB_WEEK_ALARM_IRQn           = 115,              /*!< 115  SUB_WEEK_ALARM_INT, GIRQ 21.4                                    */
  ONE_SECOND_IRQn               = 116,              /*!< 116  ONE_SECOND, GIRQ 21.5                                            */
  SUB_SECOND_IRQn               = 117,              /*!< 117  SUB_SECOND, GIRQ 21.6                                            */
  SYSPWR_PRES_IRQn              = 118,              /*!< 118  SYSPWR_PRES, GIRQ 21.7                                           */
  RTC_INT_IRQn                  = 119,              /*!< 119  RTC, GIRQ 21.8                                                   */
  RTC_ALARM_IRQn                = 120,              /*!< 120  RTC ALARM, GIRQ 21.9                                             */
  VCI_OVRD_IN_IRQn              = 121,              /*!< 121  VCI_OVRD_IN, GIRQ 21.10                                          */
  VCI_IN0_IRQn                  = 122,              /*!< 122  VCI_IN0, GIRQ 21.11                                              */
  VCI_IN1_IRQn                  = 123,              /*!< 123  VCI_IN1, GIRQ 21.12                                              */
  VCI_IN2_IRQn                  = 124,              /*!< 124  VCI_IN2, GIRQ 21.13                                              */
  VCI_IN3_IRQn                  = 125,              /*!< 125  VCI_IN3, GIRQ 21.14                                              */
  VCI_IN4_IRQn                  = 126,              /*!< 126  VCI_IN4, GIRQ 21.15                                              */
  VCI_IN5_IRQn                  = 127,              /*!< 127  VCI_IN5, GIRQ 21.16                                              */
  VCI_IN6_IRQn                  = 128,              /*!< 128  VCI_IN6, GIRQ 21.17                                              */
  KSC_INT_IRQn                  = 135,              /*!< 135  KSC, GIRQ 21.25                                                  */
  TIMER_0_IRQn                  = 136,              /*!< 136  TIMER_16_0, GIRQ 23.0                                            */
  TIMER_1_IRQn                  = 137,              /*!< 137  TIMER_16_1, GIRQ 23.1                                            */
  TIMER_2_IRQn                  = 138,              /*!< 138  TIMER_16_2, GIRQ 23.2                                            */
  TIMER_3_IRQn                  = 139,              /*!< 139  TIMER_16_3, GIRQ 23.3                                            */
  TIMER_4_IRQn                  = 140,              /*!< 140  TIMER_32_0, GIRQ 23.4                                            */
  TIMER_5_IRQn                  = 141,              /*!< 141  TIMER_32_1, GIRQ 23.5                                            */
  COUNTER_TIMER_0_IRQn          = 142,              /*!< 142  COUNTER_TIMER_0, GIRQ 23.6                                       */
  COUNTER_TIMER_1_IRQn          = 143,              /*!< 143  COUNTER_TIMER_1, GIRQ 23.7                                       */
  COUNTER_TIMER_2_IRQn          = 144,              /*!< 144  COUNTER_TIMER_2, GIRQ 23.8                                       */
  COUNTER_TIMER_3_IRQn          = 145,              /*!< 145  COUNTER_TIMER_3, GIRQ 23.9                                       */
  CAPTURE_TIMER_IRQn            = 146,              /*!< 146  CAPTURE_TIMER, GIRQ 23.10                                        */
  CAPTURE_0_IRQn                = 147,              /*!< 147  CAPTURE_0, GIRQ 23.11                                            */
  CAPTURE_1_IRQn                = 148,              /*!< 148  CAPTURE_1, GIRQ 23.12                                            */
  CAPTURE_2_IRQn                = 149,              /*!< 149  CAPTURE_2, GIRQ 23.13                                            */
  CAPTURE_3_IRQn                = 150,              /*!< 150  CAPTURE_3, GIRQ 23.14                                            */
  CAPTURE_4_IRQn                = 151,              /*!< 151  CAPTURE_4, GIRQ 23.15                                            */
  CAPTURE_5_IRQn                = 152,              /*!< 152  CAPTURE_5, GIRQ 23.16                                            */
  COMPARE_0_IRQn                = 153,              /*!< 153  COMPARE_0, GIRQ 23.17                                            */
  COMPARE_1_IRQn                = 154,              /*!< 154  COMPARE_1, GIRQ 23.18                                            */
  MAX_IRQn
} IRQn_Type;


/** @addtogroup Configuration_of_CMSIS
  * @{
  */


/* ================================================================================ */
/* ================      Processor and Core Peripheral Section     ================ */
/* ================================================================================ */

/* ----------------Configuration of the Cortex-M4 Processor and Core Peripherals---------------- */
#define __CM4_REV                 0x0100            /*!< Cortex-M4 Core Revision                                               */
#define __MPU_PRESENT                  1            /*!< MPU present or not                                                    */
#define __NVIC_PRIO_BITS               3            /*!< Number of Bits used for Priority Levels                               */
#define __Vendor_SysTickConfig         0            /*!< Set to 1 if different SysTick Config is used                          */
#define __FPU_PRESENT                  1            /*!< FPU present or not                                                    */
/** @} */ /* End of group Configuration_of_CMSIS */

#include "core_cm4.h"                               /*!< Cortex-M4 processor and core peripherals                              */


/* ================================================================================ */
/* ================       Device Specific Peripheral Section       ================ */
/* ================================================================================ */


/** @addtogroup Device_Peripheral_Registers
  * @{
  */


/* -------------------  Start of section using anonymous unions  ------------------ */
#if defined(__CC_ARM)
  #pragma push
  #pragma anon_unions
#elif defined(__ICCARM__)
  #pragma language=extended
#elif defined(__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined(__TMS470__)
/* anonymous unions are enabled by default */
#elif defined(__TASKING__)
  #pragma warning 586
#else
  #warning Not supported compiler type
#endif



/* ================================================================================ */
/* ================                    PCR_INST                    ================ */
/* ================================================================================ */


/**
  * @brief The Power, Clocks, and Resets (PCR) Section identifies all the power supplies,
 clock sources, and reset inputs to the chip and defines all the derived power, clock, and reset signals.  (PCR_INST)
  */

typedef struct {                                    /*!< (@ 0x40080100) PCR_INST Structure                                     */

  union {
    __IO uint32_t  SYS_SLP_CNTRL;                   /*!< (@ 0x40080100) System Sleep Control                                   */

    struct {
      __IO uint32_t  SLEEP_MODE :  1;               /*!< [0..0] Selects the System Sleep mode                                  */
           uint32_t             :  1;
      __IO uint32_t  TEST       :  1;               /*!< [2..2] Test bit                                                       */
      __IO uint32_t  SLEEP_ALL  :  1;               /*!< [3..3] Initiates the System Sleep mode                                */
    } SYS_SLP_CNTRL_b;                              /*!< [4] BitSize                                                           */
  };

  union {
    __IO uint32_t  PROC_CLK_CNTRL;                  /*!< (@ 0x40080104) Processor Clock Control Register [7:0] Processor
                                                         Clock Divide Value (PROC_DIV)
                                                          1: divide 48 MHz Ring Oscillator by 1.
                                                          3: divide 48 MHz Ring Oscillator by 3.
                                                          4: divide 48 MHz Ring Oscillator by 4.
                                                          16: divide 48 MHz Ring Oscillator by 16.
                                                          48: divide 48 MHz Ring Oscillator by 48.
                                                          No other values are supported.                                       */

    struct {
      __IO uint32_t  PROCESSOR_CLOCK_DIVIDE:  8;    /*!< [0..7] Selects the EC clock rate                                      */
    } PROC_CLK_CNTRL_b;                             /*!< [8] BitSize                                                           */
  };

  union {
    __IO uint32_t  SLOW_CLK_CNTRL;                  /*!< (@ 0x40080108) Configures the EC_CLK clock domain                     */

    struct {
      __IO uint32_t  SLOW_CLOCK_DIVIDE: 10;         /*!< [0..9] SLOW_CLOCK_DIVIDE. n=Divide by n; 0=Clock off                  */
    } SLOW_CLK_CNTRL_b;                             /*!< [10] BitSize                                                          */
  };

  union {
    __IO uint32_t  OSC_ID;                          /*!< (@ 0x4008010C) Oscillator ID Register                                 */

    struct {
      __IO uint32_t  TEST       :  8;               /*!< [0..7] Test bits                                                      */
      __IO uint32_t  PLL_LOCK   :  1;               /*!< [8..8] PLL Lock Status                                                */
    } OSC_ID_b;                                     /*!< [9] BitSize                                                           */
  };

  union {
    __IO uint32_t  PCR_PWR_RST_STS;                 /*!< (@ 0x40080110) PCR Power Reset Status Register                        */

    struct {
           uint32_t             :  2;
      __I  uint32_t  VCC_PWRGD_STATUS:  1;          /*!< [2..2] Indicates the status of VCC_PWRGD. 0 = PWRGD not asserted.
                                                         1 = PWRGD asserte.                                                    */
      __I  uint32_t  RESET_HOST_STATUS:  1;         /*!< [3..3] Indicates the status of RESET_VCC. 0 = reset active.
                                                         1 = reset not active.                                                 */
           uint32_t             :  1;
      __IO uint32_t  VBAT_RESET_STATUS:  1;         /*!< [5..5] VBAT reset status 0 = No reset occurred while VTR was
                                                         off or since the last time this bit was cleared. 1 = A reset
                                                          occurred.(R/WC)                                                      */
      __IO uint32_t  VTR_RESET_STATUS:  1;          /*!< [6..6] Indicates the status of VTR_RESET.(R/WC)
                                                          0 = No reset occurred since the last time this bit was cleared.
                                                          1 = A reset occurred.                                                */
      __IO uint32_t  JTAG_RESET_STATUS:  1;         /*!< [7..7] Indicates s RESET_SYS was triggered by a JTAG action.(R/WC)
                                                          0 = No JTAG reset occurred since the last time this bit was
                                                         cleared.
                                                          1 = A reset occurred because of a JATAG command.                     */
           uint32_t             :  2;
      __I  uint32_t  _32K_ACTIVE:  1;               /*!< [10..10] 32K_ACTIVE (32K_ACTIVE)                                      */
      __I  uint32_t  PCICLK_ACTIVE:  1;             /*!< [11..11] PCICLK_ACTIVE (PCICLK_ACTIVE)                                */
      __I  uint32_t  ESPI_CLK_ACTIVE:  1;           /*!< [12..12] ESPI_CLK_ACTIVE                                              */
    } PCR_PWR_RST_STS_b;                            /*!< [13] BitSize                                                          */
  };

  union {
    __IO uint32_t  PWR_RST_CNTRL;                   /*!< (@ 0x40080114) Power Reset Control Register                           */

    struct {
      __IO uint32_t  PWR_INV    :  1;               /*!< [0..0] Used by FW to control internal RESET_VCC signal function
                                                         and external PWROK pin. This bit is read-only when VCC_PWRGD
                                                          is de-asserted low.                                                  */
           uint32_t             :  7;
      __IO uint32_t  HOST_RESET_SELECT:  1;         /*!< [8..8] Determines what generates the internal platform reset
                                                         signal. 1=LRESET# pin; 0=eSPI PLTRST# VWire                           */
    } PWR_RST_CNTRL_b;                              /*!< [9] BitSize                                                           */
  };

  union {
    __IO uint32_t  SYS_RST;                         /*!< (@ 0x40080118) System Reset Register                                  */

    struct {
           uint32_t             :  8;
      __IO uint32_t  SOFT_SYS_RESET:  1;            /*!< [8..8] A write of a 1 forces an assertion of the RESET_SYS reset
                                                         signal, resetting the device. A write of 0 has no effect.             */
    } SYS_RST_b;                                    /*!< [9] BitSize                                                           */
  };
  __I  uint32_t  RESERVED[5];

  union {
    __IO uint32_t  SLP_EN_0;                        /*!< (@ 0x40080130) Sleep Enable 0 Register                                */

    struct {
      __IO uint32_t  JTAG_STAP_SLP_EN:  1;          /*!< [0..0] JTAG STAP Enable                                               */
      __IO uint32_t  EFUSE_SLP_EN:  1;              /*!< [1..1] eFuse Enable                                                   */
    } SLP_EN_0_b;                                   /*!< [2] BitSize                                                           */
  };

  union {
    __IO uint32_t  SLP_EN_1;                        /*!< (@ 0x40080134) Sleep Enable 1 Register                                */

    struct {
      __IO uint32_t  INT_SLP_EN :  1;               /*!< [0..0] Interrupt Sleep Enable                                         */
           uint32_t             :  1;
      __IO uint32_t  TACH0_SLP_EN:  1;              /*!< [2..2] TACH0 Sleep Enable (TACH0_SLP_EN)                              */
           uint32_t             :  1;
      __IO uint32_t  PWM0_SLP_EN:  1;               /*!< [4..4] PWM0 Sleep Enable (PWM0_SLP_EN)                                */
      __IO uint32_t  PMC_SLP_EN :  1;               /*!< [5..5] PMC Sleep Enable (PMC_SLP_EN)                                  */
      __IO uint32_t  DMA_SLP_EN :  1;               /*!< [6..6] DMA Sleep Enable (DMA_SLP_EN)                                  */
      __IO uint32_t  TFDP_SLP_EN:  1;               /*!< [7..7] TFDP Sleep Enable (TFDP_SLP_EN)                                */
      __IO uint32_t  PROCESSOR_SLP_EN:  1;          /*!< [8..8] PROCESSOR Sleep Enable (PROCESSOR_SLP_EN)                      */
      __IO uint32_t  WDT_SLP_EN :  1;               /*!< [9..9] WDT Sleep Enable (WDT_SLP_EN)                                  */
      __IO uint32_t  SMB0_SLP_EN:  1;               /*!< [10..10] SMB0 Sleep Enable (SMB0_SLP_EN)                              */
      __IO uint32_t  TACH1_SLP_EN:  1;              /*!< [11..11] TACH1 Sleep Enable (TACH1_SLP_EN)                            */
      __IO uint32_t  TACH2_SLP_EN:  1;              /*!< [12..12] TACH2 Sleep Enable (TACH2_SLP_EN)                            */
           uint32_t             :  7;
      __IO uint32_t  PWM1_SLP_EN:  1;               /*!< [20..20] PWM1 Sleep Enable (PWM1_SLP_EN)                              */
      __IO uint32_t  PWM2_SLP_EN:  1;               /*!< [21..21] PWM2 Sleep Enable (PWM2_SLP_EN)                              */
      __IO uint32_t  PWM3_SLP_EN:  1;               /*!< [22..22] PWM3 Sleep Enable (PWM3_SLP_EN)                              */
      __IO uint32_t  PWM4_SLP_EN:  1;               /*!< [23..23] PWM4 Sleep Enable (PWM4_SLP_EN)                              */
      __IO uint32_t  PWM5_SLP_EN:  1;               /*!< [24..24] PWM3 Sleep Enable (PWM5_SLP_EN)                              */
      __IO uint32_t  PWM6_SLP_EN:  1;               /*!< [25..25] PWM3 Sleep Enable (PWM6_SLP_EN)                              */
      __IO uint32_t  PWM7_SLP_EN:  1;               /*!< [26..26] PWM3 Sleep Enable (PWM7_SLP_EN)                              */
      __IO uint32_t  PWM8_SLP_EN:  1;               /*!< [27..27] PWM3 Sleep Enable (PWM8_SLP_EN)                              */
           uint32_t             :  1;
      __IO uint32_t  EC_REG_BANK_SLP_EN:  1;        /*!< [29..29] EC_REG_BANK Sleep Enable (EC_REG_BANK_SLP_EN)                */
      __IO uint32_t  TIMER16_0_SLP_EN:  1;          /*!< [30..30] TIMER16_0 Sleep Enable (TIMER16_0_SLP_EN)                    */
      __IO uint32_t  TIMER16_1_SLP_EN:  1;          /*!< [31..31] TIMER16_1 Sleep Enable (TIMER16_1_SLP_EN)                    */
    } SLP_EN_1_b;                                   /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  SLP_EN_2;                        /*!< (@ 0x40080138) Sleep Enable 2 Register                                */

    struct {
           uint32_t             :  1;
      __IO uint32_t  UART_0_SLP_EN:  1;             /*!< [1..1] UART 0 Sleep Enable                                            */
      __IO uint32_t  UART_1_SLP_EN:  1;             /*!< [2..2] UART 1 Sleep Enable                                            */
           uint32_t             :  9;
      __IO uint32_t  GLBL_CFG_SLP_EN:  1;           /*!< [12..12] GLBL_CFG (GLBL_CFG_SLP_EN)                                   */
           uint32_t             :  5;
      __IO uint32_t  RTC_SLP_EN :  1;               /*!< [18..18] RTC Sleep Enable (RTC_SLP_EN)                                */
    } SLP_EN_2_b;                                   /*!< [19] BitSize                                                          */
  };

  union {
    __IO uint32_t  SLP_EN_3;                        /*!< (@ 0x4008013C) Sleep Enable 3 Register                                */

    struct {
           uint32_t             :  3;
      __IO uint32_t  ADC_SLP_EN :  1;               /*!< [3..3] ADC Sleep Enable (ADC_SLP_EN)                                  */
           uint32_t             :  5;
      __IO uint32_t  GP_SPI0_SLP_EN:  1;            /*!< [9..9] GP SPI0 Sleep Enable (GP_SPI0_SLP_EN)                          */
      __IO uint32_t  HTIMER_0_SLP_EN:  1;           /*!< [10..10] HTIMER 0 Sleep Enable (HTIMER_0_SLP_EN)                      */
      __IO uint32_t  KEYSCAN_SLP_EN:  1;            /*!< [11..11] KEYSCAN Sleep Enable (KEYSCAN_SLP_EN)                        */
      __IO uint32_t  RPMPWM_SLP_EN:  1;             /*!< [12..12] RPM-PWM Sleep Enable (RPMPWM_SLP_EN)                         */
      __IO uint32_t  SMB1_SLP_EN:  1;               /*!< [13..13] SMB1 Sleep Enable (SMB1_SLP_EN)                              */
      __IO uint32_t  SMB2_SLP_EN:  1;               /*!< [14..14] SMB2 Sleep Enable (SMB2_SLP_EN)                              */
      __IO uint32_t  SMB3_SLP_EN:  1;               /*!< [15..15] SMB3 Sleep Enable (SMB3_SLP_EN)                              */
      __IO uint32_t  LED0_SLP_EN:  1;               /*!< [16..16] LED0 Sleep Enable (LED0_SLP_EN)                              */
      __IO uint32_t  LED1_SLP_EN:  1;               /*!< [17..17] LED1 Sleep Enable (LED1_SLP_EN)                              */
      __IO uint32_t  LED2_SLP_EN:  1;               /*!< [18..18] LED2 Sleep Enable (LED2_SLP_EN)                              */
           uint32_t             :  1;
      __IO uint32_t  GP_SPI1_SLP_EN:  1;            /*!< [20..20] GP SPI1 Sleep Enable (GP_SPI1_SLP_EN)                        */
      __IO uint32_t  TIMER16_2_SLP_EN:  1;          /*!< [21..21] TIMER16_2_Sleep Enable (TIMER16_2_SLP_EN)                    */
      __IO uint32_t  TIMER16_3_SLP_EN:  1;          /*!< [22..22] TIMER16_3 Sleep Enable (TIMER16_3_SLP_EN)                    */
      __IO uint32_t  TIMER32_0_SLP_EN:  1;          /*!< [23..23] TIMER32_0 Sleep Enable (TIMER32_0_SLP_EN)                    */
      __IO uint32_t  TIMER32_1_SLP_EN:  1;          /*!< [24..24] TIMER32_1 Sleep Enable (TIMER32_1_SLP_EN)                    */
      __IO uint32_t  LED3_SLP_EN:  1;               /*!< [25..25] LED3 Sleep Enable (LED3_SLP_EN)                              */
      __IO uint32_t  PKE_SLP_EN :  1;               /*!< [26..26] PKE Sleep Enable                                             */
      __IO uint32_t  RNG_SLP_EN :  1;               /*!< [27..27] RNG Sleep Enable                                             */
      __IO uint32_t  AES_HASH_SLP_EN:  1;           /*!< [28..28] AES_HASH Sleep Enable                                        */
      __IO uint32_t  HTIMER_1_SLP_EN:  1;           /*!< [29..29] HTIMER 1 Sleep Enable (HTIMER_1_SLP_EN)                      */
      __IO uint32_t  CCTIMER_SLP_EN:  1;            /*!< [30..30] Capture Compare Timer Sleep Enable (CCTIMER_SLP_EN)
                                                                                                                               */
      __IO uint32_t  PWM9_SLP_EN:  1;               /*!< [31..31] PWM9 Sleep Enable (PWM9_SLP_EN)                              */
    } SLP_EN_3_b;                                   /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  SLP_EN_4;                        /*!< (@ 0x40080140) Sleep Enable 4 Register                                */

    struct {
      __IO uint32_t  PWM10_SLP_EN:  1;              /*!< [0..0] PWM10 Sleep Enable (PWM10_SLP_EN)                              */
      __IO uint32_t  PWM11_SLP_EN:  1;              /*!< [1..1] PWM11 Sleep Enable (PWM11_SLP_EN)                              */
      __IO uint32_t  CNT_TMER0_SLP_EN:  1;          /*!< [2..2] CNT_TMER0 Sleep Enable (CNT_TMER0_SLP_EN)                      */
      __IO uint32_t  CNT_TMER1_SLP_EN:  1;          /*!< [3..3] CNT_TMER1 Sleep Enable (CNT_TMER1_SLP_EN)                      */
      __IO uint32_t  CNT_TMER2_SLP_EN:  1;          /*!< [4..4] CNT_TMER2 Sleep Enable (CNT_TMER2_SLP_EN)                      */
      __IO uint32_t  CNT_TMER3_SLP_EN:  1;          /*!< [5..5] CNT_TMER3 Sleep Enable (CNT_TMER3_SLP_EN)                      */
      __IO uint32_t  RTOS_SLP_EN:  1;               /*!< [6..6] PWM6 Sleep Enable (RTOS_SLP_EN)                                */
      __IO uint32_t  RPMPWM1_SLP_EN:  1;            /*!< [7..7] RPMPWM 1 Sleep Enable (RPMPWM1_SLP_EN)                         */
      __IO uint32_t  QSPI_SLP_EN:  1;               /*!< [8..8] Quad SPI Sleep Enable                                          */
           uint32_t             :  1;
      __IO uint32_t  RC_ID0_SLP_EN:  1;             /*!< [10..10] RC_ID0 Sleep Enable (RC_ID0_SLP_EN)                          */
      __IO uint32_t  RC_ID1_SLP_EN:  1;             /*!< [11..11] RC_ID1 Sleep Enable (RC_ID1_SLP_EN)                          */
      __IO uint32_t  RC_ID2_SLP_EN:  1;             /*!< [12..12] RC_ID2 Sleep Enable (RC_ID2_SLP_EN)                          */
    } SLP_EN_4_b;                                   /*!< [13] BitSize                                                          */
  };
  __I  uint32_t  RESERVED1[3];

  union {
    __IO uint32_t  CLK_REQ_0;                       /*!< (@ 0x40080150) Clock Required 0 Register                              */

    struct {
      __IO uint32_t  JTAG_STAP_CLK_REQ:  1;         /*!< [0..0] JTAG STAP Enable                                               */
      __IO uint32_t  EFUSE_CLK_REQ:  1;             /*!< [1..1] eFuse Enable                                                   */
    } CLK_REQ_0_b;                                  /*!< [2] BitSize                                                           */
  };

  union {
    __IO uint32_t  CLK_REQ_1;                       /*!< (@ 0x40080154) Clock Required 1 Register                              */

    struct {
      __IO uint32_t  INT_CLK_REQ:  1;               /*!< [0..0] Interrupt Clock Required                                       */
           uint32_t             :  1;
      __IO uint32_t  TACH0_CLK_REQ:  1;             /*!< [2..2] TACH0 Clock Required (TACH0_CLK_REQ)                           */
           uint32_t             :  1;
      __IO uint32_t  PWM0_CLK_REQ:  1;              /*!< [4..4] PWM0 Clock Required (PWM0_CLK_REQ)                             */
      __IO uint32_t  PMC_CLK_REQ:  1;               /*!< [5..5] PMC Clock Required (PMC_CLK_REQ)                               */
      __IO uint32_t  DMA_CLK_REQ:  1;               /*!< [6..6] DMA Clock Required (DMA_CLK_REQ)                               */
      __IO uint32_t  TFDP_CLK_REQ:  1;              /*!< [7..7] TFDP Clock Required (TFDP_CLK_REQ)                             */
      __IO uint32_t  PROCESSOR_CLK_REQ:  1;         /*!< [8..8] PROCESSOR Clock Required (PROCESSOR_CLK_REQ)                   */
      __IO uint32_t  WDT_CLK_REQ:  1;               /*!< [9..9] WDT Clock Required (WDT_CLK_REQ)                               */
      __IO uint32_t  SMB0_CLK_REQ:  1;              /*!< [10..10] SMB0 Clock Required (SMB0_CLK_REQ)                           */
      __IO uint32_t  TACH1_CLK_REQ:  1;             /*!< [11..11] TACH1 Clock Required (TACH1_CLK_REQ)                         */
      __IO uint32_t  TACH2_CLK_REQ:  1;             /*!< [12..12] TACH2 Clock Required (TACH2_CLK_REQ)                         */
           uint32_t             :  7;
      __IO uint32_t  PWM1_CLK_REQ:  1;              /*!< [20..20] PWM1 Clock Required (PWM1_CLK_REQ)                           */
      __IO uint32_t  PWM2_CLK_REQ:  1;              /*!< [21..21] PWM2 Clock Required (PWM2_CLK_REQ)                           */
      __IO uint32_t  PWM3_CLK_REQ:  1;              /*!< [22..22] PWM3 Clock Required (PWM3_CLK_REQ)                           */
      __IO uint32_t  PWM4_CLK_REQ:  1;              /*!< [23..23] PWM4 Clock Required (PWM4_CLK_REQ)                           */
      __IO uint32_t  PWM5_CLK_REQ:  1;              /*!< [24..24] PWM3 Clock Required (PWM5_CLK_REQ)                           */
      __IO uint32_t  PWM6_CLK_REQ:  1;              /*!< [25..25] PWM3 Clock Required (PWM6_CLK_REQ)                           */
      __IO uint32_t  PWM7_CLK_REQ:  1;              /*!< [26..26] PWM3 Clock Required (PWM7_CLK_REQ)                           */
      __IO uint32_t  PWM8_CLK_REQ:  1;              /*!< [27..27] PWM3 Clock Required (PWM8_CLK_REQ)                           */
           uint32_t             :  1;
      __IO uint32_t  EC_REG_BANK_CLK_REQ:  1;       /*!< [29..29] EC_REG_BANK Clock Required (EC_REG_BANK_CLK_REQ)             */
      __IO uint32_t  TIMER16_0_CLK_REQ:  1;         /*!< [30..30] TIMER16_0 Clock Required (TIMER16_0_CLK_REQ)                 */
      __IO uint32_t  TIMER16_1_CLK_REQ:  1;         /*!< [31..31] TIMER16_1 Clock Required (TIMER16_1_CLK_REQ)                 */
    } CLK_REQ_1_b;                                  /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  CLK_REQ_2;                       /*!< (@ 0x40080158) Clock Required 2 Register                              */

    struct {
           uint32_t             :  1;
      __IO uint32_t  UART_0_CLK_REQ:  1;            /*!< [1..1] UART 0 Clock Required                                          */
      __IO uint32_t  UART_1_CLK_REQ:  1;            /*!< [2..2] UART 1 Clock Required                                          */
           uint32_t             :  9;
      __IO uint32_t  GLBL_CFG_CLK_REQ:  1;          /*!< [12..12] GLBL_CFG (GLBL_CFG_CLK_REQ)                                  */
           uint32_t             :  5;
      __IO uint32_t  RTC_CLK_REQ:  1;               /*!< [18..18] RTC Clock Required (RTC_CLK_REQ)                             */
    } CLK_REQ_2_b;                                  /*!< [19] BitSize                                                          */
  };

  union {
    __IO uint32_t  CLK_REQ_3;                       /*!< (@ 0x4008015C) Clock Required 3 Register                              */

    struct {
           uint32_t             :  3;
      __IO uint32_t  ADC_CLK_REQ:  1;               /*!< [3..3] ADC Clock Required (ADC_CLK_REQ)                               */
           uint32_t             :  5;
      __IO uint32_t  GP_SPI0_CLK_REQ:  1;           /*!< [9..9] GP SPI0 Clock Required (GP_SPI0_CLK_REQ)                       */
      __IO uint32_t  HTIMER_0_CLK_REQ:  1;          /*!< [10..10] HTIMER 0 Clock Required (HTIMER_0_CLK_REQ)                   */
      __IO uint32_t  KEYSCAN_CLK_REQ:  1;           /*!< [11..11] KEYSCAN Clock Required (KEYSCAN_CLK_REQ)                     */
      __IO uint32_t  RPMPWM0_CLK_REQ:  1;           /*!< [12..12] RPM-PWM 0 Clock Required (RPMPWM0_CLK_REQ)                   */
      __IO uint32_t  SMB1_CLK_REQ:  1;              /*!< [13..13] SMB1 Clock Required (SMB1_CLK_REQ)                           */
      __IO uint32_t  SMB2_CLK_REQ:  1;              /*!< [14..14] SMB2 Clock Required (SMB2_CLK_REQ)                           */
      __IO uint32_t  SMB3_CLK_REQ:  1;              /*!< [15..15] SMB3 Clock Required (SMB3_CLK_REQ)                           */
      __IO uint32_t  LED0_CLK_REQ:  1;              /*!< [16..16] LED0 Clock Required (LED0_CLK_REQ)                           */
      __IO uint32_t  LED1_CLK_REQ:  1;              /*!< [17..17] LED1 Clock Required (LED1_CLK_REQ)                           */
      __IO uint32_t  LED2_CLK_REQ:  1;              /*!< [18..18] LED2 Clock Required (LED2_CLK_REQ)                           */
           uint32_t             :  1;
      __IO uint32_t  GP_SPI1_CLK_REQ:  1;           /*!< [20..20] GP SPI1 Clock Required (GP_SPI1_CLK_REQ)                     */
      __IO uint32_t  TIMER16_2_CLK_REQ:  1;         /*!< [21..21] TIMER16_2_Clock Required (TIMER16_2_CLK_REQ)                 */
      __IO uint32_t  TIMER16_3_CLK_REQ:  1;         /*!< [22..22] TIMER16_3 Clock Required (TIMER16_3_CLK_REQ)                 */
      __IO uint32_t  TIMER32_0_CLK_REQ:  1;         /*!< [23..23] TIMER32_0 Clock Required (TIMER32_0_CLK_REQ)                 */
      __IO uint32_t  TIMER32_1_CLK_REQ:  1;         /*!< [24..24] TIMER32_1 Clock Required (TIMER32_1_CLK_REQ)                 */
      __IO uint32_t  LED3_CLK_REQ:  1;              /*!< [25..25] LED3 Clock Required (LED3_CLK_REQ)                           */
      __IO uint32_t  PKE_CLK_REQ:  1;               /*!< [26..26] PKE Clock Required                                           */
      __IO uint32_t  RNG_CLK_REQ:  1;               /*!< [27..27] RNG Clock Required                                           */
      __IO uint32_t  AES_HASH_CLK_REQ:  1;          /*!< [28..28] AES_HASH Clock Required                                      */
      __IO uint32_t  HTIMER_1_CLK_REQ:  1;          /*!< [29..29] HTIMER 1 Clock Required (HTIMER_1_CLK_REQ)                   */
      __IO uint32_t  CCTIMER_CLK_REQ:  1;           /*!< [30..30] Capture Compare Timer Clock Required (CCTIMER_CLK_REQ)
                                                                                                                               */
      __IO uint32_t  PWM9_CLK_REQ:  1;              /*!< [31..31] PWM9 Clock Required (PWM9_CLK_REQ)                           */
    } CLK_REQ_3_b;                                  /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  CLK_REQ_4;                       /*!< (@ 0x40080160) Clock Required 4 Register                              */

    struct {
      __IO uint32_t  PWM10_CLK_REQ:  1;             /*!< [0..0] PWM10 Clock Required (PWM10_CLK_REQ)                           */
      __IO uint32_t  PWM11_CLK_REQ:  1;             /*!< [1..1] PWM11 Clock Required (PWM11_CLK_REQ)                           */
      __IO uint32_t  CNT_TMER0_CLK_REQ:  1;         /*!< [2..2] CNT_TMER0 Clock Required (CNT_TMER0_CLK_REQ)                   */
      __IO uint32_t  CNT_TMER1_CLK_REQ:  1;         /*!< [3..3] CNT_TMER1 Clock Required (CNT_TMER1_CLK_REQ)                   */
      __IO uint32_t  CNT_TMER2_CLK_REQ:  1;         /*!< [4..4] CNT_TMER2 Clock Required (CNT_TMER2_CLK_REQ)                   */
      __IO uint32_t  CNT_TMER3_CLK_REQ:  1;         /*!< [5..5] CNT_TMER3 Clock Required (CNT_TMER3_CLK_REQ)                   */
      __IO uint32_t  RTOS_CLK_REQ:  1;              /*!< [6..6] RTOS Clock Required (RTOS_CLK_REQ)                             */
      __IO uint32_t  RPMPWM1_CLK_REQ:  1;           /*!< [7..7] RPM-PWM1 Clock Required (RPMPWM1_CLK_REQ)                      */
      __IO uint32_t  QSPI_CLK_REQ:  1;              /*!< [8..8] Quad SPI Clock Required                                        */
           uint32_t             :  1;
      __IO uint32_t  RC_ID0_CLK_REQ:  1;            /*!< [10..10] RC_ID0 Clock Required (RC_ID0_CLK_REQ)                       */
      __IO uint32_t  RC_ID1_CLK_REQ:  1;            /*!< [11..11] RC_ID1 Clock Required (RC_ID1_CLK_REQ)                       */
      __IO uint32_t  RC_ID2_CLK_REQ:  1;            /*!< [12..12] RC_ID2 Clock Required (RC_ID2_CLK_REQ)                       */
    } CLK_REQ_4_b;                                  /*!< [13] BitSize                                                          */
  };
  __I  uint32_t  RESERVED2[3];

  union {
    __IO uint32_t  RST_EN_0;                        /*!< (@ 0x40080170) Reset Enable 0 Register                                */

    struct {
      __IO uint32_t  JTAG_STAP_RST_EN:  1;          /*!< [0..0] JTAG STAP Reset Enable                                         */
      __IO uint32_t  EFUSE_RST_EN:  1;              /*!< [1..1] eFuse Reset Enable                                             */
    } RST_EN_0_b;                                   /*!< [2] BitSize                                                           */
  };

  union {
    __IO uint32_t  RST_EN_1;                        /*!< (@ 0x40080174) Reset Enable 1 Register                                */

    struct {
      __IO uint32_t  INT_RST_EN :  1;               /*!< [0..0] Interrupt Reset Enable                                         */
           uint32_t             :  1;
      __IO uint32_t  TACH0_RST_EN:  1;              /*!< [2..2] TACH0 Reset Enable (TACH0_RST_EN)                              */
           uint32_t             :  1;
      __IO uint32_t  PWM0_RST_EN:  1;               /*!< [4..4] PWM0 Reset Enable (PWM0_RST_EN)                                */
      __IO uint32_t  PMC_RST_EN :  1;               /*!< [5..5] PMC Reset Enable (PMC_RST_EN)                                  */
      __IO uint32_t  DMA_RST_EN :  1;               /*!< [6..6] DMA Reset Enable (DMA_RST_EN)                                  */
      __IO uint32_t  TFDP_RST_EN:  1;               /*!< [7..7] TFDP Reset Enable (TFDP_RST_EN)                                */
      __IO uint32_t  PROCESSOR_RST_EN:  1;          /*!< [8..8] PROCESSOR Reset Enable (PROCESSOR_RST_EN)                      */
      __IO uint32_t  WDT_RST_EN :  1;               /*!< [9..9] WDT Reset Enable (WDT_RST_EN)                                  */
      __IO uint32_t  SMB0_RST_EN:  1;               /*!< [10..10] SMB0 Reset Enable (SMB0_RST_EN)                              */
      __IO uint32_t  TACH1_RST_EN:  1;              /*!< [11..11] TACH1 Reset Enable (TACH1_RST_EN)                            */
      __IO uint32_t  TACH2_RST_EN:  1;              /*!< [12..12] TACH2 Reset Enable (TACH2_RST_EN)                            */
           uint32_t             :  7;
      __IO uint32_t  PWM1_RST_EN:  1;               /*!< [20..20] PWM1 Reset Enable (PWM1_RST_EN)                              */
      __IO uint32_t  PWM2_RST_EN:  1;               /*!< [21..21] PWM2 Reset Enable (PWM2_RST_EN)                              */
      __IO uint32_t  PWM3_RST_EN:  1;               /*!< [22..22] PWM3 Reset Enable (PWM3_RST_EN)                              */
      __IO uint32_t  PWM4_RST_EN:  1;               /*!< [23..23] PWM4 Reset Enable (PWM4_RST_EN)                              */
      __IO uint32_t  PWM5_RST_EN:  1;               /*!< [24..24] PWM3 Reset Enable (PWM5_RST_EN)                              */
      __IO uint32_t  PWM6_RST_EN:  1;               /*!< [25..25] PWM3 Reset Enable (PWM6_RST_EN)                              */
      __IO uint32_t  PWM7_RST_EN:  1;               /*!< [26..26] PWM3 Reset Enable (PWM7_RST_EN)                              */
      __IO uint32_t  PWM8_RST_EN:  1;               /*!< [27..27] PWM3 Reset Enable (PWM8_RST_EN)                              */
           uint32_t             :  1;
      __IO uint32_t  EC_REG_BANK_RST_EN:  1;        /*!< [29..29] EC_REG_BANK Reset Enable (EC_REG_BANK_RST_EN)                */
      __IO uint32_t  TIMER16_0_RST_EN:  1;          /*!< [30..30] TIMER16_0 Reset Enable (TIMER16_0_RST_EN)                    */
      __IO uint32_t  TIMER16_1_RST_EN:  1;          /*!< [31..31] TIMER16_1 Reset Enable (TIMER16_1_RST_EN)                    */
    } RST_EN_1_b;                                   /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  RST_EN_2;                        /*!< (@ 0x40080178) Reset Enable 2 Register                                */

    struct {
           uint32_t             :  1;
      __IO uint32_t  UART_0_RST_EN:  1;             /*!< [1..1] UART 0 Reset Enable                                            */
      __IO uint32_t  UART_1_RST_EN:  1;             /*!< [2..2] UART 1 Reset Enable                                            */
           uint32_t             :  9;
      __IO uint32_t  GLBL_CFG_RST_EN:  1;           /*!< [12..12] GLBL_CFG (GLBL_CFG_RST_EN)                                   */
           uint32_t             :  5;
      __IO uint32_t  RTC_RST_EN :  1;               /*!< [18..18] RTC Reset Enable (RTC_RST_EN)                                */
    } RST_EN_2_b;                                   /*!< [19] BitSize                                                          */
  };

  union {
    __IO uint32_t  RST_EN_3;                        /*!< (@ 0x4008017C) Reset Enable 3 Register                                */

    struct {
           uint32_t             :  3;
      __IO uint32_t  ADC_RST_EN :  1;               /*!< [3..3] ADC Reset Enable (ADC_RST_EN)                                  */
           uint32_t             :  5;
      __IO uint32_t  GP_SPI0_RST_EN:  1;            /*!< [9..9] GP SPI0 Reset Enable (GP_SPI0_RST_EN)                          */
      __IO uint32_t  HTIMER_0_RST_EN:  1;           /*!< [10..10] HTIMER 0 Reset Enable (HTIMER_0_RST_EN)                      */
      __IO uint32_t  KEYSCAN_RST_EN:  1;            /*!< [11..11] KEYSCAN Reset Enable (KEYSCAN_RST_EN)                        */
      __IO uint32_t  RPMPWM0_RST_EN:  1;            /*!< [12..12] RPM-PWM 0 Reset Enable (RPMPWM0_RST_EN)                      */
      __IO uint32_t  SMB1_RST_EN:  1;               /*!< [13..13] SMB1 Reset Enable (SMB1_RST_EN)                              */
      __IO uint32_t  SMB2_RST_EN:  1;               /*!< [14..14] SMB2 Reset Enable (SMB2_RST_EN)                              */
      __IO uint32_t  SMB3_RST_EN:  1;               /*!< [15..15] SMB3 Reset Enable (SMB3_RST_EN)                              */
      __IO uint32_t  LED0_RST_EN:  1;               /*!< [16..16] LED0 Reset Enable (LED0_RST_EN)                              */
      __IO uint32_t  LED1_RST_EN:  1;               /*!< [17..17] LED1 Reset Enable (LED1_RST_EN)                              */
      __IO uint32_t  LED2_RST_EN:  1;               /*!< [18..18] LED2 Reset Enable (LED2_RST_EN)                              */
           uint32_t             :  1;
      __IO uint32_t  GP_SPI1_RST_EN:  1;            /*!< [20..20] GP SPI1 Reset Enable (GP_SPI1_RST_EN)                        */
      __IO uint32_t  TIMER16_2_RST_EN:  1;          /*!< [21..21] TIMER16_2_Reset Enable (TIMER16_2_RST_EN)                    */
      __IO uint32_t  TIMER16_3_RST_EN:  1;          /*!< [22..22] TIMER16_3 Reset Enable (TIMER16_3_RST_EN)                    */
      __IO uint32_t  TIMER32_0_RST_EN:  1;          /*!< [23..23] TIMER32_0 Reset Enable (TIMER32_0_RST_EN)                    */
      __IO uint32_t  TIMER32_1_RST_EN:  1;          /*!< [24..24] TIMER32_1 Reset Enable (TIMER32_1_RST_EN)                    */
      __IO uint32_t  LED3_RST_EN:  1;               /*!< [25..25] LED3 Reset Enable (LED3_RST_EN)                              */
      __IO uint32_t  PKE_RST_EN :  1;               /*!< [26..26] PKE Reset Enable                                             */
      __IO uint32_t  RNG_RST_EN :  1;               /*!< [27..27] RNG Reset Enable                                             */
      __IO uint32_t  AES_HASH_RST_EN:  1;           /*!< [28..28] AES_HASH Reset Enable                                        */
      __IO uint32_t  HTIMER_1_RST_EN:  1;           /*!< [29..29] HTIMER 1 Reset Enable (HTIMER_1_RST_EN)                      */
      __IO uint32_t  CCTIMER_RST_EN:  1;            /*!< [30..30] Capture Compare Timer Reset Enable (CCTIMER_RST_EN)
                                                                                                                               */
      __IO uint32_t  PWM9_RST_EN:  1;               /*!< [31..31] PWM9 Reset Enable (PWM9_RST_EN)                              */
    } RST_EN_3_b;                                   /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  RST_EN_4;                        /*!< (@ 0x40080180) Reset Enable 4 Register                                */

    struct {
      __IO uint32_t  PWM10_RST_EN:  1;              /*!< [0..0] PWM10 Reset Enable (PWM10_RST_EN)                              */
      __IO uint32_t  PWM11_RST_EN:  1;              /*!< [1..1] PWM11 Reset Enable (PWM11_RST_EN)                              */
      __IO uint32_t  CNT_TMER0_RST_EN:  1;          /*!< [2..2] CNT_TMER0 Reset Enable (CNT_TMER0_RST_EN)                      */
      __IO uint32_t  CNT_TMER1_RST_EN:  1;          /*!< [3..3] CNT_TMER1 Reset Enable (CNT_TMER1_RST_EN)                      */
      __IO uint32_t  CNT_TMER2_RST_EN:  1;          /*!< [4..4] CNT_TMER2 Reset Enable (CNT_TMER2_RST_EN)                      */
      __IO uint32_t  CNT_TMER3_RST_EN:  1;          /*!< [5..5] CNT_TMER3 Reset Enable (CNT_TMER3_RST_EN)                      */
      __IO uint32_t  RTOS_RST_EN:  1;               /*!< [6..6] RTOS Reset Enable (RTOS_RST_EN)                                */
      __IO uint32_t  RPMPWM1_RST_EN:  1;            /*!< [7..7] RPM-PWM1 Reset Enable (RPMPWM1_RST_EN)                         */
      __IO uint32_t  QSPI_RST_EN:  1;               /*!< [8..8] Quad SPI Reset Enable                                          */
           uint32_t             :  1;
      __IO uint32_t  RC_ID0_RST_EN:  1;             /*!< [10..10] RC_ID0 Reset Enable (RC_ID0_RST_EN)                          */
      __IO uint32_t  RC_ID1_RST_EN:  1;             /*!< [11..11] RC_ID1 Reset Enable (RC_ID1_RST_EN)                          */
      __IO uint32_t  RC_ID2_RST_EN:  1;             /*!< [12..12] RC_ID2 Reset Enable (RC_ID2_RST_EN)                          */
    } RST_EN_4_b;                                   /*!< [13] BitSize                                                          */
  };
} PCR_INST_Type;


/* ================================================================================ */
/* ================                  DMA_MAIN_INST                 ================ */
/* ================================================================================ */


/**
  * @brief DMA Main Registers (DMA_MAIN_INST)
  */

typedef struct {                                    /*!< (@ 0x40002400) DMA_MAIN_INST Structure                                */

  union {
    __IO uint8_t   DMA_MAIN_CONTROL;                /*!< (@ 0x40002400) Soft reset the entire module. Enable the blocks
                                                         operation.                                                            */

    struct {
      __IO uint8_t   ACTIVATE   :  1;               /*!< [0..0] Enable the blocks operation. (R/WS)
                                                          1=Enable block. Each individual channel must be enabled separately.
                                                          0=Disable all channels.                                              */
      __O  uint8_t   SOFT_RESET :  1;               /*!< [1..1] Soft reset the entire module. This bit is self-clearing.
                                                                                                                               */
    } DMA_MAIN_CONTROL_b;                           /*!< [2] BitSize                                                           */
  };
  __I  uint8_t   RESERVED[3];
  __I  uint32_t  DATA_PACKET;                       /*!< (@ 0x40002404) Debug register that has the data that is stored
                                                         in the Data Packet. This data is read data from the currently
                                                          active transfer source.                                              */
} DMA_MAIN_INST_Type;


/* ================================================================================ */
/* ================                 DMA_CHAN00_INST                ================ */
/* ================================================================================ */


/**
  * @brief DMA Channel 00 Registers (DMA_CHAN00_INST)
  */

typedef struct {                                    /*!< (@ 0x40002440) DMA_CHAN00_INST Structure                              */

  union {
    __IO uint8_t   DMA_CHANNEL_ACTIVATE;            /*!< (@ 0x40002440) Enable this channel for operation. The DMA Main
                                                         Control: Activate must also be enabled for this channel to be
                                                          operational.                                                         */

    struct {
      __IO uint8_t   CHANNEL_ACTIVATE:  1;          /*!< [0..0] Enable this channel for operation. The DMA Main Control:Activate
                                                         must also be enabled for this channel to be operational.
                                                          1=Enable channel(block). Each individual channel must be enabled
                                                          separately.
                                                          0=Disable channel(block).                                            */
    } DMA_CHANNEL_ACTIVATE_b;                       /*!< [1] BitSize                                                           */
  };
  __I  uint8_t   RESERVED[3];
  __IO uint32_t  MEMORY_START_ADDRESS;              /*!< (@ 0x40002444) This is the starting address for the Memory device.
                                                                                                                               */
  __IO uint32_t  MEMORY_END_ADDRESS;                /*!< (@ 0x40002448) This is the ending address for the Memory device.
                                                                                                                               */
  __IO uint32_t  DEVICE_ADDRESS;                    /*!< (@ 0x4000244C) This is the Master Device address.                     */

  union {
    __IO uint32_t  CONTROL;                         /*!< (@ 0x40002450) DMA Channel N Control                                  */

    struct {
      __IO uint32_t  RUN        :  1;               /*!< [0..0] This is a control field. Note: This bit only applies
                                                         to Hardware Flow Control mode.
                                                          1= This channel is enabled and will service transfer requests
                                                          0=This channel is disabled. All transfer requests are ignored.
                                                                                                                               */
      __IO uint32_t  REQUEST    :  1;               /*!< [1..1] This is a status field.
                                                          1= There is a transfer request from the Master Device
                                                          0= There is no transfer request from the Master Device               */
      __IO uint32_t  DONE       :  1;               /*!< [2..2] This is a status signal. It is only valid while DMA Channel
                                                         Control: Run is Enabled.
                                                          This is the inverse of the DMA Channel Control: Busy field,
                                                          except this is qualified with the DMA Channel Control:Run field.
                                                          1=Channel is done
                                                          0=Channel is not done or it is OFF                                   */
      __IO uint32_t  STATUS     :  2;               /*!< [3..4] This is a status signal. The status decode is listed
                                                         in priority order with the highest priority first.
                                                          3: Error detected by the DMA
                                                          2: The DMA Channel is externally done, in that the Device has
                                                          terminated the transfer over the Hardware Flow Control through
                                                          the Port dma_term
                                                          1: The DMA Channel is locally done, in that Memory Start Address
                                                          equals Memory End Address
                                                          0: DMA Channel Control:Run is Disabled (0x0)                         */
      __IO uint32_t  BUSY       :  1;               /*!< [5..5] This is a status signal.
                                                          1=The DMA Channel is busy (FSM is not IDLE)
                                                          0=The DMA Channel is not busy (FSM is IDLE)                          */
           uint32_t             :  2;
      __IO uint32_t  TX_DIRECTION:  1;              /*!< [8..8] This determines the direction of the DMA Transfer.
                                                          1=Data Packet Read from Memory Start Address followed by Data
                                                         Packet Write to Device Address
                                                          0=Data Packet Read from Device Address followed by Data Packet
                                                          Write to Memory Start Address                                        */
      __IO uint32_t  HARDWARE_FLOW_CONTROL_DEVICE:  7;/*!< [9..15] This is the device that is connected to this channel
                                                         as its Hardware Flow Control master.
                                                          The Flow Control Interface is a bus with each master concatenated
                                                          onto it.
                                                          This selects which bus index of the concatenated Flow Control
                                                          Interface bus is targeted towards this channel.
                                                          The Flow Control Interface Port list is dma_req, dma_term,
                                                          and dma_done.                                                        */
      __IO uint32_t  INCREMENT_MEM_ADDR:  1;        /*!< [16..16] This will enable an auto-increment to the DMA Channel
                                                         Memory Address.
                                                          1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfe
                                                         r Size after every Data Packet transfer
                                                          0=Do nothing                                                         */
      __IO uint32_t  INCREMENT_DEVICE_ADDR:  1;     /*!< [17..17] This will enable an auto-increment to the DMA Channel
                                                         Device Address.
                                                          1: Increment the DMA Channel Device Address by DMA Channel
                                                          Control:Transfer Size after every Data Packet transfer
                                                          0: Do nothing                                                        */
      __IO uint32_t  LOCK       :  1;               /*!< [18..18] This is used to lock the arbitration of the Channel
                                                         Arbiter on this channel once this channel is granted. Once this
                                                          is locked, it will remain on the arbiter until it has completed
                                                          it transfer (either the Transfer Aborted, Transfer Done or Transfer
                                                          Terminated conditions).                                              */
      __IO uint32_t  DISABLE_HW_FLOW_CONTROL:  1;   /*!< [19..19] This will Disable the Hardware Flow Control. When disabled,
                                                         any DMA Master device attempting to communicate to the DMA over
                                                          the DMA Flow Control Interface (Ports: dma_req, dma_term, and
                                                          dma_done) will be ignored. This should be set before using the
                                                          DMA channel in Firmware Flow Control mode.                           */
      __IO uint32_t  TRANSFER_SIZE:  3;             /*!< [20..22] This is the transfer size in Bytes of each Data Packet
                                                         transfer.
                                                          Note: The transfer size must be a legal AMBA transfer size.
                                                          Valid sizes are 1, 2 and 4 Bytes.                                    */
           uint32_t             :  1;
      __IO uint32_t  TRANSFER_GO:  1;               /*!< [24..24] This is used for the Firmware Flow Control DMA transfer.
                                                                                                                               */
      __IO uint32_t  TRANSFER_ABORT:  1;            /*!< [25..25] This is used to abort the current transfer on this
                                                         DMA Channel. The aborted transfer will be forced to terminate
                                                          immediately.                                                         */
    } CONTROL_b;                                    /*!< [26] BitSize                                                          */
  };

  union {
    __IO uint8_t   INT_STATUS;                      /*!< (@ 0x40002454) DMA Channel N Interrupt Status                         */

    struct {
      __IO uint8_t   BUS_ERROR  :  1;               /*!< [0..0] This is an interrupt source register. This flags when
                                                         there is an Error detected over the internal 32-bit Bus.
                                                          1: Error detected. (R/WC)                                            */
      __IO uint8_t   FLOW_CONTROL:  1;              /*!< [1..1] This is an interrupt source register. This flags when
                                                         the DMA Channel has encountered a Hardware Flow Control Request
                                                         after the DMA Channel has completed the transfer. This means
                                                          the Master Device is attempting to overflow the DMA.
                                                          1=Hardware Flow Control is requesting after the transfer has
                                                          completed
                                                          0=No Hardware Flow Control event                                     */
      __IO uint8_t   DONE       :  1;               /*!< [2..2] This is an interrupt source register. This flags when
                                                         the DMA Channel has completed a transfer successfully on its
                                                          side.
                                                         A completed transfer is defined as when the DMA Channel reaches
                                                          its limit; Memory Start Address equals Memory End Address.
                                                         A completion due to a Hardware Flow Control Terminate will not
                                                          flag this interrupt.
                                                          1=Memory Start Address equals Memory End Address
                                                          0=Memory Start Address does not equal Memory End Address             */
    } INT_STATUS_b;                                 /*!< [3] BitSize                                                           */
  };
  __I  uint8_t   RESERVED1[3];

  union {
    __IO uint8_t   INT_EN;                          /*!< (@ 0x40002458) DMA CHANNEL N INTERRUPT ENABLE                         */

    struct {
      __IO uint8_t   STATUS_ENABLE_BUS_ERROR:  1;   /*!< [0..0] This is an interrupt enable for DMA Channel Interrupt:Status
                                                         Bus Error.
                                                          1=Enable Interrupt
                                                          0=Disable Interrupt                                                  */
      __IO uint8_t   STATUS_ENABLE_FLOW_CONTROL:  1;/*!< [1..1] This is an interrupt enable for DMA Channel Interrupt:Status
                                                         Flow Control Error.
                                                          1=Enable Interrupt
                                                          0=Disable Interrupt                                                  */
      __IO uint8_t   STATUS_ENABLE_DONE:  1;        /*!< [2..2] This is an interrupt enable for DMA Channel Interrupt:Status
                                                         Done.
                                                          1=Enable Interrupt
                                                          0=Disable Interrupt                                                  */
    } INT_EN_b;                                     /*!< [3] BitSize                                                           */
  };
  __I  uint8_t   RESERVED2[7];

  union {
    __IO uint32_t  CRC_ENABLE;                      /*!< (@ 0x40002460) DMA CHANNEL N CRC ENABLE                               */

    struct {
      __IO uint32_t  CRC_MODE_ENABLE:  1;           /*!< [0..0] 1=Enable the calculation of CRC-32 for DMA Channel N
                                                         0=Disable the calculation of CRC-32 for DMA Channel N                 */
      __IO uint32_t  CRC_POST_TRANSFER_ENABLE:  1;  /*!< [1..1] The bit enables the transfer of the calculated CRC-32
                                                         after the completion of the DMA transaction.
                                                         If the DMA transaction is aborted by either firmware or an internal
                                                          bus error, the transfer will not occur.
                                                         If the target of the DMA transfer is a device and the device
                                                          signaled the termination of the DMA transaction,
                                                         the CRC post transfer will not occur.
                                                         1=Enable the transfer of CRC-32 for DMA Channel N after the
                                                          DMA transaction completes
                                                         0=Disable the automatic transfer of the CRC                           */
    } CRC_ENABLE_b;                                 /*!< [2] BitSize                                                           */
  };

  union {
    __IO uint32_t  CRC_DATA;                        /*!< (@ 0x40002464) DMA CHANNEL N CRC DATA                                 */

    struct {
      __IO uint32_t  CRC        : 32;               /*!< [0..31] Writes to this register initialize the CRC generator.
                                                         Reads from this register return the output of the
                                                         CRC that is calculated from the data transferred by DMA Channel
                                                          N. The output of the CRC generator is bit-reversed
                                                         and inverted on reads, as required by the CRC-32-IEEE definition.
                                                          A CRC can be accumulated across multiple DMA transactions
                                                         on Channel N. If it is necessary to save the intermediate CRC
                                                          value, the result of the read of this register must be
                                                         bit-reversed and inverted before being written back                   */
    } CRC_DATA_b;                                   /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  CRC_POST_STATUS;                 /*!< (@ 0x40002468) DMA CHANNEL N CRC POST STATUS                          */

    struct {
      __I  uint32_t  CRC_DONE   :  1;               /*!< [0..0] This bit is set to '1b' when the CRC calculation has
                                                         completed from either normal or forced termination.
                                                         It is cleared to '0b' when the DMA controller starts a new transfer
                                                          on the channel.                                                      */
      __I  uint32_t  CRC_RUNNING:  1;               /*!< [1..1] This bit is set to '1b' when the DMA controller starts
                                                         the post-transfer transmission of the CRC.
                                                         It is only set when the post-transfer is enabled by the CRC_POST_TRANSFER_
                                                         ENABLE field. This bit is cleared
                                                         to '0b' when the post-transfer completes.                             */
      __I  uint32_t  CRC_DATA_DONE:  1;             /*!< [2..2] This bit is set to '1b' when the DMA controller has completed
                                                         the post-transfer of the CRC data.
                                                         This bit is cleared to '0b' when the a new DMA transfer starts.
                                                                                                                               */
      __I  uint32_t  CRC_DATA_READY:  1;            /*!< [3..3] This bit is set to '1b' when the DMA controller is processing
                                                         the post-transfer of the CRC data.
                                                         This bit is cleared to '0b' when the post-transfer completes.
                                                                                                                               */
    } CRC_POST_STATUS_b;                            /*!< [4] BitSize                                                           */
  };
} DMA_CHAN00_INST_Type;


/* ================================================================================ */
/* ================                 DMA_CHAN01_INST                ================ */
/* ================================================================================ */


/**
  * @brief DMA Channel 01 Registers (DMA_CHAN01_INST)
  */

typedef struct {                                    /*!< (@ 0x40002480) DMA_CHAN01_INST Structure                              */

  union {
    __IO uint8_t   DMA_CHANNEL_ACTIVATE;            /*!< (@ 0x40002480) Enable this channel for operation. The DMA Main
                                                         Control: Activate must also be enabled for this channel to be
                                                          operational.                                                         */

    struct {
      __IO uint8_t   CHANNEL_ACTIVATE:  1;          /*!< [0..0] Enable this channel for operation. The DMA Main Control:Activate
                                                         must also be enabled for this channel to be operational.
                                                          1=Enable channel(block). Each individual channel must be enabled
                                                          separately.
                                                          0=Disable channel(block).                                            */
    } DMA_CHANNEL_ACTIVATE_b;                       /*!< [1] BitSize                                                           */
  };
  __I  uint8_t   RESERVED[3];
  __IO uint32_t  MEMORY_START_ADDRESS;              /*!< (@ 0x40002484) This is the starting address for the Memory device.
                                                                                                                               */
  __IO uint32_t  MEMORY_END_ADDRESS;                /*!< (@ 0x40002488) This is the ending address for the Memory device.
                                                                                                                               */
  __IO uint32_t  DEVICE_ADDRESS;                    /*!< (@ 0x4000248C) This is the Master Device address.                     */

  union {
    __IO uint32_t  CONTROL;                         /*!< (@ 0x40002490) DMA Channel N Control                                  */

    struct {
      __IO uint32_t  RUN        :  1;               /*!< [0..0] This is a control field. Note: This bit only applies
                                                         to Hardware Flow Control mode.
                                                          1= This channel is enabled and will service transfer requests
                                                          0=This channel is disabled. All transfer requests are ignored.
                                                                                                                               */
      __IO uint32_t  REQUEST    :  1;               /*!< [1..1] This is a status field.
                                                          1= There is a transfer request from the Master Device
                                                          0= There is no transfer request from the Master Device               */
      __IO uint32_t  DONE       :  1;               /*!< [2..2] This is a status signal. It is only valid while DMA Channel
                                                         Control: Run is Enabled.
                                                          This is the inverse of the DMA Channel Control: Busy field,
                                                          except this is qualified with the DMA Channel Control:Run field.
                                                          1=Channel is done
                                                          0=Channel is not done or it is OFF                                   */
      __IO uint32_t  STATUS     :  2;               /*!< [3..4] This is a status signal. The status decode is listed
                                                         in priority order with the highest priority first.
                                                          3: Error detected by the DMA
                                                          2: The DMA Channel is externally done, in that the Device has
                                                          terminated the transfer over the Hardware Flow Control through
                                                          the Port dma_term
                                                          1: The DMA Channel is locally done, in that Memory Start Address
                                                          equals Memory End Address
                                                          0: DMA Channel Control:Run is Disabled (0x0)                         */
      __IO uint32_t  BUSY       :  1;               /*!< [5..5] This is a status signal.
                                                          1=The DMA Channel is busy (FSM is not IDLE)
                                                          0=The DMA Channel is not busy (FSM is IDLE)                          */
           uint32_t             :  2;
      __IO uint32_t  TX_DIRECTION:  1;              /*!< [8..8] This determines the direction of the DMA Transfer.
                                                          1=Data Packet Read from Memory Start Address followed by Data
                                                         Packet Write to Device Address
                                                          0=Data Packet Read from Device Address followed by Data Packet
                                                          Write to Memory Start Address                                        */
      __IO uint32_t  HARDWARE_FLOW_CONTROL_DEVICE:  7;/*!< [9..15] This is the device that is connected to this channel
                                                         as its Hardware Flow Control master.
                                                          The Flow Control Interface is a bus with each master concatenated
                                                          onto it.
                                                          This selects which bus index of the concatenated Flow Control
                                                          Interface bus is targeted towards this channel.
                                                          The Flow Control Interface Port list is dma_req, dma_term,
                                                          and dma_done.                                                        */
      __IO uint32_t  INCREMENT_MEM_ADDR:  1;        /*!< [16..16] This will enable an auto-increment to the DMA Channel
                                                         Memory Address.
                                                          1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfe
                                                         r Size after every Data Packet transfer
                                                          0=Do nothing                                                         */
      __IO uint32_t  INCREMENT_DEVICE_ADDR:  1;     /*!< [17..17] This will enable an auto-increment to the DMA Channel
                                                         Device Address.
                                                          1: Increment the DMA Channel Device Address by DMA Channel
                                                          Control:Transfer Size after every Data Packet transfer
                                                          0: Do nothing                                                        */
      __IO uint32_t  LOCK       :  1;               /*!< [18..18] This is used to lock the arbitration of the Channel
                                                         Arbiter on this channel once this channel is granted. Once this
                                                          is locked, it will remain on the arbiter until it has completed
                                                          it transfer (either the Transfer Aborted, Transfer Done or Transfer
                                                          Terminated conditions).                                              */
      __IO uint32_t  DISABLE_HW_FLOW_CONTROL:  1;   /*!< [19..19] This will Disable the Hardware Flow Control. When disabled,
                                                         any DMA Master device attempting to communicate to the DMA over
                                                          the DMA Flow Control Interface (Ports: dma_req, dma_term, and
                                                          dma_done) will be ignored. This should be set before using the
                                                          DMA channel in Firmware Flow Control mode.                           */
      __IO uint32_t  TRANSFER_SIZE:  3;             /*!< [20..22] This is the transfer size in Bytes of each Data Packet
                                                         transfer.
                                                          Note: The transfer size must be a legal AMBA transfer size.
                                                          Valid sizes are 1, 2 and 4 Bytes.                                    */
           uint32_t             :  1;
      __IO uint32_t  TRANSFER_GO:  1;               /*!< [24..24] This is used for the Firmware Flow Control DMA transfer.
                                                                                                                               */
      __IO uint32_t  TRANSFER_ABORT:  1;            /*!< [25..25] This is used to abort the current transfer on this
                                                         DMA Channel. The aborted transfer will be forced to terminate
                                                          immediately.                                                         */
    } CONTROL_b;                                    /*!< [26] BitSize                                                          */
  };

  union {
    __IO uint8_t   INT_STATUS;                      /*!< (@ 0x40002494) DMA Channel N Interrupt Status                         */

    struct {
      __IO uint8_t   BUS_ERROR  :  1;               /*!< [0..0] This is an interrupt source register. This flags when
                                                         there is an Error detected over the internal 32-bit Bus.
                                                          1: Error detected. (R/WC)                                            */
      __IO uint8_t   FLOW_CONTROL:  1;              /*!< [1..1] This is an interrupt source register. This flags when
                                                         the DMA Channel has encountered a Hardware Flow Control Request
                                                         after the DMA Channel has completed the transfer. This means
                                                          the Master Device is attempting to overflow the DMA.
                                                          1=Hardware Flow Control is requesting after the transfer has
                                                          completed
                                                          0=No Hardware Flow Control event                                     */
      __IO uint8_t   DONE       :  1;               /*!< [2..2] This is an interrupt source register. This flags when
                                                         the DMA Channel has completed a transfer successfully on its
                                                          side.
                                                         A completed transfer is defined as when the DMA Channel reaches
                                                          its limit; Memory Start Address equals Memory End Address.
                                                         A completion due to a Hardware Flow Control Terminate will not
                                                          flag this interrupt.
                                                          1=Memory Start Address equals Memory End Address
                                                          0=Memory Start Address does not equal Memory End Address             */
    } INT_STATUS_b;                                 /*!< [3] BitSize                                                           */
  };
  __I  uint8_t   RESERVED1[3];

  union {
    __IO uint8_t   INT_EN;                          /*!< (@ 0x40002498) DMA CHANNEL N INTERRUPT ENABLE                         */

    struct {
      __IO uint8_t   STATUS_ENABLE_BUS_ERROR:  1;   /*!< [0..0] This is an interrupt enable for DMA Channel Interrupt:Status
                                                         Bus Error.
                                                          1=Enable Interrupt
                                                          0=Disable Interrupt                                                  */
      __IO uint8_t   STATUS_ENABLE_FLOW_CONTROL:  1;/*!< [1..1] This is an interrupt enable for DMA Channel Interrupt:Status
                                                         Flow Control Error.
                                                          1=Enable Interrupt
                                                          0=Disable Interrupt                                                  */
      __IO uint8_t   STATUS_ENABLE_DONE:  1;        /*!< [2..2] This is an interrupt enable for DMA Channel Interrupt:Status
                                                         Done.
                                                          1=Enable Interrupt
                                                          0=Disable Interrupt                                                  */
    } INT_EN_b;                                     /*!< [3] BitSize                                                           */
  };
  __I  uint8_t   RESERVED2[7];

  union {
    __IO uint32_t  FILL_ENABLE;                     /*!< (@ 0x400024A0) DMA CHANNEL N FILL ENABLE                              */

    struct {
      __IO uint32_t  FILL_MODE_ENABLE:  1;          /*!< [0..0] 1=Enable the calculation of CRC-32 for DMA Channel N
                                                         0=Disable the calculation of CRC-32 for DMA Channel N                 */
    } FILL_ENABLE_b;                                /*!< [1] BitSize                                                           */
  };

  union {
    __IO uint32_t  FILL_DATA;                       /*!< (@ 0x400024A4) DMA CHANNEL N FILL DATA                                */

    struct {
      __IO uint32_t  FILL_DATA  : 32;               /*!< [0..31] This is the data pattern used to fill memory.                 */
    } FILL_DATA_b;                                  /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  FILL_STATUS;                     /*!< (@ 0x400024A8) DMA CHANNEL N FILL STATUS                              */

    struct {
      __I  uint32_t  FILL_DONE  :  1;               /*!< [0..0] This bit is set to '1b' when the CRC calculation has
                                                         completed from either normal or forced termination.
                                                         It is cleared to '0b' when the DMA controller starts a new transfer
                                                          on the channel.                                                      */
      __I  uint32_t  FILL_RUNNING:  1;              /*!< [1..1] This bit is set to '1b' when the DMA controller starts
                                                         the post-transfer transmission of the CRC.
                                                         It is only set when the post-transfer is enabled by the CRC_POST_TRANSFER_
                                                         ENABLE field. This bit is cleared
                                                         to '0b' when the post-transfer completes.                             */
    } FILL_STATUS_b;                                /*!< [2] BitSize                                                           */
  };
} DMA_CHAN01_INST_Type;


/* ================================================================================ */
/* ================                 DMA_CHAN02_INST                ================ */
/* ================================================================================ */


/**
  * @brief DMA Channel 00 Registers (DMA_CHAN02_INST)
  */

typedef struct {                                    /*!< (@ 0x400024C0) DMA_CHAN02_INST Structure                              */

  union {
    __IO uint8_t   DMA_CHANNEL_ACTIVATE;            /*!< (@ 0x400024C0) Enable this channel for operation. The DMA Main
                                                         Control: Activate must also be enabled for this channel to be
                                                          operational.                                                         */

    struct {
      __IO uint8_t   CHANNEL_ACTIVATE:  1;          /*!< [0..0] Enable this channel for operation. The DMA Main Control:Activate
                                                         must also be enabled for this channel to be operational.
                                                          1=Enable channel(block). Each individual channel must be enabled
                                                          separately.
                                                          0=Disable channel(block).                                            */
    } DMA_CHANNEL_ACTIVATE_b;                       /*!< [1] BitSize                                                           */
  };
  __I  uint8_t   RESERVED[3];
  __IO uint32_t  MEMORY_START_ADDRESS;              /*!< (@ 0x400024C4) This is the starting address for the Memory device.
                                                                                                                               */
  __IO uint32_t  MEMORY_END_ADDRESS;                /*!< (@ 0x400024C8) This is the ending address for the Memory device.
                                                                                                                               */
  __IO uint32_t  DEVICE_ADDRESS;                    /*!< (@ 0x400024CC) This is the Master Device address.                     */

  union {
    __IO uint32_t  CONTROL;                         /*!< (@ 0x400024D0) DMA Channel N Control                                  */

    struct {
      __IO uint32_t  RUN        :  1;               /*!< [0..0] This is a control field. Note: This bit only applies
                                                         to Hardware Flow Control mode.
                                                          1= This channel is enabled and will service transfer requests
                                                          0=This channel is disabled. All transfer requests are ignored.
                                                                                                                               */
      __IO uint32_t  REQUEST    :  1;               /*!< [1..1] This is a status field.
                                                          1= There is a transfer request from the Master Device
                                                          0= There is no transfer request from the Master Device               */
      __IO uint32_t  DONE       :  1;               /*!< [2..2] This is a status signal. It is only valid while DMA Channel
                                                         Control: Run is Enabled.
                                                          This is the inverse of the DMA Channel Control: Busy field,
                                                          except this is qualified with the DMA Channel Control:Run field.
                                                          1=Channel is done
                                                          0=Channel is not done or it is OFF                                   */
      __IO uint32_t  STATUS     :  2;               /*!< [3..4] This is a status signal. The status decode is listed
                                                         in priority order with the highest priority first.
                                                          3: Error detected by the DMA
                                                          2: The DMA Channel is externally done, in that the Device has
                                                          terminated the transfer over the Hardware Flow Control through
                                                          the Port dma_term
                                                          1: The DMA Channel is locally done, in that Memory Start Address
                                                          equals Memory End Address
                                                          0: DMA Channel Control:Run is Disabled (0x0)                         */
      __IO uint32_t  BUSY       :  1;               /*!< [5..5] This is a status signal.
                                                          1=The DMA Channel is busy (FSM is not IDLE)
                                                          0=The DMA Channel is not busy (FSM is IDLE)                          */
           uint32_t             :  2;
      __IO uint32_t  TX_DIRECTION:  1;              /*!< [8..8] This determines the direction of the DMA Transfer.
                                                          1=Data Packet Read from Memory Start Address followed by Data
                                                         Packet Write to Device Address
                                                          0=Data Packet Read from Device Address followed by Data Packet
                                                          Write to Memory Start Address                                        */
      __IO uint32_t  HARDWARE_FLOW_CONTROL_DEVICE:  7;/*!< [9..15] This is the device that is connected to this channel
                                                         as its Hardware Flow Control master.
                                                          The Flow Control Interface is a bus with each master concatenated
                                                          onto it.
                                                          This selects which bus index of the concatenated Flow Control
                                                          Interface bus is targeted towards this channel.
                                                          The Flow Control Interface Port list is dma_req, dma_term,
                                                          and dma_done.                                                        */
      __IO uint32_t  INCREMENT_MEM_ADDR:  1;        /*!< [16..16] This will enable an auto-increment to the DMA Channel
                                                         Memory Address.
                                                          1=Increment the DMA Channel Memory Address by DMA Channel Control:Transfe
                                                         r Size after every Data Packet transfer
                                                          0=Do nothing                                                         */
      __IO uint32_t  INCREMENT_DEVICE_ADDR:  1;     /*!< [17..17] This will enable an auto-increment to the DMA Channel
                                                         Device Address.
                                                          1: Increment the DMA Channel Device Address by DMA Channel
                                                          Control:Transfer Size after every Data Packet transfer
                                                          0: Do nothing                                                        */
      __IO uint32_t  LOCK       :  1;               /*!< [18..18] This is used to lock the arbitration of the Channel
                                                         Arbiter on this channel once this channel is granted. Once this
                                                          is locked, it will remain on the arbiter until it has completed
                                                          it transfer (either the Transfer Aborted, Transfer Done or Transfer
                                                          Terminated conditions).                                              */
      __IO uint32_t  DISABLE_HW_FLOW_CONTROL:  1;   /*!< [19..19] This will Disable the Hardware Flow Control. When disabled,
                                                         any DMA Master device attempting to communicate to the DMA over
                                                          the DMA Flow Control Interface (Ports: dma_req, dma_term, and
                                                          dma_done) will be ignored. This should be set before using the
                                                          DMA channel in Firmware Flow Control mode.                           */
      __IO uint32_t  TRANSFER_SIZE:  3;             /*!< [20..22] This is the transfer size in Bytes of each Data Packet
                                                         transfer.
                                                          Note: The transfer size must be a legal AMBA transfer size.
                                                          Valid sizes are 1, 2 and 4 Bytes.                                    */
           uint32_t             :  1;
      __IO uint32_t  TRANSFER_GO:  1;               /*!< [24..24] This is used for the Firmware Flow Control DMA transfer.
                                                                                                                               */
      __IO uint32_t  TRANSFER_ABORT:  1;            /*!< [25..25] This is used to abort the current transfer on this
                                                         DMA Channel. The aborted transfer will be forced to terminate
                                                          immediately.                                                         */
    } CONTROL_b;                                    /*!< [26] BitSize                                                          */
  };

  union {
    __IO uint8_t   INT_STATUS;                      /*!< (@ 0x400024D4) DMA Channel N Interrupt Status                         */

    struct {
      __IO uint8_t   BUS_ERROR  :  1;               /*!< [0..0] This is an interrupt source register. This flags when
                                                         there is an Error detected over the internal 32-bit Bus.
                                                          1: Error detected. (R/WC)                                            */
      __IO uint8_t   FLOW_CONTROL:  1;              /*!< [1..1] This is an interrupt source register. This flags when
                                                         the DMA Channel has encountered a Hardware Flow Control Request
                                                         after the DMA Channel has completed the transfer. This means
                                                          the Master Device is attempting to overflow the DMA.
                                                          1=Hardware Flow Control is requesting after the transfer has
                                                          completed
                                                          0=No Hardware Flow Control event                                     */
      __IO uint8_t   DONE       :  1;               /*!< [2..2] This is an interrupt source register. This flags when
                                                         the DMA Channel has completed a transfer successfully on its
                                                          side.
                                                         A completed transfer is defined as when the DMA Channel reaches
                                                          its limit; Memory Start Address equals Memory End Address.
                                                         A completion due to a Hardware Flow Control Terminate will not
                                                          flag this interrupt.
                                                          1=Memory Start Address equals Memory End Address
                                                          0=Memory Start Address does not equal Memory End Address             */
    } INT_STATUS_b;                                 /*!< [3] BitSize                                                           */
  };
  __I  uint8_t   RESERVED1[3];

  union {
    __IO uint8_t   INT_EN;                          /*!< (@ 0x400024D8) DMA CHANNEL N INTERRUPT ENABLE                         */

    struct {
      __IO uint8_t   STATUS_ENABLE_BUS_ERROR:  1;   /*!< [0..0] This is an interrupt enable for DMA Channel Interrupt:Status
                                                         Bus Error.
                                                          1=Enable Interrupt
                                                          0=Disable Interrupt                                                  */
      __IO uint8_t   STATUS_ENABLE_FLOW_CONTROL:  1;/*!< [1..1] This is an interrupt enable for DMA Channel Interrupt:Status
                                                         Flow Control Error.
                                                          1=Enable Interrupt
                                                          0=Disable Interrupt                                                  */
      __IO uint8_t   STATUS_ENABLE_DONE:  1;        /*!< [2..2] This is an interrupt enable for DMA Channel Interrupt:Status
                                                         Done.
                                                          1=Enable Interrupt
                                                          0=Disable Interrupt                                                  */
    } INT_EN_b;                                     /*!< [3] BitSize                                                           */
  };
} DMA_CHAN02_INST_Type;


/* ================================================================================ */
/* ================                    INTS_INST                   ================ */
/* ================================================================================ */


/**
  * @brief The interrupt generation logic is made of 16 groups of signals, each of which
 consist of a Status register, a Enable register and a Result register. The Status and Enable are
 latched registers. The Result register is a bit by bit AND function of the Source and Enable registers.
 All the bits of the Result register are OR'ed together and AND'ed with the corresponding bit in the Block
 Select register to form the interrupt signal that is routed to the ARM interrupt controller.  (INTS_INST)
  */

typedef struct {                                    /*!< (@ 0x4000E000) INTS_INST Structure                                    */
  __IO uint32_t  GIRQ08_SRC;                        /*!< (@ 0x4000E000) Status R/W1C                                           */
  __IO uint32_t  GIRQ08_EN_SET;                     /*!< (@ 0x4000E004) Write to set source enables                            */
  __I  uint32_t  GIRQ08_RESULT;                     /*!< (@ 0x4000E008) Read-only bitwise OR of Source and Enable              */
  __IO uint32_t  GIRQ08_EN_CLR;                     /*!< (@ 0x4000E00C) Write to clear source enables                          */
  __I  uint32_t  RESERVED;
  __IO uint32_t  GIRQ09_SRC;                        /*!< (@ 0x4000E014) Status R/W1C                                           */
  __IO uint32_t  GIRQ09_EN_SET;                     /*!< (@ 0x4000E018) Write to set source enables                            */
  __I  uint32_t  GIRQ09_RESULT;                     /*!< (@ 0x4000E01C) Read-only bitwise OR of Source and Enable              */
  __IO uint32_t  GIRQ09_EN_CLR;                     /*!< (@ 0x4000E020) Write to clear source enables                          */
  __I  uint32_t  RESERVED1;
  __IO uint32_t  GIRQ10_SRC;                        /*!< (@ 0x4000E028) Status R/W1C                                           */
  __IO uint32_t  GIRQ10_EN_SET;                     /*!< (@ 0x4000E02C) Write to set source enables                            */
  __I  uint32_t  GIRQ10_RESULT;                     /*!< (@ 0x4000E030) Read-only bitwise OR of Source and Enable              */
  __IO uint32_t  GIRQ10_EN_CLR;                     /*!< (@ 0x4000E034) Write to clear source enables                          */
  __I  uint32_t  RESERVED2;
  __IO uint32_t  GIRQ11_SRC;                        /*!< (@ 0x4000E03C) Status R/W1C                                           */
  __IO uint32_t  GIRQ11_EN_SET;                     /*!< (@ 0x4000E040) Write to set source enables                            */
  __I  uint32_t  GIRQ11_RESULT;                     /*!< (@ 0x4000E044) Read-only bitwise OR of Source and Enable              */
  __IO uint32_t  GIRQ11_EN_CLR;                     /*!< (@ 0x4000E048) Write to clear source enables                          */
  __I  uint32_t  RESERVED3;
  __IO uint32_t  GIRQ12_SRC;                        /*!< (@ 0x4000E050) Status R/W1C                                           */
  __IO uint32_t  GIRQ12_EN_SET;                     /*!< (@ 0x4000E054) Write to set source enables                            */
  __I  uint32_t  GIRQ12_RESULT;                     /*!< (@ 0x4000E058) Read-only bitwise OR of Source and Enable              */
  __IO uint32_t  GIRQ12_EN_CLR;                     /*!< (@ 0x4000E05C) Write to clear source enables                          */
  __I  uint32_t  RESERVED4;
  __IO uint32_t  GIRQ13_SRC;                        /*!< (@ 0x4000E064) Status R/W1C                                           */
  __IO uint32_t  GIRQ13_EN_SET;                     /*!< (@ 0x4000E068) Write to set source enables                            */
  __I  uint32_t  GIRQ13_RESULT;                     /*!< (@ 0x4000E06C) Read-only bitwise OR of Source and Enable              */
  __IO uint32_t  GIRQ13_EN_CLR;                     /*!< (@ 0x4000E070) Write to clear source enables                          */
  __I  uint32_t  RESERVED5;
  __IO uint32_t  GIRQ14_SRC;                        /*!< (@ 0x4000E078) Status R/W1C                                           */
  __IO uint32_t  GIRQ14_EN_SET;                     /*!< (@ 0x4000E07C) Write to set source enables                            */
  __I  uint32_t  GIRQ14_RESULT;                     /*!< (@ 0x4000E080) Read-only bitwise OR of Source and Enable              */
  __IO uint32_t  GIRQ14_EN_CLR;                     /*!< (@ 0x4000E084) Write to clear source enables                          */
  __I  uint32_t  RESERVED6;
  __IO uint32_t  GIRQ15_SRC;                        /*!< (@ 0x4000E08C) Status R/W1C                                           */
  __IO uint32_t  GIRQ15_EN_SET;                     /*!< (@ 0x4000E090) Write to set source enables                            */
  __I  uint32_t  GIRQ15_RESULT;                     /*!< (@ 0x4000E094) Read-only bitwise OR of Source and Enable              */
  __IO uint32_t  GIRQ15_EN_CLR;                     /*!< (@ 0x4000E098) Write to clear source enables                          */
  __I  uint32_t  RESERVED7;
  __IO uint32_t  GIRQ16_SRC;                        /*!< (@ 0x4000E0A0) Status R/W1C                                           */
  __IO uint32_t  GIRQ16_EN_SET;                     /*!< (@ 0x4000E0A4) Write to set source enables                            */
  __I  uint32_t  GIRQ16_RESULT;                     /*!< (@ 0x4000E0A8) Read-only bitwise OR of Source and Enable              */
  __IO uint32_t  GIRQ16_EN_CLR;                     /*!< (@ 0x4000E0AC) Write to clear source enables                          */
  __I  uint32_t  RESERVED8;
  __IO uint32_t  GIRQ17_SRC;                        /*!< (@ 0x4000E0B4) Status R/W1C                                           */
  __IO uint32_t  GIRQ17_EN_SET;                     /*!< (@ 0x4000E0B8) Write to set source enables                            */
  __I  uint32_t  GIRQ17_RESULT;                     /*!< (@ 0x4000E0BC) Read-only bitwise OR of Source and Enable              */
  __IO uint32_t  GIRQ17_EN_CLR;                     /*!< (@ 0x4000E0C0) Write to clear source enables                          */
  __I  uint32_t  RESERVED9;
  __IO uint32_t  GIRQ18_SRC;                        /*!< (@ 0x4000E0C8) Status R/W1C                                           */
  __IO uint32_t  GIRQ18_EN_SET;                     /*!< (@ 0x4000E0CC) Write to set source enables                            */
  __I  uint32_t  GIRQ18_RESULT;                     /*!< (@ 0x4000E0D0) Read-only bitwise OR of Source and Enable              */
  __IO uint32_t  GIRQ18_EN_CLR;                     /*!< (@ 0x4000E0D4) Write to clear source enables                          */
  __I  uint32_t  RESERVED10;
  __IO uint32_t  GIRQ19_SRC;                        /*!< (@ 0x4000E0DC) Status R/W1C                                           */
  __IO uint32_t  GIRQ19_EN_SET;                     /*!< (@ 0x4000E0E0) Write to set source enables                            */
  __I  uint32_t  GIRQ19_RESULT;                     /*!< (@ 0x4000E0E4) Read-only bitwise OR of Source and Enable              */
  __IO uint32_t  GIRQ19_EN_CLR;                     /*!< (@ 0x4000E0E8) Write to clear source enables                          */
  __I  uint32_t  RESERVED11;
  __IO uint32_t  GIRQ20_SRC;                        /*!< (@ 0x4000E0F0) Status R/W1C                                           */
  __IO uint32_t  GIRQ20_EN_SET;                     /*!< (@ 0x4000E0F4) Write to set source enables                            */
  __I  uint32_t  GIRQ20_RESULT;                     /*!< (@ 0x4000E0F8) Read-only bitwise OR of Source and Enable              */
  __IO uint32_t  GIRQ20_EN_CLR;                     /*!< (@ 0x4000E0FC) Write to clear source enables                          */
  __I  uint32_t  RESERVED12;
  __IO uint32_t  GIRQ21_SRC;                        /*!< (@ 0x4000E104) Status R/W1C                                           */
  __IO uint32_t  GIRQ21_EN_SET;                     /*!< (@ 0x4000E108) Write to set source enables                            */
  __I  uint32_t  GIRQ21_RESULT;                     /*!< (@ 0x4000E10C) Read-only bitwise OR of Source and Enable              */
  __IO uint32_t  GIRQ21_EN_CLR;                     /*!< (@ 0x4000E110) Write to clear source enables                          */
  __I  uint32_t  RESERVED13;
  __IO uint32_t  GIRQ22_SRC;                        /*!< (@ 0x4000E118) Status R/W1C                                           */
  __IO uint32_t  GIRQ22_EN_SET;                     /*!< (@ 0x4000E11C) Write to set source enables                            */
  __I  uint32_t  GIRQ22_RESULT;                     /*!< (@ 0x4000E120) Read-only bitwise OR of Source and Enable              */
  __IO uint32_t  GIRQ22_EN_CLR;                     /*!< (@ 0x4000E124) Write to clear source enables                          */
  __I  uint32_t  RESERVED14;
  __IO uint32_t  GIRQ23_SRC;                        /*!< (@ 0x4000E12C) Status R/W1C                                           */
  __IO uint32_t  GIRQ23_EN_SET;                     /*!< (@ 0x4000E130) Write to set source enables                            */
  __I  uint32_t  GIRQ23_RESULT;                     /*!< (@ 0x4000E134) Read-only bitwise OR of Source and Enable              */
  __IO uint32_t  GIRQ23_EN_CLR;                     /*!< (@ 0x4000E138) Write to clear source enables                          */
  __I  uint32_t  RESERVED15;
  __IO uint32_t  GIRQ24_SRC;                        /*!< (@ 0x4000E140) Status R/W1C                                           */
  __IO uint32_t  GIRQ24_EN_SET;                     /*!< (@ 0x4000E144) Write to set source enables                            */
  __I  uint32_t  GIRQ24_RESULT;                     /*!< (@ 0x4000E148) Read-only bitwise OR of Source and Enable              */
  __IO uint32_t  GIRQ24_EN_CLR;                     /*!< (@ 0x4000E14C) Write to clear source enables                          */
  __I  uint32_t  RESERVED16;
  __IO uint32_t  GIRQ25_SRC;                        /*!< (@ 0x4000E154) Status R/W1C                                           */
  __IO uint32_t  GIRQ25_EN_SET;                     /*!< (@ 0x4000E158) Write to set source enables                            */
  __I  uint32_t  GIRQ25_RESULT;                     /*!< (@ 0x4000E15C) Read-only bitwise OR of Source and Enable              */
  __IO uint32_t  GIRQ25_EN_CLR;                     /*!< (@ 0x4000E160) Write to clear source enables                          */
  __I  uint32_t  RESERVED17;
  __IO uint32_t  GIRQ26_SRC;                        /*!< (@ 0x4000E168) Status R/W1C                                           */
  __IO uint32_t  GIRQ26_EN_SET;                     /*!< (@ 0x4000E16C) Write to set source enables                            */
  __I  uint32_t  GIRQ26_RESULT;                     /*!< (@ 0x4000E170) Read-only bitwise OR of Source and Enable              */
  __IO uint32_t  GIRQ26_EN_CLR;                     /*!< (@ 0x4000E174) Write to clear source enables                          */
  __I  uint32_t  RESERVED18[34];

  union {
    __IO uint32_t  BLOCK_ENABLE_SET;                /*!< (@ 0x4000E200) Block Enable Set Register                              */

    struct {
      __IO uint32_t  IRQ_VECTOR_ENABLE_SET: 31;     /*!< [0..30] Each GIRQx bit can be individually enabled to assert
                                                         an interrupt event.
                                                          Reads always return the current value of the internal GIRQX_ENABLE
                                                          bit. The state of the GIRQX_ENABLE bit is determined by
                                                          the corresponding GIRQX_ENABLE_SET bit and the GIRQX_ENABLE_
                                                          CLEAR bit. (0=disabled, 1=enabled) (R/WS)
                                                          1=Interrupts in the GIRQx Source Register may be enabled
                                                          0=No effect.                                                         */
    } BLOCK_ENABLE_SET_b;                           /*!< [31] BitSize                                                          */
  };

  union {
    __IO uint32_t  BLOCK_ENABLE_CLEAR;              /*!< (@ 0x4000E204) Block Enable Clear Register.                           */

    struct {
      __IO uint32_t  IRQ_VECTOR_ENABLE_CLEAR: 31;   /*!< [0..30] Each GIRQx bit can be individually disabled to inhibit
                                                         an interrupt event.
                                                          Reads always return the current value of the internal GIRQX_ENABLE
                                                          bit. The state of the GIRQX_ENABLE bit is determined by
                                                          the corresponding GIRQX_ENABLE_SET bit and the GIRQX_ENABLE_
                                                          CLEAR bit. (0=disabled, 1=enabled) (R/WC)
                                                          1=All interrupts in the GIRQx Source Register are disabled
                                                          0=No effect.                                                         */
    } BLOCK_ENABLE_CLEAR_b;                         /*!< [31] BitSize                                                          */
  };

  union {
    __I  uint32_t  BLOCK_IRQ_VECTOR;                /*!< (@ 0x4000E208) Block IRQ Vector Register                              */

    struct {
      __I  uint32_t  IRQ_VECTOR : 25;               /*!< [0..24] Each bit in this field reports the status of the group
                                                         GIRQ interrupt assertion to the NVIC. If the GIRQx interrupt
                                                          is disabled as a group, by the Block Enable Clear Register,
                                                          then the corresponding bit will be '0'b and no interrupt will
                                                          be asserted.                                                         */
    } BLOCK_IRQ_VECTOR_b;                           /*!< [25] BitSize                                                          */
  };
} INTS_INST_Type;


/* ================================================================================ */
/* ================                    GCR_INST                    ================ */
/* ================================================================================ */


/**
  * @brief The Logical Device Configuration registers support motherboard designs in
 which the resources required by their components are known and assigned by the BIOS
 at POST.  (GCR_INST)
  */

typedef struct {                                    /*!< (@ 0x400FFF00) GCR_INST Structure                                     */
  __I  uint8_t   RESERVED[7];
  __IO uint8_t   LOGICAL_DEVICE_NUMBER;             /*!< (@ 0x400FFF07) A write to this register selects the current
                                                         logical device. This allows access to the control and configuration
                                                          registers for each logical device. Note: The Activate command
                                                          operates only on the selected logical device.                        */
  __I  uint32_t  RESERVED1[6];
  __I  uint8_t   DEVICE_ID;                         /*!< (@ 0x400FFF20) A read-only register which provides device identification.
                                                                                                                               */
  __I  uint8_t   DEVICE_REVISION;                   /*!< (@ 0x400FFF21) A read-only register which provides device revision
                                                         information.                                                          */
} GCR_INST_Type;


/* ================================================================================ */
/* ================                   UART0_INST                   ================ */
/* ================================================================================ */


/**
  * @brief The 16550 UART (Universal Asynchronous Receiver/Transmitter) is a
 full-function Two Pin Serial Port that supports the standard RS-232 Interface.  (UART0_INST)
  */

typedef struct {                                    /*!< (@ 0x400F2400) UART0_INST Structure                                   */

  union {
    __IO uint8_t   BAUDRATE_LSB;                    /*!< (@ 0x400F2400) UART Programmable BAUD Rate Generator (LSB) Register
                                                         (DLAB=1)                                                              */
    __O  uint8_t   TX_DATA;                         /*!< (@ 0x400F2400) UART Transmit (Write) Buffer Register (DLAB=0)
                                                                                                                               */
    __I  uint8_t   RX_DATA;                         /*!< (@ 0x400F2400) UART Receive (Read) Buffer Register (DLAB=0)
                                                                                                                               */
  };

  union {
    union {
      __IO uint8_t   INT_EN;                        /*!< (@ 0x400F2401) UART Interrupt Enable Register (DLAB=0)                */

      struct {
        __IO uint8_t   ERDAI    :  1;               /*!< [0..0] ERDAI This bit enables the Received Data Available Interrupt
                                                         (and timeout interrupts in the FIFO mode) when set to logic
                                                          '1'.                                                                 */
        __IO uint8_t   ETHREI   :  1;               /*!< [1..1] ETHREI This bit enables the Transmitter Holding Register
                                                         Empty Interrupt when set to logic '1'.                                */
        __IO uint8_t   ELSI     :  1;               /*!< [2..2] ELSI This bit enables the Received Line Status Interrupt
                                                         when set to logic '1'.                                                */
        __IO uint8_t   EMSI     :  1;               /*!< [3..3] EMSI This bit enables the MODEM Status Interrupt when
                                                         set to logic '1'.                                                     */
      } INT_EN_b;                                   /*!< [4] BitSize                                                           */
    };
    __IO uint8_t   BAUDRATE_MSB;                    /*!< (@ 0x400F2401) UART Programmable BAUD Rate Generator (MSB) Register
                                                         (DLAB=1). [6:0] BAUD_RATE_DIVISOR_MSB, [7:7] BAUD_CLK_SEL
                                                          1=If CLK_SRC is '0', the baud clock is derived from the 1.8432MHz_Clk.
                                                          If CLK_SRC is '1', this bit has no effect
                                                          0=If CLK_SRC is '0', the baud clock is derived from the 24MHz_Clk.
                                                          If CLK_SRC is '1', this bit has no effect                            */
  };

  union {
    union {
      __IO uint8_t   INT_ID;                        /*!< (@ 0x400F2402) UART Interrupt Identification Register                 */

      struct {
        __I  uint8_t   IPEND    :  1;               /*!< [0..0] IPEND This bit can be used in either a hardwired prioritized
                                                         or polled environment to indicate whether an interrupt is pending.
                                                                                                                               */
        __I  uint8_t   INTID    :  3;               /*!< [1..3] INTID These bits identify the highest priority interrupt
                                                         pending                                                               */
             uint8_t            :  2;
        __I  uint8_t   FIFO_EN  :  2;               /*!< [6..7] These two bits are set when the FIFO CONTROL Register
                                                         bit 0 equals 1.                                                       */
      } INT_ID_b;                                   /*!< [8] BitSize                                                           */
    };

    union {
      __IO uint8_t   FIFO_CR;                       /*!< (@ 0x400F2402) UART FIFO Control Register                             */

      struct {
        __O  uint8_t   EXRF     :  1;               /*!< [0..0] EXRF Enable XMIT and RECV FIFO.                                */
        __O  uint8_t   CLEAR_RECV_FIFO:  1;         /*!< [1..1] CLEAR_RECV_FIFO Setting this bit to a logic '1' clears
                                                         all bytes in the RCVR FIFO and resets its counter logic to '0'.
                                                                                                                               */
        __O  uint8_t   CLEAR_XMIT_FIFO:  1;         /*!< [2..2] CLEAR_XMIT_FIFO Setting this bit to a logic '1' clears
                                                         all bytes in the XMIT FIFO and resets its counter logic to '0'
                                                          . The shift register is not cleared. This bit is self-clearing.
                                                                                                                               */
        __IO uint8_t   DMA_MODE_SELECT:  1;         /*!< [3..3] DMA_MODE_SELECT Writing to this bit has no effect on
                                                         the operation of the UART. The RXRDY and TXRDY pins are not
                                                          available on this chip.                                              */
             uint8_t            :  2;
        __IO uint8_t   RECV_FIFO_TRIGGER_LEVEL:  2; /*!< [6..7] RECV_FIFO_TRIGGER_LEVEL These bits are used to set the
                                                         trigger level for the RCVR FIFO interrupt.                            */
      } FIFO_CR_b;                                  /*!< [8] BitSize                                                           */
    };
  };

  union {
    __IO uint8_t   LINE_CR;                         /*!< (@ 0x400F2403) UART Line Control Register                             */

    struct {
      __IO uint8_t   WORD_LENGTH:  2;               /*!< [0..1] WORD_LENGTH These two bits specify the number of bits
                                                         in each transmitted or received serial character.                     */
      __IO uint8_t   STOP_BITS  :  1;               /*!< [2..2] STOP_BITS This bit specifies the number of stop bits
                                                         in each transmitted or received serial character.                     */
      __IO uint8_t   ENABLE_PARITY:  1;             /*!< [3..3] ENABLE_PARITY Parity Enable bit.                               */
      __IO uint8_t   PARITY_SELECT:  1;             /*!< [4..4] PARITY_SELECT Even Parity Select bit.                          */
      __IO uint8_t   STICK_PARITY:  1;              /*!< [5..5] STICK_PARITY Stick Parity bit.                                 */
      __IO uint8_t   BREAK_CONTROL:  1;             /*!< [6..6] BREAK_CONTROL Set Break Control bit                            */
      __IO uint8_t   DLAB       :  1;               /*!< [7..7] DLAB Divisor Latch Access Bit (DLAB).                          */
    } LINE_CR_b;                                    /*!< [8] BitSize                                                           */
  };

  union {
    __IO uint8_t   MODEM_CR;                        /*!< (@ 0x400F2404) UART Modem Control Register                            */

    struct {
      __IO uint8_t   DTR        :  1;               /*!< [0..0] DTR This bit controls the Data Terminal Ready (nDTR)
                                                         output.                                                               */
      __IO uint8_t   RTS        :  1;               /*!< [1..1] RTS This bit controls the Request To Send (nRTS) output.
                                                                                                                               */
      __IO uint8_t   OUT1       :  1;               /*!< [2..2] OUT1 This bit controls the Output 1 (OUT1) bit.                */
      __IO uint8_t   OUT2       :  1;               /*!< [3..3] OUT2 This bit is used to enable an UART interrupt.             */
      __IO uint8_t   LOOPBACK   :  1;               /*!< [4..4] LOOPBACK This bit provides the loopback feature for diagnostic
                                                         testing of the Serial Port.                                           */
    } MODEM_CR_b;                                   /*!< [5] BitSize                                                           */
  };

  union {
    __I  uint8_t   LINE_STS;                        /*!< (@ 0x400F2405) UART Line Status Register                              */

    struct {
      __I  uint8_t   DATA_READY :  1;               /*!< [0..0] DATA_READY Data Ready. It is set to a logic '1' whenever
                                                         a complete incoming character has been received and transferred
                                                          into the Receiver Buffer Register or the FIFO                        */
      __I  uint8_t   OVERRUN    :  1;               /*!< [1..1] OVERRUN Overrun Error.                                         */
      __I  uint8_t   PE         :  1;               /*!< [2..2] PARITY ERROR Parity Error.                                     */
      __I  uint8_t   FRAME_ERROR:  1;               /*!< [3..3] FRAME_ERROR Framing Error.                                     */
      __I  uint8_t   BREAK_INTERRUPT:  1;           /*!< [4..4] BREAK_INTERRUPT Break Interrupt.                               */
      __I  uint8_t   TRANSMIT_EMPTY:  1;            /*!< [5..5] TRANSMIT_EMPTY Transmitter Holding Register Empty Bit
                                                         5 indicates that the Serial Port is ready to accept a new character
                                                          for transmission.                                                    */
      __I  uint8_t   TRANSMIT_ERROR:  1;            /*!< [6..6] Transmitter Empty. Bit 6 is set to a logic '1' whenever
                                                         the Transmitter Holding Register (THR) and Transmitter Shift
                                                          Register (TSR) are both empty.                                       */
      __I  uint8_t   FIFO_ERROR :  1;               /*!< [7..7] FIFO_ERROR                                                     */
    } LINE_STS_b;                                   /*!< [8] BitSize                                                           */
  };

  union {
    __I  uint8_t   MODEM_STS;                       /*!< (@ 0x400F2406) UART Modem Status Register                             */

    struct {
      __I  uint8_t   CTS        :  1;               /*!< [0..0] CTS Delta Clear To Send (DCTS).                                */
      __I  uint8_t   DSR        :  1;               /*!< [1..1] DSR Delta Data Set Ready (DDSR).                               */
      __I  uint8_t   RI         :  1;               /*!< [2..2] RI Trailing Edge of Ring Indicator (TERI).                     */
      __I  uint8_t   DCD        :  1;               /*!< [3..3] DCD Delta Data Carrier Detect (DDCD).                          */
      __IO uint8_t   nCTS       :  1;               /*!< [4..4] nCTS This bit is the complement of the Clear To Send
                                                         (nCTS) input.                                                         */
      __IO uint8_t   nDSR       :  1;               /*!< [5..5] This bit is the complement of the Data Set Ready (nDSR)
                                                         input.                                                                */
      __IO uint8_t   nRI        :  1;               /*!< [6..6] nRI This bit is the complement of the Ring Indicator
                                                         (nRI) input.                                                          */
      __IO uint8_t   nDCD       :  1;               /*!< [7..7] nDCD This bit is the complement of the Data Carrier Detect
                                                         (nDCD) input.                                                         */
    } MODEM_STS_b;                                  /*!< [8] BitSize                                                           */
  };
  __IO uint8_t   SCRATCHPAD;                        /*!< (@ 0x400F2407) UART Scratchpad Register This 8 bit read/write
                                                         register has no effect on the operation of the Serial Port.
                                                          It is intended as a scratchpad register to be used by the programmer
                                                          to hold data temporarily.                                            */
  __I  uint32_t  RESERVED[202];
  __IO uint8_t   ACTIVATE;                          /*!< (@ 0x400F2730) UART Activate Register. [0:0] ACTIVATE When this
                                                         bit is 1, the UART logical device is powered and functional.
                                                          When this bit is 0, the UART logical device is powered down
                                                          and inactive.                                                        */
  __I  uint8_t   RESERVED1[191];

  union {
    __IO uint8_t   CONFIG;                          /*!< (@ 0x400F27F0) UART Config Select Register                            */

    struct {
      __IO uint8_t   CLK_SRC    :  1;               /*!< [0..0] CLK_SRC 1=The UART Baud Clock is derived from an external
                                                         clock source, 0=The UART Baud Clock is derived from one of the
                                                          two internal clock sources                                           */
      __IO uint8_t   POWER      :  1;               /*!< [1..1] POWER 1=The RESET reset signal is derived from nSIO_RESET,
                                                         0=The RESET reset signal is derived from VCC1_RESET                   */
      __IO uint8_t   POLARITY   :  1;               /*!< [2..2] POLARITY 1=The UART_TX and UART_RX pins functions are
                                                         inverted, 0=The UART_TX and UART_RX pins functions are not inverted
                                                                                                                               */
    } CONFIG_b;                                     /*!< [3] BitSize                                                           */
  };
} UART0_INST_Type;


/* ================================================================================ */
/* ================                GPIO_000_036_INST               ================ */
/* ================================================================================ */


/**
  * @brief GPIO 000:036 Pin Control Registers (GPIO_000_036_INST)
  */

typedef struct {                                    /*!< (@ 0x40081000) GPIO_000_036_INST Structure                            */

  union {
    __IO uint32_t  GPIO_000_PIN_CONTROL;            /*!< (@ 0x40081000) GPIO000 Pin Control                                    */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_000_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_001_PIN_CONTROL;            /*!< (@ 0x40081004) GPIO 001 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_001_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_002_PIN_CONTROL;            /*!< (@ 0x40081008) GPIO 002 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_002_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_003_PIN_CONTROL;            /*!< (@ 0x4008100C) GPIO 003 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_003_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_004_PIN_CONTROL;            /*!< (@ 0x40081010) GPIO 004 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_004_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_005_PIN_CONTROL;            /*!< (@ 0x40081014) GPIO 005 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_005_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_006_PIN_CONTROL;            /*!< (@ 0x40081018) GPIO 006 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_006_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_007_PIN_CONTROL;            /*!< (@ 0x4008101C) GPIO 007 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_007_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_010_PIN_CONTROL;            /*!< (@ 0x40081020) GPIO 010 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_010_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_011_PIN_CONTROL;            /*!< (@ 0x40081024) GPIO 011 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_011_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_012_PIN_CONTROL;            /*!< (@ 0x40081028) GPIO 012 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_012_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_013_PIN_CONTROL;            /*!< (@ 0x4008102C) GPIO 013 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_013_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_014_PIN_CONTROL;            /*!< (@ 0x40081030) GPIO 014 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_014_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_015_PIN_CONTROL;            /*!< (@ 0x40081034) GPIO 015 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_015_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_016_PIN_CONTROL;            /*!< (@ 0x40081038) GPIO 016 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_016_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_017_PIN_CONTROL;            /*!< (@ 0x4008103C) GPIO 017 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_017_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_020_PIN_CONTROL;            /*!< (@ 0x40081040) GPIO 020 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_020_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_021_PIN_CONTROL;            /*!< (@ 0x40081044) GPIO 021 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_021_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_022_PIN_CONTROL;            /*!< (@ 0x40081048) GPIO 022 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_022_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_023_PIN_CONTROL;            /*!< (@ 0x4008104C) GPIO 023 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_023_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_024_PIN_CONTROL;            /*!< (@ 0x40081050) GPIO 024 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_024_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_025_PIN_CONTROL;            /*!< (@ 0x40081054) GPIO 025 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_025_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_026_PIN_CONTROL;            /*!< (@ 0x40081058) GPIO 026 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_026_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_027_PIN_CONTROL;            /*!< (@ 0x4008105C) GPIO 027 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_027_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_030_PIN_CONTROL;            /*!< (@ 0x40081060) GPIO 030 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_030_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_031_PIN_CONTROL;            /*!< (@ 0x40081064) GPIO 031 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_031_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_032_PIN_CONTROL;            /*!< (@ 0x40081068) GPIO 032 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_032_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_033_PIN_CONTROL;            /*!< (@ 0x4008106C) GPIO 033 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_033_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_034_PIN_CONTROL;            /*!< (@ 0x40081070) GPIO 034 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_034_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_035_PIN_CONTROL;            /*!< (@ 0x40081074) GPIO 035 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_035_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_036_PIN_CONTROL;            /*!< (@ 0x40081078) GPIO 036 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_036_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };
} GPIO_000_036_INST_Type;


/* ================================================================================ */
/* ================                GPIO_040_076_INST               ================ */
/* ================================================================================ */


/**
  * @brief GPIO 040:076 Pin Control Registers (GPIO_040_076_INST)
  */

typedef struct {                                    /*!< (@ 0x40081080) GPIO_040_076_INST Structure                            */

  union {
    __IO uint32_t  GPIO_040_PIN_CONTROL;            /*!< (@ 0x40081080) GPIO040 Pin Control                                    */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_040_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_041_PIN_CONTROL;            /*!< (@ 0x40081084) GPIO 041 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_041_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_042_PIN_CONTROL;            /*!< (@ 0x40081088) GPIO 042 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_042_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_043_PIN_CONTROL;            /*!< (@ 0x4008108C) GPIO 043 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_043_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_044_PIN_CONTROL;            /*!< (@ 0x40081090) GPIO 044 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_044_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_045_PIN_CONTROL;            /*!< (@ 0x40081094) GPIO 045 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_045_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_046_PIN_CONTROL;            /*!< (@ 0x40081098) GPIO 046 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_046_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_047_PIN_CONTROL;            /*!< (@ 0x4008109C) GPIO 047 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_047_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_050_PIN_CONTROL;            /*!< (@ 0x400810A0) GPIO 050 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_050_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_051_PIN_CONTROL;            /*!< (@ 0x400810A4) GPIO 051 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_051_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_052_PIN_CONTROL;            /*!< (@ 0x400810A8) GPIO 052 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_052_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_053_PIN_CONTROL;            /*!< (@ 0x400810AC) GPIO 053 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_053_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_054_PIN_CONTROL;            /*!< (@ 0x400810B0) GPIO 054 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_054_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_055_PIN_CONTROL;            /*!< (@ 0x400810B4) GPIO 055 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_055_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_056_PIN_CONTROL;            /*!< (@ 0x400810B8) GPIO 056 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_056_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_057_PIN_CONTROL;            /*!< (@ 0x400810BC) GPIO 057 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_057_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_060_PIN_CONTROL;            /*!< (@ 0x400810C0) GPIO 060 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_060_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_061_PIN_CONTROL;            /*!< (@ 0x400810C4) GPIO 061 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_061_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_062_PIN_CONTROL;            /*!< (@ 0x400810C8) GPIO 062 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_062_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_063_PIN_CONTROL;            /*!< (@ 0x400810CC) GPIO 063 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_063_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_064_PIN_CONTROL;            /*!< (@ 0x400810D0) GPIO 064 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_064_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_065_PIN_CONTROL;            /*!< (@ 0x400810D4) GPIO 065 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_065_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_066_PIN_CONTROL;            /*!< (@ 0x400810D8) GPIO 066 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_066_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_067_PIN_CONTROL;            /*!< (@ 0x400810DC) GPIO 067 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_067_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_070_PIN_CONTROL;            /*!< (@ 0x400810E0) GPIO 070 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_070_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_071_PIN_CONTROL;            /*!< (@ 0x400810E4) GPIO 071 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_071_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_072_PIN_CONTROL;            /*!< (@ 0x400810E8) GPIO 072 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_072_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_073_PIN_CONTROL;            /*!< (@ 0x400810EC) GPIO 073 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_073_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_074_PIN_CONTROL;            /*!< (@ 0x400810F0) GPIO 074 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_074_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_075_PIN_CONTROL;            /*!< (@ 0x400810F4) GPIO 075 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_075_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_076_PIN_CONTROL;            /*!< (@ 0x400810F8) GPIO 076 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input),10b=Unpowered. The GPIO pad is
                                                          turned off completely. Both the input buffer and output buffer
                                                          on the pad are disabled. Pull-up and pull-down resisters
                                                          are disabled independent of the setting of the PU/PD field.
                                                          11b=VTR Powered Output Only. Input pad is disabled and
                                                          output will be tristated when VTR Power Rail is off.                 */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_076_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };
} GPIO_040_076_INST_Type;


/* ================================================================================ */
/* ================                GPIO_100_137_INST               ================ */
/* ================================================================================ */


/**
  * @brief GPIO 100:137 Pin Control Registers (GPIO_100_137_INST)
  */

typedef struct {                                    /*!< (@ 0x40081100) GPIO_100_137_INST Structure                            */

  union {
    __IO uint32_t  GPIO_100_PIN_CONTROL;            /*!< (@ 0x40081100) GPIO100 Pin Control                                    */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_100_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_101_PIN_CONTROL;            /*!< (@ 0x40081104) GPIO 101 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_101_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_102_PIN_CONTROL;            /*!< (@ 0x40081108) GPIO 102 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_102_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_103_PIN_CONTROL;            /*!< (@ 0x4008110C) GPIO 103 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_103_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_104_PIN_CONTROL;            /*!< (@ 0x40081110) GPIO 104 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_104_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_105_PIN_CONTROL;            /*!< (@ 0x40081114) GPIO 105 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_105_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_106_PIN_CONTROL;            /*!< (@ 0x40081118) GPIO 106 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_106_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_107_PIN_CONTROL;            /*!< (@ 0x4008111C) GPIO 107 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_107_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_110_PIN_CONTROL;            /*!< (@ 0x40081120) GPIO 110 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_110_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_111_PIN_CONTROL;            /*!< (@ 0x40081124) GPIO 111 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_111_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_112_PIN_CONTROL;            /*!< (@ 0x40081128) GPIO 112 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_112_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_113_PIN_CONTROL;            /*!< (@ 0x4008112C) GPIO 113 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_113_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_114_PIN_CONTROL;            /*!< (@ 0x40081130) GPIO 114 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_114_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_115_PIN_CONTROL;            /*!< (@ 0x40081134) GPIO 115 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_115_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_116_PIN_CONTROL;            /*!< (@ 0x40081138) GPIO 116 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_116_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_117_PIN_CONTROL;            /*!< (@ 0x4008113C) GPIO 117 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_117_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_120_PIN_CONTROL;            /*!< (@ 0x40081140) GPIO 120 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_120_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_121_PIN_CONTROL;            /*!< (@ 0x40081144) GPIO 121 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_121_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_122_PIN_CONTROL;            /*!< (@ 0x40081148) GPIO 122 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_122_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_123_PIN_CONTROL;            /*!< (@ 0x4008114C) GPIO 123 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_123_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_124_PIN_CONTROL;            /*!< (@ 0x40081150) GPIO 124 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_124_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_125_PIN_CONTROL;            /*!< (@ 0x40081154) GPIO 125 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_125_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_126_PIN_CONTROL;            /*!< (@ 0x40081158) GPIO 126 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_126_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_127_PIN_CONTROL;            /*!< (@ 0x4008115C) GPIO 127 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_127_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_130_PIN_CONTROL;            /*!< (@ 0x40081160) GPIO 130 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_130_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_131_PIN_CONTROL;            /*!< (@ 0x40081164) GPIO 131 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_131_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_132_PIN_CONTROL;            /*!< (@ 0x40081168) GPIO 132 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_132_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_133_PIN_CONTROL;            /*!< (@ 0x4008116C) GPIO 133 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_133_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_134_PIN_CONTROL;            /*!< (@ 0x40081170) GPIO 134 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_134_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_135_PIN_CONTROL;            /*!< (@ 0x40081174) GPIO 135 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00b = VTR Power Rail. 01b = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input).
                                                          11b=VTR Powered Output Only: Input pad is disabled and output
                                                          will be tristated when VTR Power Rail is off.
                                                          10b=Unpowered. The GPIO pad is turned off completely. Both
                                                          the input buffer and output buffer on the pad are disabled.

                                                          Pull-up and pull-down resisters are disabled independent of
                                                          the setting of the PU/PD field.                                      */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_135_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };
} GPIO_100_137_INST_Type;


/* ================================================================================ */
/* ================                GPIO_140_176_INST               ================ */
/* ================================================================================ */


/**
  * @brief GPIO 140:176 Pin Control Registers (GPIO_140_176_INST)
  */

typedef struct {                                    /*!< (@ 0x40081180) GPIO_140_176_INST Structure                            */

  union {
    __IO uint32_t  GPIO_140_PIN_CONTROL;            /*!< (@ 0x40081180) GPIO140 Pin Control                                    */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_140_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_141_PIN_CONTROL;            /*!< (@ 0x40081184) GPIO 141 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_141_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_142_PIN_CONTROL;            /*!< (@ 0x40081188) GPIO 142 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_142_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_143_PIN_CONTROL;            /*!< (@ 0x4008118C) GPIO 143 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_143_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_144_PIN_CONTROL;            /*!< (@ 0x40081190) GPIO 144 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_144_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_145_PIN_CONTROL;            /*!< (@ 0x40081194) GPIO 145 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_145_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_146_PIN_CONTROL;            /*!< (@ 0x40081198) GPIO 146 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_146_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_147_PIN_CONTROL;            /*!< (@ 0x4008119C) GPIO 147 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_147_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_150_PIN_CONTROL;            /*!< (@ 0x400811A0) GPIO 150 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_150_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_151_PIN_CONTROL;            /*!< (@ 0x400811A4) GPIO 151 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_151_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_152_PIN_CONTROL;            /*!< (@ 0x400811A8) GPIO 152 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_152_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_153_PIN_CONTROL;            /*!< (@ 0x400811AC) GPIO 153 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_153_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_154_PIN_CONTROL;            /*!< (@ 0x400811B0) GPIO 154 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_154_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_155_PIN_CONTROL;            /*!< (@ 0x400811B4) GPIO 155 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_155_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_156_PIN_CONTROL;            /*!< (@ 0x400811B8) GPIO 156 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_156_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_157_PIN_CONTROL;            /*!< (@ 0x400811BC) GPIO 157 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_157_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_160_PIN_CONTROL;            /*!< (@ 0x400811C0) GPIO 160 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_160_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_161_PIN_CONTROL;            /*!< (@ 0x400811C4) GPIO 161 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_161_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_162_PIN_CONTROL;            /*!< (@ 0x400811C8) GPIO 162 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_162_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_163_PIN_CONTROL;            /*!< (@ 0x400811CC) GPIO 163 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_163_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_164_PIN_CONTROL;            /*!< (@ 0x400811D0) GPIO 164 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_164_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_165_PIN_CONTROL;            /*!< (@ 0x400811D4) GPIO 165 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_165_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_166_PIN_CONTROL;            /*!< (@ 0x400811D8) GPIO 166 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_166_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_167_PIN_CONTROL;            /*!< (@ 0x400811DC) GPIO 167 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_167_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_170_PIN_CONTROL;            /*!< (@ 0x400811E0) GPIO 170 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_170_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_171_PIN_CONTROL;            /*!< (@ 0x400811E4) GPIO 171 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_171_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_172_PIN_CONTROL;            /*!< (@ 0x400811E8) GPIO 172 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_172_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_173_PIN_CONTROL;            /*!< (@ 0x400811EC) GPIO 173 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_173_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_174_PIN_CONTROL;            /*!< (@ 0x400811F0) GPIO 174 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_174_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_175_PIN_CONTROL;            /*!< (@ 0x400811F4) GPIO 175 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_175_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };
} GPIO_140_176_INST_Type;


/* ================================================================================ */
/* ================                GPIO_200_236_INST               ================ */
/* ================================================================================ */


/**
  * @brief GPIO 200:236 Pin Control Registers (GPIO_200_236_INST)
  */

typedef struct {                                    /*!< (@ 0x40081200) GPIO_200_236_INST Structure                            */

  union {
    __IO uint32_t  GPIO_200_PIN_CONTROL;            /*!< (@ 0x40081200) GPIO200 Pin Control                                    */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_200_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_201_PIN_CONTROL;            /*!< (@ 0x40081204) GPIO 201 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_201_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_202_PIN_CONTROL;            /*!< (@ 0x40081208) GPIO 202 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_202_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_203_PIN_CONTROL;            /*!< (@ 0x4008120C) GPIO 203 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_203_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_204_PIN_CONTROL;            /*!< (@ 0x40081210) GPIO 204 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_204_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_205_PIN_CONTROL;            /*!< (@ 0x40081214) GPIO 205 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_205_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_206_PIN_CONTROL;            /*!< (@ 0x40081218) GPIO 206 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_206_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_207_PIN_CONTROL;            /*!< (@ 0x4008121C) GPIO 207 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_207_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_210_PIN_CONTROL;            /*!< (@ 0x40081220) GPIO 210 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_210_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_211_PIN_CONTROL;            /*!< (@ 0x40081224) GPIO 211 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_211_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_212_PIN_CONTROL;            /*!< (@ 0x40081228) GPIO 212 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_212_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_213_PIN_CONTROL;            /*!< (@ 0x4008122C) GPIO 213 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_213_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_214_PIN_CONTROL;            /*!< (@ 0x40081230) GPIO 214 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_214_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_215_PIN_CONTROL;            /*!< (@ 0x40081234) GPIO 215 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_215_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_216_PIN_CONTROL;            /*!< (@ 0x40081238) GPIO 216 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_216_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_217_PIN_CONTROL;            /*!< (@ 0x4008123C) GPIO 217 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_217_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };
  __I  uint32_t  RESERVED;

  union {
    __IO uint32_t  GPIO_221_PIN_CONTROL;            /*!< (@ 0x40081244) GPIO 221 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_221_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_222_PIN_CONTROL;            /*!< (@ 0x40081248) GPIO 222 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_222_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_223_PIN_CONTROL;            /*!< (@ 0x4008124C) GPIO 223 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_223_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_224_PIN_CONTROL;            /*!< (@ 0x40081250) GPIO 224 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_224_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_225_PIN_CONTROL;            /*!< (@ 0x40081254) GPIO 225 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_225_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_226_PIN_CONTROL;            /*!< (@ 0x40081258) GPIO 226 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_226_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_227_PIN_CONTROL;            /*!< (@ 0x4008125C) GPIO 227 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_227_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_230_PIN_CONTROL;            /*!< (@ 0x40081260) GPIO 230 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_230_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_231_PIN_CONTROL;            /*!< (@ 0x40081264) GPIO 231 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_231_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };
  __I  uint32_t  RESERVED1;

  union {
    __IO uint32_t  GPIO_233_PIN_CONTROL;            /*!< (@ 0x4008126C) GPIO 233 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_233_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_234_PIN_CONTROL;            /*!< (@ 0x40081270) GPIO 234 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_234_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_235_PIN_CONTROL;            /*!< (@ 0x40081274) GPIO 235 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_235_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };
} GPIO_200_236_INST_Type;


/* ================================================================================ */
/* ================                GPIO_240_257_INST               ================ */
/* ================================================================================ */


/**
  * @brief GPIO 240:257 Pin Control Registers (GPIO_240_257_INST)
  */

typedef struct {                                    /*!< (@ 0x40081280) GPIO_240_257_INST Structure                            */

  union {
    __IO uint32_t  GPIO_240_PIN_CONTROL;            /*!< (@ 0x40081280) GPIO240 Pin Control                                    */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_240_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_241_PIN_CONTROL;            /*!< (@ 0x40081284) GPIO 241 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_241_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_242_PIN_CONTROL;            /*!< (@ 0x40081288) GPIO 242 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_242_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_243_PIN_CONTROL;            /*!< (@ 0x4008128C) GPIO 243 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_243_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_244_PIN_CONTROL;            /*!< (@ 0x40081290) GPIO 244 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_244_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_245_PIN_CONTROL;            /*!< (@ 0x40081294) GPIO 245 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_245_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_246_PIN_CONTROL;            /*!< (@ 0x40081298) GPIO 246 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_246_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };
  __I  uint32_t  RESERVED;

  union {
    __IO uint32_t  GPIO_250_PIN_CONTROL;            /*!< (@ 0x400812A0) GPIO 250 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_250_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };
  __I  uint32_t  RESERVED1[2];

  union {
    __IO uint32_t  GPIO_253_PIN_CONTROL;            /*!< (@ 0x400812AC) GPIO 253 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_253_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  GPIO_254_PIN_CONTROL;            /*!< (@ 0x400812B0) GPIO 254 Pin Control                                   */

    struct {
      __IO uint32_t  PU_PD      :  2;               /*!< [0..1] These bits are used to enable an internal pull-up or
                                                         pull-down resistor.
                                                          00 = None, 01 = Pull Up Enabled, 10 = Pull Down Enabled, 11
                                                          = None                                                               */
      __IO uint32_t  POWER_GATING:  2;              /*!< [2..3] The GPIO pin will be tristated when the selected power
                                                         well is off.
                                                          00 = VTR Power Rail, 01 = VCC Main Power Rail (as determined
                                                          by the VCC_PWRGD input), 1x = Reserved                               */
      __IO uint32_t  INTERRUPT_DETECTION:  3;       /*!< [4..6] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 000 = Low Level Sensitive
                                                          0 001 = High Level Sensitive
                                                          0 100 = Interrupt events are disabled
                                                          1 101 = Rising Edge Triggered
                                                          1 110 = Falling Edge Triggered
                                                          1 111 = Either edge triggered                                        */
      __IO uint32_t  EDGE_ENABLE:  1;               /*!< [7..7] When combined with the field INTERRUPT_DETECTION in this
                                                         register, determines the interrupt capability of the GPIO input.
                                                          0 = Edge detection disabled, 1 = Edge detection enabled              */
      __IO uint32_t  OUTPUT_BUFFER_TYPE:  1;        /*!< [8..8] Unless explicitly stated otherwise, pins with (I/O/OD)
                                                         or (O/OD) in their buffer type column in the tables are
                                                          compliant with the following Programmable OD/PP Multiplexing
                                                          Design Rule: Each compliant pin has a programmable open drain/push-pull
                                                          buffer controlled by the Output Buffer Type bit in the associated
                                                          Pin Control Register. The state of this bit controls the mode
                                                          of
                                                          the interface buffer for all selected functions, including
                                                          the GPIO function. 0 = Push-Pull, 1 = Open Drain                     */
      __IO uint32_t  GPIO_DIRECTION:  1;            /*!< [9..9] This bit controls the buffer direction only when the
                                                         MUX_CONTROL field is '00' selecting the pin signal function
                                                          to
                                                          be GPIO. When the MUX_CONTROL field is greater than '00' (i.e.,
                                                          a non-GPIO signal function is selected) this bit has no affect
                                                          and the selected signal function logic directly controls the
                                                          pin direction. 0 = Input, 1 = Output                                 */
      __IO uint32_t  GPIO_OUTPUT_SELECT:  1;        /*!< [10..10] This control bit determines which register is used
                                                         to update the data register for GPIO outputs.
                                                          0=GPIO output data for this GPIO come from the ALTERNATE_GPIO_DATA
                                                          field of this register; writes to the bit representing
                                                          this GPIO in the GPIO Output Register do not affect the GPIO;
                                                          1=GPIO output data for this GPIO come from the bit representing
                                                          this GPIO in the GPIO Output Register; writes to the ALTERNATE_GPIO_DATA
                                                          field of this register do not affect the GPIO.                       */
      __IO uint32_t  POLARITY   :  1;               /*!< [11..11] When the Polarity bit is set to '1' and the MUX_CONTROL
                                                         bits are greater than '00', the selected signal function outputs
                                                          are inverted and Interrupt Detection sense is inverted. When
                                                          the MUX_CONTROL field selects the GPIO signal function (Mux='00'),
                                                          the
                                                          Polarity bit does not effect the output. Regardless of the
                                                          state of the MUX_CONTROL field and the Polarity bit, the state
                                                          of the pin
                                                          is always reported without inversion in the GPIO input register.
                                                          1=Inverted; 0=Non-inverted                                           */
      __IO uint32_t  MUX_CONTROL:  2;               /*!< [12..13] This field determines the active signal function for
                                                         a pin. 00 = GPIO Function Selected, 01 = Signal Function 1 Selected,
                                                          10 = Signal Function 2 Selected, 11 = Signal Function 3 Selected.
                                                                                                                               */
           uint32_t             :  2;
      __IO uint32_t  ALTERNATE_GPIO_DATA:  1;       /*!< [16..16] Reads of this bit always return the last data written
                                                         to the GPIO output data register bit; reads do not return the
                                                          current output value of the GPIO pin if it is configured as
                                                          an output. If the GPIO_OUTPUT_SELECT bit in this register is
                                                          '1', then
                                                          this bit is Read Only and the GPIO output data register bit
                                                          is only written by the GPIO Output Register. If the GPIO_OUTPUT_SELECT
                                                          bit in this register is '0', then this bit is R/W, and the
                                                          bit corresponding to this GPIO in the GPIO Output Register is
                                                          Read Only                                                            */
           uint32_t             :  7;
      __I  uint32_t  GPIO_INPUT :  1;               /*!< [24..24] Reads of this bit always return the state of GPIO input
                                                         from the pad, independent of the Mux selection for the pin
                                                          or the Direction. This bit is forced high when the selected
                                                          power well is off as selected by the POWER_GATING field in this
                                                          register.                                                            */
    } GPIO_254_PIN_CONTROL_b;                       /*!< [25] BitSize                                                          */
  };
} GPIO_240_257_INST_Type;


/* ================================================================================ */
/* ================             INPUT_OUTPUT_GPIO_INST             ================ */
/* ================================================================================ */


/**
  * @brief GPIO Input/Output Registers (INPUT_OUTPUT_GPIO_INST)
  */

typedef struct {                                    /*!< (@ 0x40081300) INPUT_OUTPUT_GPIO_INST Structure                       */
  __IO uint32_t  INPUT_GPIO_000_036;                /*!< (@ 0x40081300) The GPIO Input Registers can always be used to
                                                         read the state of a pin, even when the pin is in an output mode
                                                          and/or when a
                                                          signal function other than the GPIO signal function is selected.
                                                                                                                               */
  __IO uint32_t  INPUT_GPIO_040_076;                /*!< (@ 0x40081304) Input GPIO[040:076]                                    */
  __IO uint32_t  INPUT_GPIO_100_136;                /*!< (@ 0x40081308) Input GPIO[100:136]                                    */
  __IO uint32_t  INPUT_GPIO_140_176;                /*!< (@ 0x4008130C) Input GPIO[140:176]                                    */
  __IO uint32_t  INPUT_GPIO_200_236;                /*!< (@ 0x40081310) Input GPIO[200:236]                                    */
  __IO uint32_t  INPUT_GPIO_240_276;                /*!< (@ 0x40081314) Input GPIO[240:276]                                    */
  __I  uint32_t  RESERVED[26];
  __IO uint32_t  OUTPUT_GPIO_000_036;               /*!< (@ 0x40081380) If enabled by the Output GPIO Write Enable bit,
                                                         the GPIO Output bits determine the level on the GPIO pin when
                                                          the pin is
                                                          configured for the GPIO output function. On writes: If enabled
                                                          via the Output GPIO Write Enable 0: GPIO[x] out = '0', 1: GPIO[x]
                                                          out = '1'.                                                           */
  __IO uint32_t  OUPUT_GPIO_040_076;                /*!< (@ 0x40081384) Output GPIO[040:076]                                   */
  __IO uint32_t  OUTPUT_GPIO_100_136;               /*!< (@ 0x40081388) Output GPIO[100:136]                                   */
  __IO uint32_t  OUTPUT_GPIO_140_176;               /*!< (@ 0x4008138C) Output GPIO[140:176]                                   */
  __IO uint32_t  OUTPUT_GPIO_200_236;               /*!< (@ 0x40081390) Output GPIO[200:236]                                   */
  __IO uint32_t  OUTPUT_GPIO_240_276;               /*!< (@ 0x40081394) Output GPIO[240:276]                                   */
} INPUT_OUTPUT_GPIO_INST_Type;


/* ================================================================================ */
/* ================             GPIO_PIN_CONTROL_2_INST            ================ */
/* ================================================================================ */


/**
  * @brief GPIO Pin Control 2 Registers (GPIO_PIN_CONTROL_2_INST)
  */

typedef struct {                                    /*!< (@ 0x40081500) GPIO_PIN_CONTROL_2_INST Structure                      */

  union {
    __IO uint32_t  GPIO_000_PIN_CONTROL_2;          /*!< (@ 0x40081500) GPIO 000 PIN CONTROL REGISTER 2                        */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_000_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_001_PIN_CONTROL_2;          /*!< (@ 0x40081504) GPIO 001 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_001_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_002_PIN_CONTROL_2;          /*!< (@ 0x40081508) GPIO 002 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_002_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_003_PIN_CONTROL_2;          /*!< (@ 0x4008150C) GPIO 003 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_003_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_004_PIN_CONTROL_2;          /*!< (@ 0x40081510) GPIO 004 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_004_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_005_PIN_CONTROL_2;          /*!< (@ 0x40081514) GPIO 005 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_005_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_006_PIN_CONTROL_2;          /*!< (@ 0x40081518) GPIO 006 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_006_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_007_PIN_CONTROL_2;          /*!< (@ 0x4008151C) GPIO 007 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_007_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_010_PIN_CONTROL_2;          /*!< (@ 0x40081520) GPIO 010 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_010_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_011_PIN_CONTROL_2;          /*!< (@ 0x40081524) GPIO 011 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_011_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_012_PIN_CONTROL_2;          /*!< (@ 0x40081528) GPIO 012 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_012_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_013_PIN_CONTROL_2;          /*!< (@ 0x4008152C) GPIO 013 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_013_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_014_PIN_CONTROL_2;          /*!< (@ 0x40081530) GPIO 014 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_014_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_015_PIN_CONTROL_2;          /*!< (@ 0x40081534) GPIO 015 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_015_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_016_PIN_CONTROL_2;          /*!< (@ 0x40081538) GPIO 016 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_016_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_017_PIN_CONTROL_2;          /*!< (@ 0x4008153C) GPIO 017 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_017_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_020_PIN_CONTROL_2;          /*!< (@ 0x40081540) GPIO 020 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_020_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_021_PIN_CONTROL_2;          /*!< (@ 0x40081544) GPIO 021 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_021_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_022_PIN_CONTROL_2;          /*!< (@ 0x40081548) GPIO 022 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_022_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_023_PIN_CONTROL_2;          /*!< (@ 0x4008154C) GPIO 023 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_023_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_024_PIN_CONTROL_2;          /*!< (@ 0x40081550) GPIO 024 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_024_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_025_PIN_CONTROL_2;          /*!< (@ 0x40081554) GPIO 025 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_025_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_026_PIN_CONTROL_2;          /*!< (@ 0x40081558) GPIO 026 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_026_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_027_PIN_CONTROL_2;          /*!< (@ 0x4008155C) GPIO 027 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_027_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_030_PIN_CONTROL_2;          /*!< (@ 0x40081560) GPIO 030 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_030_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_031_PIN_CONTROL_2;          /*!< (@ 0x40081564) GPIO 031 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_031_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_032_PIN_CONTROL_2;          /*!< (@ 0x40081568) GPIO 032 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_032_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_033_PIN_CONTROL_2;          /*!< (@ 0x4008156C) GPIO 033 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_033_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_034_PIN_CONTROL_2;          /*!< (@ 0x40081570) GPIO 034 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_034_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_035_PIN_CONTROL_2;          /*!< (@ 0x40081574) GPIO 035 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_035_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_036_PIN_CONTROL_2;          /*!< (@ 0x40081578) GPIO 036 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_036_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };
  __I  uint32_t  RESERVED;

  union {
    __IO uint32_t  GPIO_040_PIN_CONTROL_2;          /*!< (@ 0x40081580) GPIO 040 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_040_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_041_PIN_CONTROL_2;          /*!< (@ 0x40081584) GPIO 041 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_041_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_042_PIN_CONTROL_2;          /*!< (@ 0x40081588) GPIO 042 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_042_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_043_PIN_CONTROL_2;          /*!< (@ 0x4008158C) GPIO 043 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_043_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_044_PIN_CONTROL_2;          /*!< (@ 0x40081590) GPIO 044 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_044_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_045_PIN_CONTROL_2;          /*!< (@ 0x40081594) GPIO 045 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_045_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_046_PIN_CONTROL_2;          /*!< (@ 0x40081598) GPIO 046 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_046_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_047_PIN_CONTROL_2;          /*!< (@ 0x4008159C) GPIO 047 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_047_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_050_PIN_CONTROL_2;          /*!< (@ 0x400815A0) GPIO 050 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_050_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_051_PIN_CONTROL_2;          /*!< (@ 0x400815A4) GPIO 051 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_051_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_052_PIN_CONTROL_2;          /*!< (@ 0x400815A8) GPIO 052 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_052_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_053_PIN_CONTROL_2;          /*!< (@ 0x400815AC) GPIO 053 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_053_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_054_PIN_CONTROL_2;          /*!< (@ 0x400815B0) GPIO 054 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_054_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_055_PIN_CONTROL_2;          /*!< (@ 0x400815B4) GPIO 055 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_055_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_056_PIN_CONTROL_2;          /*!< (@ 0x400815B8) GPIO 056 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_056_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_057_PIN_CONTROL_2;          /*!< (@ 0x400815BC) GPIO 057 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_057_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_060_PIN_CONTROL_2;          /*!< (@ 0x400815C0) GPIO 060 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_060_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_061_PIN_CONTROL_2;          /*!< (@ 0x400815C4) GPIO 061 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_061_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_062_PIN_CONTROL_2;          /*!< (@ 0x400815C8) GPIO 062 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_062_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_063_PIN_CONTROL_2;          /*!< (@ 0x400815CC) GPIO 063 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_063_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_064_PIN_CONTROL_2;          /*!< (@ 0x400815D0) GPIO 064 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_064_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_065_PIN_CONTROL_2;          /*!< (@ 0x400815D4) GPIO 065 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_065_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_066_PIN_CONTROL_2;          /*!< (@ 0x400815D8) GPIO 066 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_066_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_067_PIN_CONTROL_2;          /*!< (@ 0x400815DC) GPIO 067 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_067_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_070_PIN_CONTROL_2;          /*!< (@ 0x400815E0) GPIO 070 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_070_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_071_PIN_CONTROL_2;          /*!< (@ 0x400815E4) GPIO 071 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_071_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_072_PIN_CONTROL_2;          /*!< (@ 0x400815E8) GPIO 072 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_072_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_073_PIN_CONTROL_2;          /*!< (@ 0x400815EC) GPIO 073 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_073_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_074_PIN_CONTROL_2;          /*!< (@ 0x400815F0) GPIO 074 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_074_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_075_PIN_CONTROL_2;          /*!< (@ 0x400815F4) GPIO 075 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_075_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_076_PIN_CONTROL_2;          /*!< (@ 0x400815F8) GPIO 076 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_076_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };
  __I  uint32_t  RESERVED1;

  union {
    __IO uint32_t  GPIO_100_PIN_CONTROL_2;          /*!< (@ 0x40081600) GPIO 100 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_100_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_101_PIN_CONTROL_2;          /*!< (@ 0x40081604) GPIO 101 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_101_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_102_PIN_CONTROL_2;          /*!< (@ 0x40081608) GPIO 102 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_102_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_103_PIN_CONTROL_2;          /*!< (@ 0x4008160C) GPIO 103 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_103_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_104_PIN_CONTROL_2;          /*!< (@ 0x40081610) GPIO 104 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_104_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_105_PIN_CONTROL_2;          /*!< (@ 0x40081614) GPIO 105 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_105_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_106_PIN_CONTROL_2;          /*!< (@ 0x40081618) GPIO 106 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_106_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_107_PIN_CONTROL_2;          /*!< (@ 0x4008161C) GPIO 107 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_107_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_110_PIN_CONTROL_2;          /*!< (@ 0x40081620) GPIO 110 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_110_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_111_PIN_CONTROL_2;          /*!< (@ 0x40081624) GPIO 111 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_111_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_112_PIN_CONTROL_2;          /*!< (@ 0x40081628) GPIO 112 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_112_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_113_PIN_CONTROL_2;          /*!< (@ 0x4008162C) GPIO 113 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_113_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_114_PIN_CONTROL_2;          /*!< (@ 0x40081630) GPIO 114 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_114_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_115_PIN_CONTROL_2;          /*!< (@ 0x40081634) GPIO 115 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_115_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_116_PIN_CONTROL_2;          /*!< (@ 0x40081638) GPIO 116 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_116_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_117_PIN_CONTROL_2;          /*!< (@ 0x4008163C) GPIO 117 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_117_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_120_PIN_CONTROL_2;          /*!< (@ 0x40081640) GPIO 120 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_120_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_121_PIN_CONTROL_2;          /*!< (@ 0x40081644) GPIO 121 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_121_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_122_PIN_CONTROL_2;          /*!< (@ 0x40081648) GPIO 122 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_122_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_123_PIN_CONTROL_2;          /*!< (@ 0x4008164C) GPIO 123 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_123_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_124_PIN_CONTROL_2;          /*!< (@ 0x40081650) GPIO 124 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_124_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_125_PIN_CONTROL_2;          /*!< (@ 0x40081654) GPIO 125 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_125_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_126_PIN_CONTROL_2;          /*!< (@ 0x40081658) GPIO 126 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_126_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_127_PIN_CONTROL_2;          /*!< (@ 0x4008165C) GPIO 127 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_127_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_130_PIN_CONTROL_2;          /*!< (@ 0x40081660) GPIO 130 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_130_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_131_PIN_CONTROL_2;          /*!< (@ 0x40081664) GPIO 131 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_131_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_132_PIN_CONTROL_2;          /*!< (@ 0x40081668) GPIO 132 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_132_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_133_PIN_CONTROL_2;          /*!< (@ 0x4008166C) GPIO 133 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_133_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_134_PIN_CONTROL_2;          /*!< (@ 0x40081670) GPIO 134 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_134_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_135_PIN_CONTROL_2;          /*!< (@ 0x40081674) GPIO 135 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_135_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };
  __I  uint32_t  RESERVED2[2];

  union {
    __IO uint32_t  GPIO_140_PIN_CONTROL_2;          /*!< (@ 0x40081680) GPIO 140 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_140_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_141_PIN_CONTROL_2;          /*!< (@ 0x40081684) GPIO 141 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_141_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_142_PIN_CONTROL_2;          /*!< (@ 0x40081688) GPIO 142 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_142_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_143_PIN_CONTROL_2;          /*!< (@ 0x4008168C) GPIO 143 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_143_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_144_PIN_CONTROL_2;          /*!< (@ 0x40081690) GPIO 144 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_144_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_145_PIN_CONTROL_2;          /*!< (@ 0x40081694) GPIO 145 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_145_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_146_PIN_CONTROL_2;          /*!< (@ 0x40081698) GPIO 146 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_146_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_147_PIN_CONTROL_2;          /*!< (@ 0x4008169C) GPIO 147 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_147_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_150_PIN_CONTROL_2;          /*!< (@ 0x400816A0) GPIO 150 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_150_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_151_PIN_CONTROL_2;          /*!< (@ 0x400816A4) GPIO 151 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_151_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_152_PIN_CONTROL_2;          /*!< (@ 0x400816A8) GPIO 152 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_152_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_153_PIN_CONTROL_2;          /*!< (@ 0x400816AC) GPIO 153 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_153_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_154_PIN_CONTROL_2;          /*!< (@ 0x400816B0) GPIO 154 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_154_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_155_PIN_CONTROL_2;          /*!< (@ 0x400816B4) GPIO 155 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_155_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_156_PIN_CONTROL_2;          /*!< (@ 0x400816B8) GPIO 156 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_156_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_157_PIN_CONTROL_2;          /*!< (@ 0x400816BC) GPIO 157 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_157_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_160_PIN_CONTROL_2;          /*!< (@ 0x400816C0) GPIO 160 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_160_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_161_PIN_CONTROL_2;          /*!< (@ 0x400816C4) GPIO 161 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_161_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_162_PIN_CONTROL_2;          /*!< (@ 0x400816C8) GPIO 162 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_162_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_163_PIN_CONTROL_2;          /*!< (@ 0x400816CC) GPIO 163 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_163_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_164_PIN_CONTROL_2;          /*!< (@ 0x400816D0) GPIO 164 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_164_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_165_PIN_CONTROL_2;          /*!< (@ 0x400816D4) GPIO 165 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_165_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_166_PIN_CONTROL_2;          /*!< (@ 0x400816D8) GPIO 166 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_166_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_167_PIN_CONTROL_2;          /*!< (@ 0x400816DC) GPIO 167 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_167_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_170_PIN_CONTROL_2;          /*!< (@ 0x400816E0) GPIO 170 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_170_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_171_PIN_CONTROL_2;          /*!< (@ 0x400816E4) GPIO 171 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_171_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_172_PIN_CONTROL_2;          /*!< (@ 0x400816E8) GPIO 172 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_172_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_173_PIN_CONTROL_2;          /*!< (@ 0x400816EC) GPIO 173 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_173_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_174_PIN_CONTROL_2;          /*!< (@ 0x400816F0) GPIO 174 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_174_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_175_PIN_CONTROL_2;          /*!< (@ 0x400816F4) GPIO 175 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_175_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };
  __I  uint32_t  RESERVED3[2];

  union {
    __IO uint32_t  GPIO_200_PIN_CONTROL_2;          /*!< (@ 0x40081700) GPIO 200 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_200_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_201_PIN_CONTROL_2;          /*!< (@ 0x40081704) GPIO 201 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_201_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_202_PIN_CONTROL_2;          /*!< (@ 0x40081708) GPIO 202 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_202_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_203_PIN_CONTROL_2;          /*!< (@ 0x4008170C) GPIO 203 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_203_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_204_PIN_CONTROL_2;          /*!< (@ 0x40081710) GPIO 204 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_204_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_205_PIN_CONTROL_2;          /*!< (@ 0x40081714) GPIO 205 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_205_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_206_PIN_CONTROL_2;          /*!< (@ 0x40081718) GPIO 206 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_206_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_207_PIN_CONTROL_2;          /*!< (@ 0x4008171C) GPIO 207 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_207_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_210_PIN_CONTROL_2;          /*!< (@ 0x40081720) GPIO 210 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_210_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_211_PIN_CONTROL_2;          /*!< (@ 0x40081724) GPIO 211 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_211_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_212_PIN_CONTROL_2;          /*!< (@ 0x40081728) GPIO 212 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_212_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_213_PIN_CONTROL_2;          /*!< (@ 0x4008172C) GPIO 213 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_213_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_214_PIN_CONTROL_2;          /*!< (@ 0x40081730) GPIO 214 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_214_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_215_PIN_CONTROL_2;          /*!< (@ 0x40081734) GPIO 215 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_215_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_216_PIN_CONTROL_2;          /*!< (@ 0x40081738) GPIO 216 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_216_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_217_PIN_CONTROL_2;          /*!< (@ 0x4008173C) GPIO 217 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_217_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };
  __I  uint32_t  RESERVED4;

  union {
    __IO uint32_t  GPIO_221_PIN_CONTROL_2;          /*!< (@ 0x40081744) GPIO 221 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_221_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_222_PIN_CONTROL_2;          /*!< (@ 0x40081748) GPIO 222 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_222_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_223_PIN_CONTROL_2;          /*!< (@ 0x4008174C) GPIO 223 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_223_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_224_PIN_CONTROL_2;          /*!< (@ 0x40081750) GPIO 224 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_224_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_225_PIN_CONTROL_2;          /*!< (@ 0x40081754) GPIO 225 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_225_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_226_PIN_CONTROL_2;          /*!< (@ 0x40081758) GPIO 226 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_226_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_227_PIN_CONTROL_2;          /*!< (@ 0x4008175C) GPIO 227 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_227_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_230_PIN_CONTROL_2;          /*!< (@ 0x40081760) GPIO 230 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_230_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_231_PIN_CONTROL_2;          /*!< (@ 0x40081764) GPIO 231 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_231_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };
  __I  uint32_t  RESERVED5;

  union {
    __IO uint32_t  GPIO_233_PIN_CONTROL_2;          /*!< (@ 0x4008176C) GPIO 233 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_233_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_234_PIN_CONTROL_2;          /*!< (@ 0x40081770) GPIO 234 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_234_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_235_PIN_CONTROL_2;          /*!< (@ 0x40081774) GPIO 235 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_235_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };
  __I  uint32_t  RESERVED6[2];

  union {
    __IO uint32_t  GPIO_240_PIN_CONTROL_2;          /*!< (@ 0x40081780) GPIO 240 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_240_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_241_PIN_CONTROL_2;          /*!< (@ 0x40081784) GPIO 241 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_241_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_242_PIN_CONTROL_2;          /*!< (@ 0x40081788) GPIO 242 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_242_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_243_PIN_CONTROL_2;          /*!< (@ 0x4008178C) GPIO 243 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_243_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_244_PIN_CONTROL_2;          /*!< (@ 0x40081790) GPIO 244 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_244_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_245_PIN_CONTROL_2;          /*!< (@ 0x40081794) GPIO 245 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_245_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_246_PIN_CONTROL_2;          /*!< (@ 0x40081798) GPIO 246 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_246_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };
  __I  uint32_t  RESERVED7;

  union {
    __IO uint32_t  GPIO_250_PIN_CONTROL_2;          /*!< (@ 0x400817A0) GPIO 250 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_250_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };
  __I  uint32_t  RESERVED8[2];

  union {
    __IO uint32_t  GPIO_253_PIN_CONTROL_2;          /*!< (@ 0x400817AC) GPIO 253 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_253_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  GPIO_254_PIN_CONTROL_2;          /*!< (@ 0x400817B0) GPIO 254 Pin Control 2                                 */

    struct {
      __IO uint32_t  SLEW_RATE  :  1;               /*!< [0..0] This bit is used to select the slew rate on the pin.
                                                         0 = slow (half frequency), 1 = fast                                   */
           uint32_t             :  3;
      __IO uint32_t  DRIVE_STRENGTH:  2;            /*!< [4..5] These bits are used to select the drive strength on the
                                                         pin. The drive strength is the same whether the pin is
                                                          powered by 3.3V or 1.8V. 00 = 2mA, 01 = 4mA, 10 = 8mA, 11 =
                                                          12mA                                                                 */
    } GPIO_254_PIN_CONTROL_2_b;                     /*!< [6] BitSize                                                           */
  };
} GPIO_PIN_CONTROL_2_INST_Type;


/* ================================================================================ */
/* ================                    WDT_INST                    ================ */
/* ================================================================================ */


/**
  * @brief The function of the Watchdog Timer is to provide a mechanism to detect
 if the internal embedded controller has failed. When enabled, the Watchdog Timer (WDT) circuit
 will generate a WDT Event if the user program fails to reload the WDT within a specified length
 of time known as the WDT Interval.  (WDT_INST)
  */

typedef struct {                                    /*!< (@ 0x40000000) WDT_INST Structure                                     */
  __IO uint16_t  WDT_LOAD;                          /*!< (@ 0x40000000) Writing this field reloads the Watch Dog Timer
                                                         counter.                                                              */
  __I  uint16_t  RESERVED;

  union {
    __IO uint16_t  WDT_CONTROL;                     /*!< (@ 0x40000004) WDT Control Register                                   */

    struct {
      __IO uint16_t  WDT_ENABLE :  1;               /*!< [0..0] WDT Block enabled                                              */
      __IO uint16_t  WDT_STATUS :  1;               /*!< [1..1] WDT_STATUS is set by hardware if the last reset of the
                                                         device was caused by an underflow of the WDT. This bit must
                                                          be cleared by the EC firmware writing a '1' to this bit. Writing
                                                          a '0' to this bit has no effect.                                     */
      __IO uint16_t  HIBERNATION_TIMER0_STALL:  1;  /*!< [2..2] This bit enables the WDT Stall function if the Hibernation
                                                         Timer 0 is active.
                                                          1=The WDT is stalled while the Hibernation Timer 0 is active
                                                          0=The WDT is not affected by Hibernation Timer 0.                    */
      __IO uint16_t  WEEK_TIMER_STALL:  1;          /*!< [3..3] This bit enables the WDT Stall function if the Week Timer
                                                         is active.
                                                          1=The WDT is stalled while the Week Timer is active
                                                          0=The WDT is not affected by the Week Timer.                         */
      __IO uint16_t  JTAG_STALL :  1;               /*!< [4..4] This bit enables the WDT Stall function if JTAG or SWD
                                                         debug functions are active
                                                          1=The WDT is stalled while either JTAG or SWD is active
                                                          0=The WDT is not affected by the JTAG debug interface.               */
    } WDT_CONTROL_b;                                /*!< [5] BitSize                                                           */
  };
  __I  uint16_t  RESERVED1;
  __O  uint8_t   KICK;                              /*!< (@ 0x40000008) The WDT Kick Register is a strobe. Reads of this
                                                         register return 0. Writes to this register cause the WDT to
                                                          reload
                                                          the WDT Load Register value and start decrementing when the
                                                          WDT_ENABLE bit in the WDT Control Register is set to '1'. When
                                                          the WDT_ENABLE
                                                          bit in the WDT Control Register is cleared to '0', writes to
                                                          the WDT Kick Register have no effect.                                */
  __I  uint8_t   RESERVED2[3];
  __I  uint16_t  WDT_COUNT;                         /*!< (@ 0x4000000C) This read-only register provides the current
                                                         WDT count.                                                            */
} WDT_INST_Type;


/* ================================================================================ */
/* ================                   TIMER0_INST                  ================ */
/* ================================================================================ */


/**
  * @brief This timer block offers a simple mechanism for firmware to maintain a time base. This timer may be instantiated as 16 bits or
 32 bits. The name of the timer instance indicates the size of the timer.  (TIMER0_INST)
  */

typedef struct {                                    /*!< (@ 0x40000C00) TIMER0_INST Structure                                  */
  __IO uint32_t  COUNT;                             /*!< (@ 0x40000C00) This is the value of the Timer counter. This
                                                         is updated by Hardware but may be set by Firmware.                    */
  __IO uint32_t  PRE_LOAD;                          /*!< (@ 0x40000C04) This is the value of the Timer pre-load for the
                                                         counter. This is used by H/W when the counter is to be restarted
                                                         automatically; this will become the new value of the counter
                                                          upon restart.                                                        */

  union {
    __IO uint32_t  STATUS;                          /*!< (@ 0x40000C08) This is the interrupt status that fires when
                                                         the timer reaches its limit                                           */

    struct {
      __IO uint32_t  EVENT_INTERRUPT:  1;           /*!< [0..0] This is the interrupt status that fires when the timer
                                                         reaches its limit. This is the interrupt status that fires when
                                                          the timer reaches its limit. This may be level or a self clearing
                                                          signal cycle pulse, based on the AUTO_RESTART bit in the Timer
                                                          Control Register. If the timer is set to automatically restart,
                                                          it will provide a pulse, otherwise a level is provided.(R/WC)
                                                                                                                               */
    } STATUS_b;                                     /*!< [1] BitSize                                                           */
  };

  union {
    __IO uint32_t  INT_EN;                          /*!< (@ 0x40000C0C) This is the interrupt enable for the status EVENT_INTERRUPT
                                                         bit in the Timer Status Register                                      */

    struct {
      __IO uint32_t  ENABLE     :  1;               /*!< [0..0] This is the interrupt enable for the status EVENT_INTERRUPT
                                                         bit in the Timer Status Register.                                     */
    } INT_EN_b;                                     /*!< [1] BitSize                                                           */
  };

  union {
    __IO uint32_t  CONTROL;                         /*!< (@ 0x40000C10) Timer Control Register                                 */

    struct {
      __IO uint32_t  ENABLE     :  1;               /*!< [0..0] This enables the block for operation. 1=This block will
                                                         function normally;
                                                         0=This block will gate its clock and go into its lowest power
                                                          state                                                                */
           uint32_t             :  1;
      __IO uint32_t  COUNT_UP   :  1;               /*!< [2..2] This selects the counter direction. When the counter
                                                         in incrementing the counter will saturate and trigger the event
                                                         when it reaches all F's. When the counter is decrementing the
                                                          counter will saturate when it reaches 0h. 1=The counter will
                                                          increment;
                                                         0=The counter will decrement                                          */
      __IO uint32_t  AUTO_RESTART:  1;              /*!< [3..3] This will select the action taken upon completing a count.
                                                         1=The counter will automatically restart the count, using the
                                                         contents of the Timer Preload Register to load the Timer Count
                                                          Register.
                                                         The interrupt will be set in edge mode
                                                         0=The counter will simply enter a done state and wait for further
                                                          control inputs. The interrupt will be set in level mode.             */
      __IO uint32_t  SOFT_RESET :  1;               /*!< [4..4] This is a soft reset. This is self clearing 1 cycle after
                                                         it is written. Firmware does not need
                                                         to wait before reconfiguring the Basic Timer following soft
                                                          reset.                                                               */
      __IO uint32_t  START      :  1;               /*!< [5..5] This bit triggers the timer counter. The counter will
                                                         operate until it hits its terminating condition. This will
                                                         clear this bit. It should be noted that when operating in restart
                                                          mode, there is no terminating condition for the counter, so
                                                         this bit will never clear. Clearing this bit will halt the timer
                                                          counter.                                                             */
      __IO uint32_t  RELOAD     :  1;               /*!< [6..6] This bit reloads the counter without interrupting it
                                                         operation. This will not function if the timer has already
                                                         completed (when the START bit in this register is '0'). This
                                                          is used to periodically prevent the timer from firing when an
                                                         event occurs. Usage while the timer is off may result in erroneous
                                                          behaviour.                                                           */
      __IO uint32_t  HALT       :  1;               /*!< [7..7] This is a halt bit. This will halt the timer as long
                                                         as it is active. Once the halt is inactive, the timer will
                                                         start from where it left off. 1=Timer is halted. It stops counting.
                                                          The clock divider will also be reset. 0=Timer runs normally.
                                                                                                                               */
           uint32_t             :  8;
      __IO uint32_t  PRE_SCALE  : 16;               /*!< [16..31] This is used to divide down the system clock through
                                                         clock enables to lower the power consumption of the block and
                                                          allow
                                                         slow timers. Updating this value during operation may result
                                                          in erroneous clock enable pulses until the clock divider restarts.
                                                         The number of clocks per clock enable pulse is (Value + 1);
                                                          a setting of 0 runs at the full clock speed, while a setting
                                                          of 1
                                                         runs at half speed.                                                   */
    } CONTROL_b;                                    /*!< [32] BitSize                                                          */
  };
} TIMER0_INST_Type;


/* ================================================================================ */
/* ================               COUNTER_TIMER0_INST              ================ */
/* ================================================================================ */


/**
  * @brief This interface is a 16-bit auto-reloading timer/counter.  (COUNTER_TIMER0_INST)
  */

typedef struct {                                    /*!< (@ 0x40000D00) COUNTER_TIMER0_INST Structure                          */

  union {
    __IO uint32_t  TIMERX_CONTROL;                  /*!< (@ 0x40000D00) This bit reflects the current state of the timer's
                                                         Clock_Required output signal.                                         */

    struct {
      __IO uint32_t  ENABLE     :  1;               /*!< [0..0] This bit is used to start and stop the timer. This bit
                                                         does not reset the timer count but does reset the timer
                                                         pulse output. This bit will be cleared when the timer stops
                                                          counting in One-Shot mode. The ENABLE bit is cleared after a
                                                         RESET cycle has completed. Firmware must poll the RESET bit
                                                          in order to determine when the timer is active after reset.
                                                         1=Timer is enabled; 0=Timer is disabled.                              */
      __IO uint32_t  RESET      :  1;               /*!< [1..1] This bit stops the timer and resets the internal counter
                                                         to the value in the Timer Reload Register. This bit
                                                         also clears the ENABLE bit if it is set. This bit is self-clearing
                                                          after the timer is reset. Firmware must poll the
                                                         RESET bit in order to determine when the timer is active after
                                                          reset. Interrupts are blocked only when RESET takes
                                                         effect and the ENABLE bit is cleared. If interrupts are not
                                                          desired, firmware must mask the interrupt in the interrupt
                                                         block. 1=Timer reset; 0=Normal timer operation.                       */
      __IO uint32_t  MODE       :  2;               /*!< [2..3] Timer Mode. 3=Measurement Mode; 2=One Shot Mode; 1=Event
                                                         Mode; 0=Timer Mode.                                                   */
      __IO uint32_t  INPOL      :  1;               /*!< [4..4] This bit selects the polarity of the TINx input. 1=TINx
                                                         is active low; 0=TINx is active high.                                 */
      __IO uint32_t  UPDN       :  1;               /*!< [5..5] In Event Mode, this bit selects the timer count direction.
                                                         In Timer Mode enables timer control by the TINx input pin.
                                                         Event Mode: 1=The timer counts up; 0=The timer counts down.
                                                         Timer Mode:; 1=TINx pin pauses the timer when de-asserted; 0=TINx
                                                          pin has no effect on the timer.                                      */
      __IO uint32_t  TOUT_EN    :  1;               /*!< [6..6] This bit enables the TOUTx pin. 1=TOUTx pin function
                                                         is enabled; 0=TOUTx pin is inactive.                                  */
      __IO uint32_t  RLOAD      :  1;               /*!< [7..7] Reload Control. This bit controls how the timer is reloaded
                                                         on overflow or underflow in Event and Timer modes.
                                                         It has no effect in One shot mode. 1=Reload timer from Timer
                                                          Reload Register and continue counting;
                                                         0=Roll timer over to FFFFh and continue counting when counting
                                                          down and rolls over to 0000h and continues counting when counting
                                                          up.                                                                  */
      __IO uint32_t  FILTER_BYPASS:  1;             /*!< [8..8] This bit is used to enable or disable the noise filter
                                                         on the TINx input signal. 1=Bypass Mode: input filter disabled.
                                                         The TINx input directly affects the timer; 0=Filter Mode: input
                                                          filter enabled. The TINx input is filtered by the input filter.
                                                                                                                               */
      __IO uint32_t  PD         :  1;               /*!< [9..9] Power Down. 1=The timer is powered down and all clocks
                                                         are gated; 0=The timer is in a running state.                         */
      __IO uint32_t  TOUT_POLARITY:  1;             /*!< [10..10] This bit determines the polarity of the TOUTx output
                                                         signal. In timer modes that toggle the TOUTx signal,
                                                         this polarity bit will not have a perceivable difference, except
                                                          to determine the inactive state. In One-Shot mode
                                                         this determines if the pulsed output is active high or active
                                                          low. 1=Active low; 0=Active high.                                    */
      __IO uint32_t  SLEEP_ENABLE:  1;              /*!< [11..11] This bit reflects the current state of the timer's
                                                         Sleep_Enable input signal. 1=Normal operation; 0=Sleep Mode
                                                          is requested.                                                        */
      __I  uint32_t  TIMERX_CLK_REQ:  1;            /*!< [12..12] This bit reflects the current state of the timer's
                                                         Clock_Required output signal. 1=The main clock is required by
                                                          this block;
                                                         0=The main clock is not required by this block.                       */
    } TIMERX_CONTROL_b;                             /*!< [13] BitSize                                                          */
  };

  union {
    __IO uint32_t  PRELOAD;                         /*!< (@ 0x40000D04) This is the value of the Timer pre-load for the
                                                         counter. This is used by H/W when the counter is to be restarted
                                                          automatically; this will become the new value of the counter
                                                          upon restart.                                                        */

    struct {
      __IO uint32_t  TCLK       :  4;               /*!< [0..3] Timer Clock Select. This field determines the clock source
                                                         for the 16-bit counter in the timer.                                  */
           uint32_t             :  1;
      __IO uint32_t  EDGE       :  2;               /*!< [5..6] This field selects which edge of the TINx input signal
                                                         affects the timer in Event Mode, One-Shot Mode and Measurement
                                                          Mode.
                                                         Event Mode: 11b=No event selected; 10b=Counts rising and falling
                                                          edges; 01b=Counts rising edges; 00b=Counts falling edges.
                                                         One-Shot Mode: 11b=Start counting when the Enable bit is set;
                                                          10b=Starts counting on a rising or falling edge; 01b=Starts
                                                         counting on a rising edge; 00b=Starts counting on a falling
                                                          edge. Measurement Mode: 11b=No event selected; 10b=Measures
                                                         the time between risin                                                */
      __IO uint32_t  EVENT      :  1;               /*!< [7..7] Event Select. This bit is used to select the count source
                                                         when the timer is operating in Event Mode.
                                                         1=TINx is count source; 0=Timer x-1 overflow is count source.
                                                                                                                               */
      __IO uint32_t  FCLK       :  4;               /*!< [8..11] Timer Clock Select. This field determines the clock
                                                         source for the TINx noise filter. The available frequencies
                                                         are the same as for TCLK.                                             */
    } PRELOAD_b;                                    /*!< [12] BitSize                                                          */
  };

  union {
    __IO uint32_t  TIMERX_RELOAD;                   /*!< (@ 0x40000D08) This register is used in Timer and One-Shot modes
                                                         to set the lower limit of the timer.                                  */

    struct {
      __IO uint32_t  TIMER_RELOAD: 16;              /*!< [0..15] The Timer Reload register is used in Timer and One-Shot
                                                         modes to set the lower limit of the timer.
                                                         In Event mode the Timer Reload register sets either the upper
                                                          or lower limit of the timer depending on if the
                                                         timer is counting up or down. Valid Timer Reload values are
                                                          0001h - FFFFh. If the timer is running, the
                                                         reload value will not be updated until the timer overflows or
                                                          underflows. Programming a 0000h as a preload
                                                         value is not a valid count value. Using a value of 0000h will
                                                          cause unpredictable behavior.                                        */
    } TIMERX_RELOAD_b;                              /*!< [16] BitSize                                                          */
  };

  union {
    __IO uint32_t  TIMERX_COUNT;                    /*!< (@ 0x40000D0C) This register returns the current value of the
                                                         timer in all modes.                                                   */

    struct {
      __I  uint32_t  TIMER_COUNT: 16;               /*!< [0..15] This is the current value of the timer in all modes.
                                                                                                                               */
    } TIMERX_COUNT_b;                               /*!< [16] BitSize                                                          */
  };
} COUNTER_TIMER0_INST_Type;


/* ================================================================================ */
/* ================           CAPTURE_COMPARE_TIMER_INST           ================ */
/* ================================================================================ */


/**
  * @brief This is a 16-bit auto-reloading timer/counter.  (CAPTURE_COMPARE_TIMER_INST)
  */

typedef struct {                                    /*!< (@ 0x40001000) CAPTURE_COMPARE_TIMER_INST Structure                   */

  union {
    __IO uint32_t  CAPTURE_COMPARE_TIMER_CONTROL;   /*!< (@ 0x40001000) This register controls the capture and compare
                                                         timer.                                                                */

    struct {
      __IO uint32_t  ACTIVATE   :  1;               /*!< [0..0] This bit is used to start the capture and compare timer
                                                         running and power it down.                                            */
      __IO uint32_t  FREE_ENABLE:  1;               /*!< [1..1] Free-Running Timer Enable. This bit is used to start
                                                         and stop the free running timer.                                      */
      __IO uint32_t  FREE_RESET :  1;               /*!< [2..2] Free Running Timer Reset. This bit stops the timer and
                                                         resets the internal counter to 0000_0000h.                            */
           uint32_t             :  1;
      __IO uint32_t  TCLK       :  3;               /*!< [4..6] This 3-bit field sets the clock source for the Free-Running
                                                         Counter.                                                              */
           uint32_t             :  1;
      __IO uint32_t  COMPARE_ENABLE0:  1;           /*!< [8..8] Compare Enable for Compare 0 Register.                         */
      __IO uint32_t  COMPARE_ENABLE1:  1;           /*!< [9..9] Compare Enable for Compare 1 Register.                         */
           uint32_t             :  6;
      __IO uint32_t  COMPARE_SET1:  1;              /*!< [16..16] When read, returns the current value off the Compare
                                                         Timer Output 1 state.                                                 */
      __IO uint32_t  COMPARE_SET0:  1;              /*!< [17..17] When read, returns the current value off the Compare
                                                         Timer Output 0 state.                                                 */
           uint32_t             :  6;
      __IO uint32_t  COMPARE_CLEAR1:  1;            /*!< [24..24] When read, returns the current value off the Compare
                                                         Timer Output 1 state.                                                 */
      __IO uint32_t  COMPARE_CLEAR0:  1;            /*!< [25..25] When read, returns the current value off the Compare
                                                         Timer Output 0 state.                                                 */
    } CAPTURE_COMPARE_TIMER_CONTROL_b;              /*!< [26] BitSize                                                          */
  };

  union {
    __IO uint32_t  CAPTURE_CONTROL_0;               /*!< (@ 0x40001004) This register is used to configure capture and
                                                         compare timers 0-3.                                                   */

    struct {
      __IO uint32_t  CAPTURE_EDGE0:  2;             /*!< [0..1] This field selects the edge type that triggers the capture
                                                         of the Free Running Counter into Capture Register 0.                  */
      __IO uint32_t  FILTER_BYP0:  1;               /*!< [2..2] This bit enables bypassing the input noise filter for
                                                         Capture Register 0, so that the input signal goes directly into
                                                          the timer.                                                           */
           uint32_t             :  2;
      __IO uint32_t  FCLK_SEL0  :  3;               /*!< [5..7] This 3-bit field sets the clock source for the input
                                                         filter for Capture Register 0.                                        */
      __IO uint32_t  CAPTURE_EDGE1:  2;             /*!< [8..9] This field selects the edge type that triggers the capture
                                                         of the Free Running Counter into Capture Register 1.                  */
      __IO uint32_t  FILTER_BYP1:  1;               /*!< [10..10] This bit enables bypassing the input noise filter for
                                                         Capture Register 1, so that the input signal goes directly into
                                                          the timer.                                                           */
           uint32_t             :  2;
      __IO uint32_t  FCLK_SEL1  :  3;               /*!< [13..15] This 3-bit field sets the clock source for the input
                                                         filter for Capture Register 1.                                        */
      __IO uint32_t  CAPTURE_EDGE2:  2;             /*!< [16..17] This field selects the edge type that triggers the
                                                         capture of the Free Running Counter into Capture Register 2.
                                                                                                                               */
      __IO uint32_t  FILTER_BYP2:  1;               /*!< [18..18] This bit enables bypassing the input noise filter for
                                                         Capture Register 2, so that the input signal goes directly into
                                                          the timer.                                                           */
           uint32_t             :  2;
      __IO uint32_t  FCLK_SEL2  :  3;               /*!< [21..23] This 3-bit field sets the clock source for the input
                                                         filter for Capture Register 2.                                        */
      __IO uint32_t  CAPTURE_EDGE3:  2;             /*!< [24..25] This field selects the edge type that triggers the
                                                         capture of the Free Running Counter into Capture Register 3.
                                                                                                                               */
      __IO uint32_t  FILTER_BYP3:  1;               /*!< [26..26] This bit enables bypassing the input noise filter for
                                                         Capture Register 3, so that the input signal goes directly into
                                                          the timer.                                                           */
           uint32_t             :  2;
      __IO uint32_t  FCLK_SEL3  :  3;               /*!< [29..31] This 3-bit field sets the clock source for the input
                                                         filter for Capture Register 3.                                        */
    } CAPTURE_CONTROL_0_b;                          /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  CAPTURE_CONTROL_1;               /*!< (@ 0x40001008) This register is used to configure capture and
                                                         compare timers 4-5.                                                   */

    struct {
      __IO uint32_t  CAPTURE_EDGE4:  2;             /*!< [0..1] This field selects the edge type that triggers the capture
                                                         of the Free Running Counter into Capture Register 4.                  */
      __IO uint32_t  FILTER_BYP4:  1;               /*!< [2..2] This bit enables bypassing the input noise filter for
                                                         Capture Register 4, so that the input signal goes directly into
                                                          the timer.                                                           */
           uint32_t             :  2;
      __IO uint32_t  FCLK_SEL4  :  3;               /*!< [5..7] This 3-bit field sets the clock source for the input
                                                         filter for Capture Register 4.                                        */
      __IO uint32_t  CAPTURE_EDGE5:  2;             /*!< [8..9] This field selects the edge type that triggers the capture
                                                         of the Free Running Counter into Capture Register 5.                  */
      __IO uint32_t  FILTER_BYP5:  1;               /*!< [10..10] This bit enables bypassing the input noise filter for
                                                         Capture Register 5, so that the input signal goes directly into
                                                          the timer.                                                           */
           uint32_t             :  2;
      __IO uint32_t  FCLK_SEL5  :  3;               /*!< [13..15] This 3-bit field sets the clock source for the input
                                                         filter for Capture Register 5.                                        */
    } CAPTURE_CONTROL_1_b;                          /*!< [16] BitSize                                                          */
  };

  union {
    __IO uint32_t  FREE_RUNNING_TIMER;              /*!< (@ 0x4000100C) This register contains the current value of the
                                                         Free Running Timer.                                                   */

    struct {
      __IO uint32_t  FREE_RUNNING_TIMER: 32;        /*!< [0..31] This register contains the current value of the Free
                                                         Running Timer.                                                        */
    } FREE_RUNNING_TIMER_b;                         /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  CAPTURE_0;                       /*!< (@ 0x40001010) This register saves the value copied from the
                                                         Free Running timer on a programmed edge of ICT0.                      */

    struct {
      __IO uint32_t  CAPTURE_0  : 32;               /*!< [0..31] This register saves the value copied from the Free Running
                                                         timer on a programmed edge of ICT0.                                   */
    } CAPTURE_0_b;                                  /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  CAPTURE_1;                       /*!< (@ 0x40001014) This register saves the value copied from the
                                                         Free Running timer on a programmed edge of ICT1.                      */

    struct {
      __IO uint32_t  CAPTURE_1  : 32;               /*!< [0..31] This register saves the value copied from the Free Running
                                                         timer on a programmed edge of ICT1.                                   */
    } CAPTURE_1_b;                                  /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  CAPTURE_2;                       /*!< (@ 0x40001018) This register saves the value copied from the
                                                         Free Running timer on a programmed edge of ICT0.                      */

    struct {
      __IO uint32_t  CAPTURE_2  : 32;               /*!< [0..31] This register saves the value copied from the Free Running
                                                         timer on a programmed edge of ICT2.                                   */
    } CAPTURE_2_b;                                  /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  CAPTURE_3;                       /*!< (@ 0x4000101C) This register saves the value copied from the
                                                         Free Running timer on a programmed edge of ICT0.                      */

    struct {
      __IO uint32_t  CAPTURE_3  : 32;               /*!< [0..31] This register saves the value copied from the Free Running
                                                         timer on a programmed edge of ICT3.                                   */
    } CAPTURE_3_b;                                  /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  CAPTURE_4;                       /*!< (@ 0x40001020) This register saves the value copied from the
                                                         Free Running timer on a programmed edge of ICT4.                      */

    struct {
      __IO uint32_t  CAPTURE_4  : 32;               /*!< [0..31] This register saves the value copied from the Free Running
                                                         timer on a programmed edge of ICT4.                                   */
    } CAPTURE_4_b;                                  /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  CAPTURE_5;                       /*!< (@ 0x40001024) This register saves the value copied from the
                                                         Free Running timer on a programmed edge of ICT5.                      */

    struct {
      __IO uint32_t  CAPTURE_5  : 32;               /*!< [0..31] This register saves the value copied from the Free Running
                                                         timer on a programmed edge of ICT5.                                   */
    } CAPTURE_5_b;                                  /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  COMPARE_0;                       /*!< (@ 0x40001028) A COMPARE 0 interrupt is generated when this
                                                         register matches the value in the Free Running Timer.                 */

    struct {
      __IO uint32_t  COMPARE_0  : 32;               /*!< [0..31] A COMPARE 0 interrupt is generated when this register
                                                         matches the value in the Free Running Timer.                          */
    } COMPARE_0_b;                                  /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  COMPARE_1;                       /*!< (@ 0x4000102C) A COMPARE 1 interrupt is generated when this
                                                         register matches the value in the Free Running Timer.                 */

    struct {
      __IO uint32_t  COMPARE_1  : 32;               /*!< [0..31] A COMPARE 1 interrupt is generated when this register
                                                         matches the value in the Free Running Timer.                          */
    } COMPARE_1_b;                                  /*!< [32] BitSize                                                          */
  };
} CAPTURE_COMPARE_TIMER_INST_Type;


/* ================================================================================ */
/* ================                    HTM0_INST                   ================ */
/* ================================================================================ */


/**
  * @brief The Hibernation Timer can generate a wake event to the Embedded Controller (EC) when it is in a hibernation mode.
 This block supports wake events up to 2 hours in duration. The timer is a 16-bit binary count-down timer that can be programmed
 in 30.5us and 0.125 second increments for period ranges of 30.5us to 2s or 0.125s to 136.5 minutes, respectively.  (HTM0_INST)
  */

typedef struct {                                    /*!< (@ 0x40009800) HTM0_INST Structure                                    */
  __IO uint16_t  HT_PRELOAD;                        /*!< (@ 0x40009800) [15:0] This register is used to set the Hibernation
                                                         Timer Preload value.                                                  */
  __I  uint16_t  RESERVED;

  union {
    __IO uint16_t  HT_CONTROL;                      /*!< (@ 0x40009804) HTimer Control Register                                */

    struct {
      __IO uint16_t  CTRL       :  1;               /*!< [0..0] 1= The Hibernation Timer has a resolution of 0.125s per
                                                         LSB, which yields a maximum time in excess of 2 hours.
                                                         0= The Hibernation Timer has a resolution of 30.5us per LSB,
                                                          which yields a maximum time of ~2seconds.                            */
    } HT_CONTROL_b;                                 /*!< [1] BitSize                                                           */
  };
  __I  uint16_t  RESERVED1;
  __I  uint16_t  COUNT;                             /*!< (@ 0x40009808) The current state of the Hibernation Timer.            */
} HTM0_INST_Type;


/* ================================================================================ */
/* ================                    RTOS_INST                   ================ */
/* ================================================================================ */


/**
  * @brief The RTOS Timer is a low-power, 32-bit timer designed to operate on the 32kHz oscillator which is available during all
 chip sleep states. This allows firmware the option to sleep the processor, enter heavy or deep chip sleep states, and
 wake after a programmed amount of time. The timer may be used as a one-shot timer or a continuous timer. When the
 timer transitions to 0 it is capable of generating a wake-capable interrupt to the embedded controller. This timer may be
 halted during debug by hardware or via a software control bit.  (RTOS_INST)
  */

typedef struct {                                    /*!< (@ 0x40007400) RTOS_INST Structure                                    */

  union {
    __IO uint32_t  RTOS_TIMER_COUNT;                /*!< (@ 0x40007400) RTOS Timer Count Register.                             */

    struct {
      __IO uint32_t  COUNTER    : 32;               /*!< [0..31] This register contains the current value of the RTOS
                                                         Timer counter. This register should be read as a DWORD. There
                                                          is no latching mechanism
                                                          of the upper bytes implemented if the register is accessed
                                                          as a byte or word. Reading the register with byte or word operations
                                                          may give incorrect results.                                          */
    } RTOS_TIMER_COUNT_b;                           /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  RTOS_TIMER_PRELOAD;              /*!< (@ 0x40007404) RTOS Timer Preload Register                            */

    struct {
      __IO uint32_t  PRE_LOAD   : 32;               /*!< [0..31] The this register is loaded into the RTOS Timer counter
                                                         either when the TIMER_START bit is written with a 1, or when
                                                          the timer counter counts down to 0 and the AUTO_RELOAD bit is
                                                          1.
                                                          This register must be programmed with a new count value before
                                                          the TIMER_START bit is set to 1. If this register is updated
                                                          while the counter is operating, the new count value will only
                                                          take effect if
                                                          the counter transitions form 1 to 0 while the AUTO_RELOAD bit
                                                          is set.                                                              */
    } RTOS_TIMER_PRELOAD_b;                         /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  RTOS_TIMER_CONTROL;              /*!< (@ 0x40007408) RTOS Timer Control Register                            */

    struct {
      __IO uint32_t  BLOCK_ENABLE:  1;              /*!< [0..0] 1=RTOS timer counter is enabled
                                                         0=RTOS timer disabled. All register bits are reset to their
                                                         default state                                                         */
      __IO uint32_t  AUTO_RELOAD:  1;               /*!< [1..1] 1=The the RTOS Timer Preload Register is loaded into
                                                         the timer counter and the counter is restarted when the counter
                                                          transitions from 1 to 0
                                                         0=The timer counter halts when it transitions from 1 to 0 and
                                                          will not restart.                                                    */
      __IO uint32_t  TIMER_START:  1;               /*!< [2..2] Writing a 1 to this bit will load the timer counter with
                                                         the RTOS Timer Preload Register and start counting. If the Preload
                                                          Register is 0, counting will not start and this bit will be
                                                          cleared to 0.
                                                         Writing a 0 to this bit will halt the counter and clear its
                                                          contents to 0. The RTOS timer interrupt will not be generated.
                                                          This bit is automatically cleared if the AUTO_RELOAD bit is
                                                          0 and the
                                                         timer counter transitions from 1 to 0.                                */
      __IO uint32_t  EXT_HARDWARE_HALT_EN:  1;      /*!< [3..3] 1=The timer counter is halted when the external HALT
                                                         signal is asserted. Counting is always enabled if HALT is de-asserted.
                                                         0=The HALT signal does not affect the RTOS Timer                      */
      __IO uint32_t  FIRMWARE_TIMER_HALT:  1;       /*!< [4..4] 1=The timer counter is halted. If the counter was running,
                                                         clearing this bit will restart the counter from the value at
                                                          which it halted
                                                         0=The timer counter, if enabled, will continue to run                 */
    } RTOS_TIMER_CONTROL_b;                         /*!< [5] BitSize                                                           */
  };

  union {
    __O  uint32_t  SOFT_INTERRUPT;                  /*!< (@ 0x4000740C) Soft Interrupt Register                                */

    struct {
      __O  uint32_t  SWI_0      :  1;               /*!< [0..0] Software Interrupt. A write of a '1' to this bit will
                                                         generate an SWI interrupt to the EC.
                                                         Writes of a '0' have no effect. Reads return '0'.                     */
      __O  uint32_t  SWI_1      :  1;               /*!< [1..1] Software Interrupt. A write of a '1' to this bit will
                                                         generate an SWI interrupt to the EC.
                                                         Writes of a '0' have no effect. Reads return '0'.                     */
      __O  uint32_t  SWI_2      :  1;               /*!< [2..2] Software Interrupt. A write of a '1' to this bit will
                                                         generate an SWI interrupt to the EC.
                                                         Writes of a '0' have no effect. Reads return '0'.                     */
      __O  uint32_t  SWI_3      :  1;               /*!< [3..3] Software Interrupt. A write of a '1' to this bit will
                                                         generate an SWI interrupt to the EC.
                                                         Writes of a '0' have no effect. Reads return '0'.                     */
    } SOFT_INTERRUPT_b;                             /*!< [4] BitSize                                                           */
  };
} RTOS_INST_Type;


/* ================================================================================ */
/* ================                    RTC_INST                    ================ */
/* ================================================================================ */


/**
  * @brief This is the set of registers that are automatically counted by hardware every 1 second while the block is enabled
 to run and to update. These registers are: Seconds, Minutes, Hours, Day of Week, Day of Month, Month, and Year.  (RTC_INST)
  */

typedef struct {                                    /*!< (@ 0x400F5000) RTC_INST Structure                                     */
  __IO uint8_t   SEC;                               /*!< (@ 0x400F5000) Seconds Register                                       */
  __IO uint8_t   SEC_ALARM;                         /*!< (@ 0x400F5001) Seconds Alarm Register                                 */
  __IO uint8_t   MIN;                               /*!< (@ 0x400F5002) Minutes Register                                       */
  __IO uint8_t   MIN_ALARM;                         /*!< (@ 0x400F5003) Minutes Alarm Register                                 */
  __IO uint8_t   HR;                                /*!< (@ 0x400F5004) Hours Register                                         */
  __IO uint8_t   HR_ALARM;                          /*!< (@ 0x400F5005) Hours Alarm Register                                   */
  __IO uint8_t   DAY_WEEK;                          /*!< (@ 0x400F5006) Day of Week Register                                   */
  __IO uint8_t   DAY_MONTH;                         /*!< (@ 0x400F5007) Day of Month Register                                  */
  __IO uint8_t   MONTH;                             /*!< (@ 0x400F5008) Month Register                                         */
  __IO uint8_t   YEAR;                              /*!< (@ 0x400F5009) Year Register                                          */
  __IO uint8_t   REG_A;                             /*!< (@ 0x400F500A) Register A                                             */
  __IO uint8_t   REG_B;                             /*!< (@ 0x400F500B) Register B                                             */
  __IO uint8_t   REG_C;                             /*!< (@ 0x400F500C) Register C                                             */
  __IO uint8_t   REG_D;                             /*!< (@ 0x400F500D) Register D                                             */
  __I  uint16_t  RESERVED;

  union {
    __IO uint32_t  CONTROL;                         /*!< (@ 0x400F5010) RTC Control Register                                   */

    struct {
      __IO uint32_t  BLOCK_ENABLE:  1;              /*!< [0..0] BLOCK_ENABLE This bit must be '1' in order for the block
                                                         to function internally. Registers may be initialized first,
                                                          before
                                                          setting this bit to '1' to start operation.                          */
      __IO uint32_t  SOFT_RESET :  1;               /*!< [1..1] SOFT_RESET A '1' written to this bit position will trigger
                                                         the RTC_RST reset, resetting the block and all registers except
                                                          this one and the Test Register. This bit is self-clearing at
                                                          the end of the reset, one cycle of LPC Bus Clock later, and
                                                          so requires
                                                          no waiting.                                                          */
      __IO uint32_t  TEST       :  1;               /*!< [2..2] TEST                                                           */
      __IO uint32_t  ALARM_ENABLE:  1;              /*!< [3..3] ALARM_ENABLE 1=Enables the Alarm features, 0=Disables
                                                         the Alarm features                                                    */
    } CONTROL_b;                                    /*!< [4] BitSize                                                           */
  };
  __IO uint32_t  WEEK_ALARM;                        /*!< (@ 0x400F5014) Week Alarm Register[7:0] - ALARM_DAY_OF_WEEK
                                                         This register, if written to a value in the range 1- -7, will
                                                          inhibit the Alarm
                                                          interrupt unless this field matches the contents of the Day
                                                          of Week Register also.                                               */

  union {
    __IO uint32_t  DAYLIGHT_SAVINGS_FORWARD;        /*!< (@ 0x400F5018) Daylight Savings Forward Register                      */

    struct {
      __IO uint32_t  DST_MONTH  :  8;               /*!< [0..7] This field matches the Month Register.                         */
      __IO uint32_t  DST_DAY_OF_WEEK:  3;           /*!< [8..10] This field matches the Day of Week Register bits[2:0].
                                                                                                                               */
           uint32_t             :  5;
      __IO uint32_t  DST_WEEK   :  3;               /*!< [16..18] 5=Last week of month, 4 =Fourth week of month, 3=Third
                                                         week of month, 2=Second week of month, 1=First week of month
                                                                                                                               */
           uint32_t             :  5;
      __IO uint32_t  DST_HOUR   :  7;               /*!< [24..30] This field holds the matching value for bits[6:0] of
                                                         the Hours register. The written value will be interpreted according
                                                          to the 24/12 Hour mode and DM mode settings at the time of
                                                          writing.                                                             */
      __IO uint32_t  DST_AM_PM  :  1;               /*!< [31..31] This bit selects AM vs. PM, to match bit[7] of the
                                                         Hours Register if 12-Hour mode is selected in Register B at
                                                          the time
                                                          of writing.                                                          */
    } DAYLIGHT_SAVINGS_FORWARD_b;                   /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  DAYLIGHT_SAVINGS_BACKWARD;       /*!< (@ 0x400F501C) Daylight Savings Backward Register                     */

    struct {
      __IO uint32_t  DST_MONTH  :  8;               /*!< [0..7] This field matches the Month Register.                         */
      __IO uint32_t  DST_DAY_OF_WEEK:  3;           /*!< [8..10] This field matches the Day of Week Register bits[2:0].
                                                                                                                               */
           uint32_t             :  5;
      __IO uint32_t  DST_WEEK   :  3;               /*!< [16..18] 5=Last week of month, 4 =Fourth week of month, 3=Third
                                                         week of month, 2=Second week of month, 1=First week of month
                                                                                                                               */
           uint32_t             :  5;
      __IO uint32_t  DST_HOUR   :  7;               /*!< [24..30] This field holds the matching value for bits[6:0] of
                                                         the Hours register. The written value will be interpreted according
                                                          to the 24/12 Hour mode and DM mode settings at the time of
                                                          writing.                                                             */
      __IO uint32_t  DST_AM_PM  :  1;               /*!< [31..31] This bit selects AM vs. PM, to match bit[7] of the
                                                         Hours Register if 12-Hour mode is selected in Register B at
                                                          the time
                                                          of writing.                                                          */
    } DAYLIGHT_SAVINGS_BACKWARD_b;                  /*!< [32] BitSize                                                          */
  };
} RTC_INST_Type;


/* ================================================================================ */
/* ================                    WEEK_INST                   ================ */
/* ================================================================================ */


/**
  * @brief The Week Alarm Interface provides two timekeeping functions: a Week Timer and a Sub-Week Timer. Both the Week Timer
 and the Sub-Week Timer assert the Power-Up Event Output which automatically powers-up the system from the G3 state.  (WEEK_INST)
  */

typedef struct {                                    /*!< (@ 0x4000AC80) WEEK_INST Structure                                    */

  union {
    __IO uint32_t  CONTROL_REGISTER;                /*!< (@ 0x4000AC80) Control Register                                       */

    struct {
      __IO uint32_t  WT_ENABLE  :  1;               /*!< [0..0] The WT_ENABLE bit is used to start and stop the Week
                                                         Alarm Counter Register and the Clock Divider Register.
                                                         The value in the Counter Register is held when the WT_ENABLE
                                                          bit is not asserted (0) and the count is resumed from the last
                                                          value when the bit is asserted (1).
                                                         The 15-Bit Clock Divider is reset to 00h and the Week Alarm
                                                          Interface is in its lowest power consumption state when the
                                                          WT_ENABLE bit is not asserted.                                       */
           uint32_t             :  5;
      __IO uint32_t  POWERUP_EN :  1;               /*!< [6..6] This bit controls the state of the Power-Up Event Output
                                                         and enables Week POWER-UP Event decoding in the VBAT-Powered
                                                          Control Interface.
                                                         1=Power-Up Event Output Enabled
                                                         0=Power-Up Event Output Disabled and Reset                            */
    } CONTROL_REGISTER_b;                           /*!< [7] BitSize                                                           */
  };

  union {
    __IO uint32_t  WEEK_ALARM_COUNTER;              /*!< (@ 0x4000AC84) Week Alarm Counter Register                            */

    struct {
      __IO uint32_t  WEEK_COUNTER: 28;              /*!< [0..27] While the WT_ENABLE bit is 1, this register is incremented
                                                         at a 1 Hz rate. Writes of this register may require one second
                                                         to take effect. Reads return the current state of the register.
                                                          Reads and writes complete independently of the state of WT_ENABLE.
                                                                                                                               */
    } WEEK_ALARM_COUNTER_b;                         /*!< [28] BitSize                                                          */
  };

  union {
    __IO uint32_t  WEEK_TIMER_COMPARE;              /*!< (@ 0x4000AC88) Week Timer Compare Register                            */

    struct {
      __IO uint32_t  WEEK_COMPARE: 28;              /*!< [0..27] A Week Alarm Interrupt and a Week Alarm Power-Up Event
                                                         are asserted when the Week Alarm Counter Register is greater
                                                          than
                                                         or equal to the contents of this register. Reads and writes
                                                          complete independently of the state of WT_ENABLE.                    */
    } WEEK_TIMER_COMPARE_b;                         /*!< [28] BitSize                                                          */
  };

  union {
    __IO uint32_t  CLOCK_DIVIDER;                   /*!< (@ 0x4000AC8C) Clock Divider Register                                 */

    struct {
      __I  uint32_t  CLOCK_DIVIDER: 15;             /*!< [0..14] Reads of this register return the current state of the
                                                         Week Timer 15- bit clock divider.                                     */
    } CLOCK_DIVIDER_b;                              /*!< [15] BitSize                                                          */
  };

  union {
    __IO uint32_t  SUB_SECOND_INT_SELECT;           /*!< (@ 0x4000AC90) Sub-Second Programmable Interrupt Select Register
                                                                                                                               */

    struct {
      __IO uint32_t  SPISR      :  4;               /*!< [0..3] This field determines the rate at which Sub-Second interrupt
                                                         events are generated.                                                 */
    } SUB_SECOND_INT_SELECT_b;                      /*!< [4] BitSize                                                           */
  };

  union {
    __I  uint32_t  SUB_WEEK_CONTROL;                /*!< (@ 0x4000AC94) Sub-Week Control Register                              */

    struct {
      __IO uint32_t  SUBWEEK_TIMER_POWERUP_EVENT_STATUS:  1;/*!< [0..0] This bit is set to 1 when the Sub-Week Alarm Counter
                                                         Register decrements from 1 to 0 and the POWERUP_EN is 1.
                                                         Writes of 1 clear this bit. Writes of 0 have no effect. Note:
                                                          This bit MUST be cleared to remove a Sub-Week Timer Power-Up
                                                          Event.                                                               */
      __IO uint32_t  WEEK_TIMER_POWERUP_EVENT_STATUS:  1;/*!< [1..1] This bit is set to 1 when the Week Alarm Counter Register
                                                         is greater than or equal the contents of the Week Timer Compare
                                                         Register and the POWERUP_EN is 1. Writes of 1 clear this bit.
                                                          Writes of 0 have no effect.
                                                         Note: This bit does not have to be cleared to remove a Week
                                                          Timer Power-Up Event.                                                */
           uint32_t             :  2;
      __I  uint32_t  TEST       :  1;               /*!< [4..4] Test                                                           */
      __IO uint32_t  TEST0      :  1;               /*!< [5..5] Test                                                           */
      __IO uint32_t  AUTO_RELOAD:  1;               /*!< [6..6] 1= No reload occurs when the Sub-Week Counter expires
                                                         0= Reloads the SUBWEEK_COUNTER_LOAD field into the Sub- Week
                                                         Counter when the counter expires.                                     */
      __IO uint32_t  SUBWEEK_TICK:  3;              /*!< [7..9] This field selects the clock source for the Sub-Week
                                                         Counter.                                                              */
    } SUB_WEEK_CONTROL_b;                           /*!< [10] BitSize                                                          */
  };

  union {
    __I  uint32_t  SUB_WEEK_ALARM_COUNTER;          /*!< (@ 0x4000AC98) Sub-Week Alarm Counter Register                        */

    struct {
      __IO uint32_t  SUBWEEK_COUNTER_LOAD:  9;      /*!< [0..8] Writes with a non-zero value to this field reload the
                                                         9-bit Sub-Week Alarm counter. Writes of 0 disable the counter.
                                                         If the Sub-Week Alarm counter decrements to 0 and the AUTO_RELOAD
                                                          bit is set, the value in this field is automatically loaded
                                                          into the Sub-Week Alarm counter.                                     */
           uint32_t             :  7;
      __IO uint32_t  SUBWEEK_COUNTER_STATUS:  9;    /*!< [16..24] Reads of this register return the current state of
                                                         the 9-bit Sub-Week Alarm counter.                                     */
    } SUB_WEEK_ALARM_COUNTER_b;                     /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  BGPO_DATA;                       /*!< (@ 0x4000AC9C) BGPO Data Register                                     */

    struct {
      __IO uint32_t  BGPO       : 10;               /*!< [0..9] Battery powered General Purpose Output. Each output pin
                                                         may be individually configured to be either a VBAT-power BGPO
                                                          or a VTR
                                                         powered GPIO, based on the corresponding settings in the BGPO
                                                          Power Register. Additionally, each output pin may be individually
                                                          configured
                                                         to reset to 0 on either RESET_VTR or RESET_SYS, based on the
                                                          corresponding settings in the BGPO Reset Register.
                                                         For each bit [i] in the field: 1=BGPO[i] output is high; 0=BGPO[i]
                                                          output is low.                                                       */
    } BGPO_DATA_b;                                  /*!< [10] BitSize                                                          */
  };

  union {
    __IO uint32_t  BGPO_POWER;                      /*!< (@ 0x4000ACA0) BGPO Power Register                                    */

    struct {
           uint32_t             :  1;
      __IO uint32_t  BGPO_POWER :  5;               /*!< [1..5] Battery powered General Purpose Output power source.
                                                         For each bit [i] in the field:
                                                         1=BGPO[i] is powered by VBAT. The BGPO[i] pin is always determined
                                                          by the corresponding bit in the BGPO Data Register. The GPIO
                                                          Input register
                                                         for the GPIO that is multiplexed with the BGPO always returns
                                                          a '1b'.
                                                         0=The pin for BGPO[i] functions as a GPIO. When VTR is powered,
                                                          the pin associated with BGPO[i] is determined by the GPIO associated
                                                          with the pin.
                                                         When VTR is unpowered, the pin is tristated.                          */
    } BGPO_POWER_b;                                 /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint32_t  BGPO_RESET;                      /*!< (@ 0x4000ACA4) BGPO Reset Register                                    */

    struct {
      __IO uint32_t  BGPO_RESET : 10;               /*!< [0..9] Battery powered General Purpose Output reset event. For
                                                         each bit [i] in the field:
                                                         1=BGPO[i] is reset to 0 on RESET_VTR; 0=BGPO[i] is reset to
                                                          0 on RESET_SYS.                                                      */
    } BGPO_RESET_b;                                 /*!< [10] BitSize                                                          */
  };
} WEEK_INST_Type;


/* ================================================================================ */
/* ================                   TACH0_INST                   ================ */
/* ================================================================================ */


/**
  * @brief This block monitors TACH output signals (or locked rotor signals) from
 various types of fans, and determines their speed.  (TACH0_INST)
  */

typedef struct {                                    /*!< (@ 0x40006000) TACH0_INST Structure                                   */

  union {
    __IO uint32_t  TACH_CONTROL;                    /*!< (@ 0x40006000) TACHx Control Register                                 */

    struct {
      __IO uint32_t  TACH_OUT_OF_LIMIT_ENABLE:  1;  /*!< [0..0] TACH_OUT_OF_LIMIT_ENABLE This bit is used to enable the
                                                         TACH_OUT_OF_LIMIT_STATUS bit in the TACHx Status Register to
                                                          generate an interrupt event.
                                                          1=Enable interrupt output from Tach block
                                                          0=Disable interrupt output from Tach block (default)                 */
      __IO uint32_t  TACH_ENABLE:  1;               /*!< [1..1] TACH_ENABLE 1= TACH Monitoring enabled, clocks enabled.
                                                         0= TACH Idle, clocks gated                                            */
           uint32_t             :  6;
      __IO uint32_t  FILTER_ENABLE:  1;             /*!< [8..8] FILTER_ENABLE This filter is used to remove high frequency
                                                         glitches from Tach Input. When this filter is enabled, Tach
                                                          input pulses less than two 100kHz_- Clk periods wide get filtered.
                                                          1= Filter enabled
                                                          0= Filter disabled (default)
                                                          It is recommended that the Tach input filter always be enabled.
                                                                                                                               */
           uint32_t             :  1;
      __IO uint32_t  TACH_READING_MODE_SELECT:  1;  /*!< [10..10] TACH_READING_MODE_SELECT
                                                          1=Counter is incremented on the rising edge of the 100kHz_Clk
                                                         input. The counter is latched into the TACHX_COUNTER field and
                                                          reset when the programmed number of edges is detected.
                                                          0=Counter is incremented when Tach Input transitions from low-tohigh
                                                          state (default)                                                      */
      __IO uint32_t  TACH_EDGES :  2;               /*!< [11..12] TACH_EDGES A Tach signal is a square wave with a 50%
                                                         duty cycle. Typically, two Tach periods represents one revolution
                                                          of the fan. A Tach period consists of three Tach edges. This
                                                          programmed value represents the number of Tach edges that will
                                                          be used to determine the interval for which the number of 100kHz_Clk
                                                          pulses will be counted
                                                          11b=9 Tach edges (4 Tach periods)
                                                          10b=5 Tach edges (2 Tach periods)
                                                          01b=3 Tach edges (1 Tach period)
                                                          00b=2 Tach edges (1/2 Tach period)                                   */
           uint32_t             :  1;
      __IO uint32_t  COUNT_READY_INT_EN:  1;        /*!< [14..14] COUNT_READY_INT_EN 1=Enable Count Ready interrupt from
                                                         Tach block, 0=Disable Count Ready interrupt from Tach block
                                                                                                                               */
      __IO uint32_t  TACH_INPUT_INT_EN:  1;         /*!< [15..15] TACH_INPUT_INT_EN 1=Enable Tach Input toggle interrupt
                                                         from Tach block, 0=Disable Tach Input toggle interrupt from
                                                          Tach block                                                           */
      __I  uint32_t  TACHX_COUNTER: 16;             /*!< [16..31] This 16-bit field contains the latched value of the
                                                         internal Tach pulse counter, which may be configured by the
                                                          Tach Reading Mode Select field to operate as a free-running
                                                          counter or to be gated by the Tach input signal.                     */
    } TACH_CONTROL_b;                               /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  TACHX_STATUS;                    /*!< (@ 0x40006004) TACHx Status Register                                  */

    struct {
      __IO uint32_t  TACH_OUT_OF_LIMIT_STATUS:  1;  /*!< [0..0] TACH_OUT_OF_LIMIT_STATUS 1=Tach is outside of limits,
                                                         0=Tach is within limits (R/WC)                                        */
      __I  uint32_t  TACH_PIN_STATUS:  1;           /*!< [1..1] TACH_PIN_STATUS 1= Tach Input is high, 0= Tach Input
                                                         is low                                                                */
      __IO uint32_t  TOGGLE_STATUS:  1;             /*!< [2..2] TOGGLE_STATUS 1=Tach Input changed state (this bit is
                                                         set on a low-to-high or high-tolow transition), 0=Tach stable
                                                          (R/WC)                                                               */
      __IO uint32_t  COUNT_READY_STATUS:  1;        /*!< [3..3] COUNT_READY_STATUS 1=Reading ready, 0=Reading not ready
                                                                                                                               */
    } TACHX_STATUS_b;                               /*!< [4] BitSize                                                           */
  };

  union {
    __IO uint32_t  TACHX_HIGH_LIMIT;                /*!< (@ 0x40006008) TACH HIGH LIMIT Register                               */

    struct {
      __IO uint32_t  TACH_HIGH_LIMIT: 16;           /*!< [0..15] This value is compared with the value in the TACHX_COUNTER
                                                         field. If the value in the counter is greater than the value
                                                         programmed in this register, the TACH_OUT_OF_LIMIT_STATUS bit
                                                          will be set. The TACH_OUT_OF_LIMIT_STATUS status event may be
                                                          enabled
                                                         to generate an interrupt to the embedded controller via the
                                                          TACH_OUT_OF_LIMIT_ENABLE bit in the TACHx Control Register.
                                                                                                                               */
    } TACHX_HIGH_LIMIT_b;                           /*!< [16] BitSize                                                          */
  };

  union {
    __IO uint32_t  TACHX_LOW_LIMIT;                 /*!< (@ 0x4000600C) TACHx Low Limit Register                               */

    struct {
      __IO uint32_t  TACH_LOW_LIMIT: 16;            /*!< [0..15] This value is compared with the value in the TACHX_COUNTER
                                                         field of the TACHx Control Register. If the value in the counter
                                                         is less than the value programmed in this register, the TACH_OUT_OF_LIMIT_
                                                         STATUS bit will be set. The TACH_OUT_OF_LIMIT_STATUS
                                                         status event may be enabled to generate an interrupt to the
                                                          embedded controller via the TACH_OUT_OF_LIMIT_ENABLE bit in
                                                          the TACHx
                                                         Control Register To disable the TACH_OUT_OF_LIMIT_STATUS low
                                                          event, program 0000h into this register.                             */
    } TACHX_LOW_LIMIT_b;                            /*!< [16] BitSize                                                          */
  };
} TACH0_INST_Type;


/* ================================================================================ */
/* ================                    PWM0_INST                   ================ */
/* ================================================================================ */


/**
  * @brief This block generates a PWM output that can be used to control 4-wire fans, blinking LEDs, and other
 similar devices. Each PWM can generate an arbitrary duty cycle output at frequencies from less than 0.1 Hz to 24 MHz.
 The PWM controller can also used to generate the PROCHOT output and Speaker output.  (PWM0_INST)
  */

typedef struct {                                    /*!< (@ 0x40005800) PWM0_INST Structure                                    */
  __IO uint32_t  COUNTER_ON_TIME;                   /*!< (@ 0x40005800) This field determines both the frequency and
                                                         duty cycle of the PWM signal. Setting this field to a value
                                                          of n will
                                                         cause the On time of the PWM to be n+1 cycles of the PWM Clock
                                                          Source.
                                                         When this field is set to zero and the PWMX_COUNTER_OFF_TIME
                                                          is not set to zero, the PWM_OUTPUT is held low (Full Off).           */
  __IO uint32_t  COUNTER_OFF_TIME;                  /*!< (@ 0x40005804) This field determine both the frequency and duty
                                                         cycle of the PWM signal. Setting this field to a value of n
                                                          will
                                                         cause the Off time of the PWM to be n+1 cycles of the PWM Clock
                                                          Source.
                                                         When this field is set to zero, the PWM_OUTPUT is held high
                                                          (Full On).                                                           */

  union {
    __IO uint32_t  CONFIG;                          /*!< (@ 0x40005808) PWMx CONFIGURATION REGISTER                            */

    struct {
      __IO uint32_t  PWM_ENABLE :  1;               /*!< [0..0] When the PWM_ENABLE is set to 0 the internal counters
                                                         are reset and the internal state machine is set to the OFF state.
                                                         In addition, the PWM_OUTPUT signal is set to the inactive state
                                                          as determined by the Invert bit. The PWMx Counter ON Time Register
                                                         and PWMx Counter OFF Time Register are not affected by the PWM_ENABLE
                                                          bit and may be read and written while the PWM enable bit is
                                                          0.
                                                         1=Enabled (default); 0=Disabled (gates clocks to save power).
                                                                                                                               */
      __IO uint32_t  CLK_SELECT :  1;               /*!< [1..1] This bit determines the clock source used by the PWM
                                                         duty cycle and frequency control logic.
                                                          1=CLOCK_LOW
                                                          0=CLOCK_HIGH                                                         */
      __IO uint32_t  INVERT     :  1;               /*!< [2..2] 1= PWM_OUTPUT ON State is active low; 0=PWM_OUTPUT ON
                                                         State is active high.                                                 */
      __IO uint32_t  CLK_PRE_DIVIDER:  4;           /*!< [3..6] The Clock source for the 16-bit down counter (see PWMx
                                                         Counter ON Time Register and PWMx Counter OFF Time Register)
                                                         is determined by bit D1 of this register. The Clock source is
                                                          then divided by the value of Pre-Divider+1 and the resulting
                                                         signal determines the rate at which the down counter will be
                                                          decremented. For example, a Pre-Divider value of 1 divides
                                                         the input clock by 2 and a value of 2 divides the input clock
                                                          by 3. A Pre-Divider of 0 will disable the Pre-Divider option.
                                                                                                                               */
    } CONFIG_b;                                     /*!< [7] BitSize                                                           */
  };
} PWM0_INST_Type;


/* ================================================================================ */
/* ================                    ADC_INST                    ================ */
/* ================================================================================ */


/**
  * @brief This block is designed to convert external analog voltage readings into digital values.  (ADC_INST)
  */

typedef struct {                                    /*!< (@ 0x40007C00) ADC_INST Structure                                     */

  union {
    __IO uint32_t  CONTROL;                         /*!< (@ 0x40007C00) The ADC Control Register is used to control the
                                                         behavior of the Analog to Digital Converter.                          */

    struct {
      __IO uint32_t  ACTIVATE   :  1;               /*!< [0..0] 0: The ADC is disabled and placed in its lowest power
                                                         state. 1: ADC block is enabled for operation.                         */
      __IO uint32_t  START_SINGLE:  1;              /*!< [1..1] (START_SINGLE) 0: The ADC Single Mode is disabled. 1:
                                                         The ADC Single Mode is enabled. Note: This bit is self-clearing
                                                                                                                               */
      __IO uint32_t  START_REPEAT:  1;              /*!< [2..2] 0: The ADC Repeat Mode is disabled. 1: The ADC Repeat
                                                         Mode is enabled.                                                      */
      __IO uint32_t  POWER_SAVER_DIS:  1;           /*!< [3..3] 0: Power saving feature is enabled. 1: Power saving feature
                                                         is disabled.                                                          */
      __IO uint32_t  SOFT_RESET :  1;               /*!< [4..4] (SOFT_RESET) 1: writing one causes a reset of the ADC
                                                         block hardware (not the registers) 0: writing zero takes the
                                                          ADC block out of reset                                               */
           uint32_t             :  1;
      __IO uint32_t  REPEAT_DONE_STAT:  1;          /*!< [6..6] 0: ADC repeat-sample conversion is not complete. 1: ADC
                                                         repeat-sample conversion is completed. (R/WC)                         */
      __IO uint32_t  SINGLE_DONE_STAT:  1;          /*!< [7..7] 0: ADC single-sample conversion is not complete. 1: ADC
                                                         single-sample conversion is completed. (R/WC)                         */
    } CONTROL_b;                                    /*!< [8] BitSize                                                           */
  };

  union {
    __IO uint32_t  DELAY;                           /*!< (@ 0x40007C04) The ADC Delay register determines the delay from
                                                         setting Start_Repeat in the ADC Control Register and the start
                                                          of a conversion cycle. This register also controls the interval
                                                          between conversion cycles in repeat mode.                            */

    struct {
      __IO uint32_t  START_DELAY: 16;               /*!< [0..15] This field determines the starting delay before a conversion
                                                         cycle is begun when Start_Repeat is written with a 1.                 */
      __IO uint32_t  REPEAT_DELAY: 16;              /*!< [16..31] This field determines the interval between conversion
                                                         cycles when Start_Repeat is 1.                                        */
    } DELAY_b;                                      /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  STATUS;                          /*!< (@ 0x40007C08) The ADC Status Register indicates whether the
                                                         ADC has completed a conversion cycle. All bits are cleared by
                                                          being written with a 1.
                                                          0: conversion of the corresponding ADC channel is not complete
                                                          1: conversion of the corresponding ADC channel is complete
                                                                                                                               */

    struct {
      __IO uint32_t  ADC_CH_STATUS: 16;             /*!< [0..15] All bits are cleared by being written with a '1'. 1=conversion
                                                         of the corresponding ADC channel is complete;
                                                          0=conversion of the corresponding ADC channel is not complete.
                                                          For enabled single cycles, the SINGLE_DONE_STATUS bit in the
                                                          ADC Control Register is also set after all enabled channel
                                                          conversion are done; for enabled repeat cycles, the REPEAT_DONE_STATUS
                                                          in the ADC Control Register is also set after all enabled channel
                                                          conversion are done.                                                 */
    } STATUS_b;                                     /*!< [16] BitSize                                                          */
  };

  union {
    __IO uint32_t  SINGLE_EN;                       /*!< (@ 0x40007C0C) The ADC Single Register is used to control which
                                                         ADC channel is captured during a Single-Sample conversion cycle
                                                          initiated by the Start_Single bit in the ADC Control Register.

                                                          APPLICATION NOTE: Do not change the bits in this register in
                                                          the middle of a conversion cycle to insure proper operation.
                                                          0: single cycle conversions for this channel are disabled
                                                          1: single cycle conversions for this channel are enabled             */

    struct {
      __IO uint32_t  SINGLE_EN  : 16;               /*!< [0..15] Each bit in this field enables the corresponding ADC
                                                         channel when a single cycle of conversions is started when the
                                                          START_SINGLE bit in the ADC Control Register is written with
                                                          a 1. 1=single cycle conversions for this channel are enabled
                                                          0=single cycle conversions for this channel are disabled. Note:
                                                          If this register is changed while a conversion.                      */
    } SINGLE_EN_b;                                  /*!< [16] BitSize                                                          */
  };

  union {
    __IO uint32_t  REPEAT;                          /*!< (@ 0x40007C10) The ADC Repeat Register is used to control which
                                                         ADC channels are captured during a repeat conversion cycle initiated
                                                          by the Start_Repeat bit in the ADC Control Register.                 */

    struct {
      __IO uint32_t  RPT_EN     : 16;               /*!< [0..15] Each bit in this field enables the corresponding ADC
                                                         channel for each pass of the Repeated ADC Conversion that is
                                                          controlled by bit START_REPEAT in the ADC Control Register.
                                                          1=repeat conversions for this channel are enabled;
                                                          0=repeat conversions for this channel are disabled                   */
    } REPEAT_b;                                     /*!< [16] BitSize                                                          */
  };
  __IO uint32_t  ADC_CHANNEL_READING[16];           /*!< (@ 0x40007C14) All 16 ADC channels return their results into
                                                         a 32-bit reading register. In each case the low 10 bits of the
                                                          reading register
                                                          return the result of the Analog to Digital conversion and the
                                                          upper 22 bits return 0.                                              */
} ADC_INST_Type;


/* ================================================================================ */
/* ================                    FAN0_INST                   ================ */
/* ================================================================================ */


/**
  * @brief The RPM-PWM Interface is an RPM based Fan Control Algorithm that monitors the fan's speed and automatically adjusts
 the drive to maintain the desired fan speed. This RPM based Fan Control Algorithm controls a PWM output based on a tachometer input.  (FAN0_INST)
  */

typedef struct {                                    /*!< (@ 0x4000A000) FAN0_INST Structure                                    */

  union {
    __IO uint16_t  FAN_SETTING;                     /*!< (@ 0x4000A000) The Fan Driver Setting used to control the output
                                                         of the Fan Driver.                                                    */

    struct {
           uint16_t             :  6;
      __IO uint16_t  FAN_SETTING: 10;               /*!< [6..15] The Fan Driver Setting used to control the output of
                                                         the Fan Driver.                                                       */
    } FAN_SETTING_b;                                /*!< [16] BitSize                                                          */
  };

  union {
    __IO uint16_t  CONFIGURATION;                   /*!< (@ 0x4000A002) The Fan Configuration Register controls the general
                                                         operation of the RPM based Fan Control Algorithm used by the
                                                          fan driver.                                                          */

    struct {
      __IO uint16_t  UPDATE     :  3;               /*!< [0..2] Determines the base time between fan driver updates.
                                                         The Update Time, along with the Fan Step Register, is used to
                                                          control
                                                          the ramp rate of the drive response to provide a cleaner transition
                                                          of the actual fan operation as the desired fan speed changes.
                                                          7=1600ms
                                                          6=1200ms
                                                          5=800ms
                                                          4=500ms
                                                          3=400ms
                                                          2=300ms
                                                          1=200ms
                                                          0=100ms
                                                          Note: This ramp rate control applies for all changes to the
                                                          active PWM output including when the RPM based Fan Speed Control
                                                          Algorithm
                                                          is disabled.                                                         */
      __IO uint16_t  EDGES      :  2;               /*!< [3..4] Determines the minimum number of edges that must be detected
                                                         on the TACH signal to determine a single rotation. A typical
                                                          fan measured 5 edges (for a 2-pole fan). Increasing the number
                                                          of edges measured with respect to the number of poles of the
                                                          fan will
                                                          cause the TACH Reading registers to indicate a fan speed that
                                                          is higher or lower than the actual speed. In order for the FSC
                                                          Algorithm
                                                          to operate correctly, the TACH Target must be updated by the
                                                          user to accommodate this shift. The Effective Tach Multip            */
      __IO uint16_t  RANGE      :  2;               /*!< [5..6] Adjusts the range of reported and programmed tachometer
                                                         reading values. The RANGE bits determine the weighting of all
                                                          TACH values (including the Valid TACH Count, TACH Target, and
                                                          TACH reading).
                                                          3=Reported Minimum RPM: 4000. Tach Count Multiplier: 1
                                                          2=Reported Minimum RPM: 2000. Tach Count Multiplier: 2
                                                          1=Reported Minimum RPM: 1000. Tach Count Multiplier: 4
                                                          0=Reported Minimum RPM: 500. Tach Count Multiplier: 8                */
      __IO uint16_t  EN_ALGO    :  1;               /*!< [7..7] Enables the RPM based Fan Control Algorithm.
                                                          1=The control circuitry is enabled and the Fan Driver output
                                                         will be automatically updated to maintain the programmed fan
                                                          speed
                                                          as indicated by the TACH Target Register.
                                                          0=The control circuitry is disabled and the fan driver output
                                                          is determined by the Fan Driver Setting Register.                    */
           uint16_t             :  1;
      __IO uint16_t  POLARITY   :  1;               /*!< [9..9] Determines the polarity of the PWM driver. This does
                                                         NOT affect the drive setting registers. A setting of 0% drive
                                                          will
                                                          still correspond to 0% drive independent of the polarity.
                                                          1 - The Polarity of the PWM driver is inverted. A drive setting
                                                          of 00h will cause the output to be set at 100% duty cycle and
                                                          a drive setting of FFh will cause the output to be set at 0%
                                                          duty cycle.
                                                          0 - the Polarity of the PWM driver is normal. A drive setting
                                                          of 00h will cause the output to be set at 0% duty cycle and
                                                          a drive                                                              */
      __IO uint16_t  ERR_RNG    :  2;               /*!< [10..11] Control some of the advanced options that affect the
                                                         error window. When the measured fan speed is within the programmed
                                                          error window around the target speed, the fan drive setting
                                                          is not updated. These bits only apply if the Fan Speed Control
                                                          Algorithm is used.
                                                          3=200 RPM
                                                          2=100 RPM
                                                          1=50 RPM
                                                          0=0 RPM                                                              */
      __IO uint16_t  DER_OPT    :  2;               /*!< [12..13] Control some of the advanced options that affect the
                                                         derivative portion of the RPM based fan control algorithm.
                                                          These bits only apply if the Fan Speed Control Algorithm is
                                                          used.                                                                */
      __IO uint16_t  DIS_GLITCH :  1;               /*!< [14..14] Disables the low pass glitch filter that removes high
                                                         frequency noise injected on the TACH pin.
                                                          1 - The glitch filter is disabled.
                                                          0 - The glitch filter is enabled.                                    */
      __IO uint16_t  EN_RRC     :  1;               /*!< [15..15] Enables the ramp rate control circuitry during the
                                                         Manual Mode of operation.
                                                          1=The ramp rate control circuitry for the Manual Mode of operation
                                                          is enabled. The PWM setting will follow the ramp rate controls
                                                          as determined by the Fan Step and Update Time settings. The
                                                          maximum PWM step is capped at the Fan Step setting and is updated
                                                          based on the Update Time as given by the field UPDATE.
                                                          0=The ramp rate control circuitry for the Manual Mode of operation
                                                          is disabled. When the Fan Drive Setting values are c                 */
    } CONFIGURATION_b;                              /*!< [16] BitSize                                                          */
  };

  union {
    __IO uint8_t   PWM_DIVIDE;                      /*!< (@ 0x4000A004) PWM Divide                                             */

    struct {
      __IO uint8_t   PWM_DIVIDE :  8;               /*!< [0..7] The PWM Divide value determines the final frequency of
                                                         the PWM driver. The driver base frequency is divided by the
                                                         PWM Divide value to determine the final frequency.                    */
    } PWM_DIVIDE_b;                                 /*!< [8] BitSize                                                           */
  };

  union {
    __IO uint8_t   GAIN;                            /*!< (@ 0x4000A005) Gain Register stores the gain terms used by the
                                                         proportional and integral portions of the RPM based Fan Control
                                                          Algorithm.                                                           */

    struct {
      __IO uint8_t   GAINP      :  2;               /*!< [0..1] The proportional gain term.
                                                          Gain Factor:
                                                          3=8x
                                                          2=4x
                                                          1=2x
                                                          0=1x                                                                 */
      __IO uint8_t   GAINI      :  2;               /*!< [2..3] The integral gain term.
                                                          Gain Factor:
                                                          3=8x
                                                          2=4x
                                                          1=2x
                                                          0=1x                                                                 */
      __IO uint8_t   GAIND      :  2;               /*!< [4..5] The derivative gain term.
                                                          Gain Factor:
                                                          3=8x
                                                          2=4x
                                                          1=2x
                                                          0=1x                                                                 */
    } GAIN_b;                                       /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint8_t   SPIN_UP_CONFIGURATION;           /*!< (@ 0x4000A006) The Fan Spin Up Configuration Register controls
                                                         the settings of Spin Up Routine.                                      */

    struct {
      __IO uint8_t   SPINUP_TIME:  2;               /*!< [0..1] Determines the maximum Spin Time that the Spin Up Routine
                                                         will run for. If a valid tachometer measurement is not
                                                          detected before the Spin Time has elapsed, an interrupt will
                                                          be generated. When the RPM based Fan Control Algorithm is active,
                                                          the fan driver will attempt to re-start the fan immediately
                                                          after the end of the last spin up attempt.
                                                          3=2 seconds
                                                          2=1 second
                                                          1=500 ms
                                                          0=250 ms                                                             */
      __IO uint8_t   SPIN_LVL   :  3;               /*!< [2..4] Determines the final drive level that is used by the
                                                         Spin Up Routine.
                                                          7=65%
                                                          6=60%
                                                          5=55%
                                                          4=50%
                                                          3=45%
                                                          2=40%
                                                          1=35%
                                                          0=30%                                                                */
      __IO uint8_t   NOKICK     :  1;               /*!< [5..5] Determines if the Spin Up Routine will drive the fan
                                                         to 100% duty cycle for 1/4 of the programmed spin up time before
                                                          driving it at the programmed level.
                                                          1=The Spin Up Routine will not drive the PWM to 100%. It will
                                                          set the drive at the programmed spin level for the entire duration
                                                          of
                                                          the programmed spin up time
                                                          0=The Spin Up Routine will drive the PWM to 100% for 1/4 of
                                                          the programmed spin up time before reverting to the programmed
                                                          spin level.                                                          */
      __IO uint8_t   DRIVE_FAIL_CNT:  2;            /*!< [6..7] Determines how many update cycles are used for the Drive
                                                         Fail detection function. This circuitry determines whether the
                                                          fan can be driven to the desired Tach target. These settings
                                                          only apply if the Fan Speed Control Algorithm is enabled.
                                                          3=Drive Fail detection circuitry will count for 64 update periods
                                                          2=Drive Fail detection circuitry will count for 32 update periods
                                                          1=Drive Fail detection circuitry will count for 16 update periods
                                                          0=Drive Fail detection circuitry is disabled.                        */
    } SPIN_UP_CONFIGURATION_b;                      /*!< [8] BitSize                                                           */
  };

  union {
    __IO uint8_t   FAN_STEP;                        /*!< (@ 0x4000A007) FAN_STEP The Fan Step value represents the maximum
                                                         step size the fan driver will take between update times               */

    struct {
      __IO uint8_t   FAN_STEP   :  8;               /*!< [0..7] The Fan Step value represents the maximum step size the
                                                         fan driver will take between update times.
                                                         When the PWM_BASE frequency range field in the PWM Driver Base
                                                          Frequency Register is set to the value 1, 2 or 3, this 8-bit
                                                          field
                                                         is added to the 10-bit PWM duty cycle, for a maximum step size
                                                          of 25%. When the PWM_BASE field is set to 0, the PWM operates
                                                          in
                                                         an 8-bit mode. In 8-bit mode, this 8-bit field is added to the
                                                          8-bit duty cycle, for a maximum step size of 100%.                   */
    } FAN_STEP_b;                                   /*!< [8] BitSize                                                           */
  };

  union {
    __IO uint8_t   MINIMUM_DRIVE;                   /*!< (@ 0x4000A008) the minimum drive setting for the RPM based Fan
                                                         Control Algorithm.                                                    */

    struct {
      __IO uint8_t   MIN_DRIVE  :  8;               /*!< [0..7] The minimum drive setting.                                     */
    } MINIMUM_DRIVE_b;                              /*!< [8] BitSize                                                           */
  };

  union {
    __IO uint8_t   VALID_TACH_COUNT;                /*!< (@ 0x4000A009) The maximum TACH Reading Register value to indicate
                                                         that the fan is spinning properly.                                    */

    struct {
      __IO uint8_t   VALID_TACH_CNT:  8;            /*!< [0..7] The maximum TACH Reading Register value to indicate that
                                                         the fan is spinning properly.                                         */
    } VALID_TACH_COUNT_b;                           /*!< [8] BitSize                                                           */
  };

  union {
    __IO uint16_t  FAN_DRIVE_FAIL_BAND;             /*!< (@ 0x4000A00A) The number of Tach counts used by the Fan Drive
                                                         Fail detection circuitry                                              */

    struct {
           uint16_t             :  3;
      __IO uint16_t  FAN_DRIVE_FAIL_BAND: 13;       /*!< [3..15] The number of Tach counts used by the Fan Drive Fail
                                                         detection circuitry.                                                  */
    } FAN_DRIVE_FAIL_BAND_b;                        /*!< [16] BitSize                                                          */
  };

  union {
    __IO uint16_t  TACH_TARGET;                     /*!< (@ 0x4000A00C) The target tachometer value.                           */

    struct {
           uint16_t             :  3;
      __IO uint16_t  TACH_TARGET: 13;               /*!< [3..15] The target tachometer value.                                  */
    } TACH_TARGET_b;                                /*!< [16] BitSize                                                          */
  };

  union {
    __IO uint16_t  TACH_READING;                    /*!< (@ 0x4000A00E) [15:3] The current tachometer reading value.
                                                                                                                               */

    struct {
           uint16_t             :  3;
      __I  uint16_t  TACH_READING: 13;              /*!< [3..15] The current tachometer reading value.                         */
    } TACH_READING_b;                               /*!< [16] BitSize                                                          */
  };

  union {
    __IO uint8_t   DRIVER_BASE_FREQUENCY;           /*!< (@ 0x4000A010) [1:0] Determines the frequency range of the PWM
                                                         fan driver                                                            */

    struct {
      __IO uint8_t   PWM_BASE   :  2;               /*!< [0..1] Determines the frequency range of the PWM fan driver
                                                         (when enabled). PWM resolution is 10-bit, except when this field
                                                         is set to '0b', when it is 8-bit.
                                                         3=2.34KHz
                                                         2=4.67KHz
                                                         1=23.4KHz
                                                         0=26.8KHz                                                             */
    } DRIVER_BASE_FREQUENCY_b;                      /*!< [2] BitSize                                                           */
  };

  union {
    __IO uint8_t   STATUS;                          /*!< (@ 0x4000A011) The bits in this register are routed to interrupts.
                                                                                                                               */

    struct {
      __IO uint8_t   FAN_STALL  :  1;               /*!< [0..0] The bit Indicates that the tachometer measurement on
                                                         the Fan detects a stalled fan. (R/WC)
                                                          0 - Stalled fan not detected.
                                                          1 - Stalled fan detected.                                            */
      __IO uint8_t   FAN_SPIN   :  1;               /*!< [1..1] The bit Indicates that the Spin up Routine for the Fan
                                                         could not detect a valid tachometer reading within its maximum
                                                          time window. (R/WC)
                                                          1 - The Spin up Routine for the Fan could not detect a valid
                                                          tachometer reading within its maximum time window.
                                                          0 - The Spin up Routine for the Fan detected a valid tachometer
                                                          reading within its maximum time window.                              */
           uint8_t              :  3;
      __IO uint8_t   DRIVE_FAIL :  1;               /*!< [5..5] The bit Indicates that the RPM-based Fan Speed Control
                                                         Algorithm cannot drive the Fan to the desired target setting
                                                          at
                                                          maximum drive. (R/WC)
                                                          1- The RPM-based Fan Speed Control Algorithm cannot drive Fan
                                                          to the desired target setting at maximum drive.
                                                          0- The RPM-based Fan Speed Control Algorithm can drive Fan
                                                          to the desired target setting.                                       */
    } STATUS_b;                                     /*!< [6] BitSize                                                           */
  };
} FAN0_INST_Type;


/* ================================================================================ */
/* ================                    LED0_INST                   ================ */
/* ================================================================================ */


/**
  * @brief The blinking/breathing hardware is implemented using a PWM. The PWM can be driven either by the 48 MHz
 clock or by a 32.768 KHz clock input. When driven by the 48 MHz clock, the PWM can be used as a standard 8-bit
 PWM in order to control a fan. When used to drive blinking or breathing LEDs, the 32.768 KHz clock source is used.  (LED0_INST)
  */

typedef struct {                                    /*!< (@ 0x4000B800) LED0_INST Structure                                    */

  union {
    __IO uint32_t  CONFIG;                          /*!< (@ 0x4000B800) LED Configuration                                      */

    struct {
      __IO uint32_t  CONTROL    :  2;               /*!< [0..1] CONTROL 3=PWM is always on
                                                          2=LED blinking (standard PWM)
                                                          1=LED breathing configuration
                                                          0=PWM is always off. All internal registers and counters are
                                                         reset to 0. Clocks are gated                                          */
      __IO uint32_t  CLOCK_SOURCE:  1;              /*!< [2..2] 1=Clock source is the 48 MHz clock, 0=Clock source is
                                                         the 32.768 KHz clock                                                  */
      __IO uint32_t  SYNCHRONIZE:  1;               /*!< [3..3] SYNCHRONIZE When this bit is '1', all counters for all
                                                         LEDs are reset to their initial values. When this bit is '0'
                                                          in the LED Configuration Register for all LEDs, then all counters
                                                          for LEDs that are configured to blink or breathe will increment
                                                          or decrement, as required.                                           */
      __IO uint32_t  PWM_SIZE   :  2;               /*!< [4..5] PWM_SIZE This bit controls the behavior of PWM:
                                                          3=Reserved
                                                          2=PWM is configured as a 6-bit PWM
                                                          1=PWM is configured as a 7-bit PWM
                                                          0=PWM is configured as an 8-bit PWM                                  */
      __IO uint32_t  ENABLE_UPDATE:  1;             /*!< [6..6] ENABLE_UPDATE This bit is set to 1 when written with
                                                         a '1'. Writes of '0' have no effect. Hardware clears this bit
                                                          to 0 when the breathing configuration registers are updated
                                                          at the end of a PWM period. The current state of the bit is
                                                          readable any time.                                                   */
      __O  uint32_t  RESET      :  1;               /*!< [7..7] RESET Writes of '1' to this bit resets the PWM registers
                                                         to their default values. This bit is self clearing. Writes of
                                                          '0' to this bit have no effect.                                      */
      __IO uint32_t  WDT_RELOAD :  8;               /*!< [8..15] WDT_RELOAD The PWM Watchdog Timer counter reload value.
                                                         On system reset, it defaults to 14h, which corresponds to a
                                                          4 second Watchdog timeout value.                                     */
      __IO uint32_t  SYMMETRY   :  1;               /*!< [16..16] SYMMETRY 1=The rising and falling ramp times are in
                                                         Asymmetric mode.
                                                          0=The rising and falling ramp times are in Symmetric mode.
                                                                                                                               */
    } CONFIG_b;                                     /*!< [17] BitSize                                                          */
  };

  union {
    __IO uint32_t  LIMITS;                          /*!< (@ 0x4000B804) LED Limits This register may be written at any
                                                         time. Values written into the register are held in an holding
                                                          register, which is transferred into the actual register at the
                                                          end of a PWM period. The two byte fields may be written independently.
                                                          Reads of this register return the current contents and not the
                                                          value of the holding register.                                       */

    struct {
      __IO uint32_t  MINIMUM    :  8;               /*!< [0..7] In breathing mode, when the current duty cycle is less
                                                         than or equal to this value the breathing apparatus holds the
                                                          current duty cycle for the period specified by the field LD
                                                          in register LED_DELAY, then starts incrementing the current
                                                          duty cycle In blinking mode, this field defines the duty cycle
                                                          of the blink function.                                               */
      __IO uint32_t  MAXIMUM    :  8;               /*!< [8..15] In breathing mode, when the current duty cycle is greater
                                                         than or equal to this value the breathing apparatus holds the
                                                          current duty cycle for the period specified by the field HD
                                                          in register LED_DELAY, then starts decrementing the current
                                                          duty cycle                                                           */
    } LIMITS_b;                                     /*!< [16] BitSize                                                          */
  };

  union {
    __IO uint32_t  DELAY;                           /*!< (@ 0x4000B808) LED Delay                                              */

    struct {
      __IO uint32_t  LOW_PULSE  : 12;               /*!< [0..11] The number of PWM periods to wait before updating the
                                                         current duty cycle when the current duty cycle is greater than
                                                          or equal to the value MIN in register LED_LIMIT.                     */
      __IO uint32_t  HIGH_PULSE : 12;               /*!< [12..23] In breathing mode, the number of PWM periods to wait
                                                         before updating the current duty cycle when the current duty
                                                          cycle is greater than or equal to the value MAX in register
                                                          LED_LIMIT.                                                           */
    } DELAY_b;                                      /*!< [24] BitSize                                                          */
  };

  union {
    __IO uint32_t  UPDATE_STEPSIZE;                 /*!< (@ 0x4000B80C) This register has eight segment fields which
                                                         provide the amount the current duty cycle is adjusted at the
                                                          end of every PWM period. Segment field selection is decoded
                                                          based on the segment index. The segment index equation utilized
                                                          depends on the SYMMETRY bit in the LED Configuration Register
                                                          Register) . In Symmetric Mode the Segment_Index[2:0] = Duty
                                                          Cycle Bits[7:5]
                                                          . In Asymmetric Mode the Segment_Index[2:0] is the bit concatenation
                                                          of following: Segment_Index[2] = (FALLING RAMP TIME in Fig           */

    struct {
      __IO uint32_t  STEP0      :  4;               /*!< [0..3] Amount the current duty cycle is adjusted at the end
                                                         of every PWM period when the segment index is equal to 000.
                                                                                                                               */
      __IO uint32_t  STEP1      :  4;               /*!< [4..7] Amount the current duty cycle is adjusted at the end
                                                         of every PWM period when the segment index is equal to 001.
                                                                                                                               */
      __IO uint32_t  STEP2      :  4;               /*!< [8..11] Amount the current duty cycle is adjusted at the end
                                                         of every PWM period when the segment index is equal to 010.
                                                                                                                               */
      __IO uint32_t  STEP3      :  4;               /*!< [12..15] Amount the current duty cycle is adjusted at the end
                                                         of every PWM period when the segment index is equal to 011.
                                                                                                                               */
      __IO uint32_t  STEP4      :  4;               /*!< [16..19] Amount the current duty cycle is adjusted at the end
                                                         of every PWM period when the segment index is equal to 100.
                                                                                                                               */
      __IO uint32_t  STEP5      :  4;               /*!< [20..23] Amount the current duty cycle is adjusted at the end
                                                         of every PWM period when the segment index is equal to 101            */
      __IO uint32_t  STEP6      :  4;               /*!< [24..27] Amount the current duty cycle is adjusted at the end
                                                         of every PWM period when the segment index is equal to 110.
                                                                                                                               */
      __IO uint32_t  STEP7      :  4;               /*!< [28..31] Amount the current duty cycle is adjusted at the end
                                                         of every PWM period when the segment index is equal to 111.
                                                                                                                               */
    } UPDATE_STEPSIZE_b;                            /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  UPDATE_INTERVAL;                 /*!< (@ 0x4000B810) LED Update Interval                                    */

    struct {
      __IO uint32_t  INTERVAL0  :  4;               /*!< [0..3] The number of PWM periods between updates to current
                                                         duty cycle when the segment index is equal to 000b.                   */
      __IO uint32_t  INTERVAL1  :  4;               /*!< [4..7] The number of PWM periods between updates to current
                                                         duty cycle when the segment index is equal to 001b.                   */
      __IO uint32_t  INTERVAL2  :  4;               /*!< [8..11] The number of PWM periods between updates to current
                                                         duty cycle when the segment index is equal to 010b.                   */
      __IO uint32_t  INTERVAL3  :  4;               /*!< [12..15] The number of PWM periods between updates to current
                                                         duty cycle when the segment index is equal to 011b.                   */
      __IO uint32_t  INTERVAL4  :  4;               /*!< [16..19] The number of PWM periods between updates to current
                                                         duty cycle when the segment index is equal to 100b.                   */
      __IO uint32_t  INTERVAL5  :  4;               /*!< [20..23] The number of PWM periods between updates to current
                                                         duty cycle when the segment index is equal to 101b.                   */
      __IO uint32_t  INTERVAL6  :  4;               /*!< [24..27] The number of PWM periods between updates to current
                                                         duty cycle when the segment index is equal to 110b.                   */
      __IO uint32_t  INTERVAL7  :  4;               /*!< [28..31] The number of PWM periods between updates to current
                                                         duty cycle when the segment index is equal to 111b.                   */
    } UPDATE_INTERVAL_b;                            /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  LED_OUTPUT_DELAY;                /*!< (@ 0x4000B814) LED Output Delay                                       */

    struct {
      __IO uint32_t  OUTPUT_DELAY:  8;              /*!< [0..7] The delay, in counts of the clock defined in Clock Source
                                                         (CLKSRC), in which output transitions are delayed.
                                                         When this field is 0, there is no added transition delay. When
                                                          the LED is programmed to be Always On or Always Off, the
                                                         Output Delay field has no effect.                                     */
    } LED_OUTPUT_DELAY_b;                           /*!< [8] BitSize                                                           */
  };
} LED0_INST_Type;


/* ================================================================================ */
/* ================                   RC_ID0_INST                  ================ */
/* ================================================================================ */


/**
  * @brief This interface provides a single pin interface which can discriminate a number of quantized RC constants.  (RC_ID0_INST)
  */

typedef struct {                                    /*!< (@ 0x40001400) RC_ID0_INST Structure                                  */

  union {
    __IO uint32_t  RC_ID_CONTROL;                   /*!< (@ 0x40001400) RC_ID Control Register                                 */

    struct {
      __IO uint32_t  DONE       :  1;               /*!< [0..0] This bit is cleared to 0 when the RC_ID interface is
                                                         in the Reset phase, and set to 1 when the interface completes
                                                          an RC_ID measurement.                                                */
      __IO uint32_t  TC         :  1;               /*!< [1..1] This bit is cleared to 0 when the RC_ID interface is
                                                         in the Reset phase, and set to 1 when the interface completes
                                                          the Discharged phase of an RC_ID measurement.                        */
      __IO uint32_t  CY_ER      :  1;               /*!< [2..2] This bit is 1 if an RC_ID measurement encountered an
                                                         error and the reading in the RC_ID Data Register is invalid.
                                                          This bit is cleared to 0 when the RC_ID interface is in the
                                                          Reset phase.                                                         */
           uint32_t             :  3;
      __IO uint32_t  START      :  1;               /*!< [6..6] Setting this bit to 1 initiates the Discharged phase
                                                         of an RC_ID measurement.                                              */
      __IO uint32_t  ENABLE     :  1;               /*!< [7..7] Clearing the bit to 0 causes the RC_ID interface to enter
                                                         the Reset state, gating its clocks, clearing the status bits
                                                          in this register and entering into its lowest power state. Setting
                                                          this bit to 1 causes the RC_ID interface to enter the Armed
                                                          phase of an RC_ID measurement.                                       */
      __IO uint32_t  CLOCK_SET  :  2;               /*!< [8..9] This field selects the frequency of the Counter circuit
                                                         clock. This field must retain the same value as long as the
                                                          ENABLE bit in this register is 1.                                    */
    } RC_ID_CONTROL_b;                              /*!< [10] BitSize                                                          */
  };

  union {
    __IO uint32_t  RC_ID_DATA;                      /*!< (@ 0x40001404) Reads of this register provide the result of
                                                         an RC_ID measurement.                                                 */

    struct {
      __I  uint32_t  RCID_DATA  : 16;               /*!< [0..15] Reads of this register provide the result of an RC_ID
                                                         measurement.                                                          */
    } RC_ID_DATA_b;                                 /*!< [16] BitSize                                                          */
  };
} RC_ID0_INST_Type;


/* ================================================================================ */
/* ================                    KMS_INST                    ================ */
/* ================================================================================ */


/**
  * @brief The Keyboard Scan Interface block provides a register interface to the EC
 to directly scan an external keyboard matrix of size up to 18x8.  (KMS_INST)
  */

typedef struct {                                    /*!< (@ 0x40009C00) KMS_INST Structure                                     */
  __I  uint32_t  RESERVED;

  union {
    __IO uint32_t  KSO_CONTROL;                     /*!< (@ 0x40009C04) KSO Select and control                                 */

    struct {
      __IO uint32_t  SELECT     :  5;               /*!< [0..4] This field selects a KSO line (00000b = KSO[0] etc.)
                                                         for output according to the value off KSO_INVERT in this register.
                                                                                                                               */
      __IO uint32_t  ALL        :  1;               /*!< [5..5] 0=When key scan is enabled, KSO output controlled by
                                                         the KSO_SELECT field.
                                                          1=KSO[x] driven high when selected.                                  */
      __IO uint32_t  KSEN       :  1;               /*!< [6..6] 0= Keyboard scan enabled, 1= Keyboard scan disabled.
                                                         All KSO output buffers disabled.                                      */
      __IO uint32_t  INVERT     :  1;               /*!< [7..7] 0= KSO[x] driven low when selected, 1= KSO[x] driven
                                                         high when selected.                                                   */
    } KSO_CONTROL_b;                                /*!< [8] BitSize                                                           */
  };
  __I  uint32_t  KSI;                               /*!< (@ 0x40009C08) [7:0] This field returns the current state of
                                                         the KSI pins.                                                         */
  __IO uint32_t  KSI_STATUS;                        /*!< (@ 0x40009C0C) [7:0] Each bit in this field is set on the falling
                                                         edge of the corresponding KSI input pin.
                                                          A KSI interrupt is generated when its corresponding status
                                                          bit and interrupt enable bit are both set. KSI interrupts are
                                                          logically ORed together to produce KSC_INT and KSC_INT_WAKE.
                                                          Writing a '1' to a bit will clear it. Writing a '0' to a bit
                                                          has no effect.                                                       */
  __IO uint32_t  KSI_INT_EN;                        /*!< (@ 0x40009C10) [7:0] Each bit in KSI_INT_EN enables interrupt
                                                         generation due to highto-low transition on a KSI input. An interrupt
                                                          is generated when the corresponding bits in KSI_STATUS and KSI_INT_EN
                                                          are both set.                                                        */
  __IO uint32_t  EXTENDED_CONTROL;                  /*!< (@ 0x40009C14) [0:0] PREDRIVE_ENABLE enables the PREDRIVE mode
                                                         to actively drive the KSO pins high for approximately 100ns
                                                          before switching to open-drain operation.
                                                          0=Disable predrive on KSO pins
                                                          1=Enable predrive on KSO pins.                                       */
} KMS_INST_Type;


/* ================================================================================ */
/* ================                    SMB0_INST                   ================ */
/* ================================================================================ */


/**
  * @brief The SMBus interface can handle standard SMBus 2.0 protocols as well as I2C interface.  (SMB0_INST)
  */

typedef struct {                                    /*!< (@ 0x40004000) SMB0_INST Structure                                    */

  union {
    union {
      __I  uint32_t  STATUS;                        /*!< (@ 0x40004000) Status Register                                        */

      struct {
        __I  uint32_t  NBB      :  1;               /*!< [0..0] The Bus Busy bit (NBB) is a read-only flag indicating
                                                         when the bus is in use. A zero indicates that the bus is busy
                                                          and access is not possible.                                          */
        __I  uint32_t  LAB      :  1;               /*!< [1..1] The Lost Arbitration Bit (LAB) is set when, in multi-master
                                                         operation, arbitration is lost to another master on the bus
                                                                                                                               */
        __I  uint32_t  AAS      :  1;               /*!< [2..2] The Addressed As Slave bit (AAS) is valid only when PIN
                                                         is asserted ('0'). When acting as slave, AAS is set when an
                                                          incoming address over the bus matches the value in the Own Address
                                                          Register or if the 'general call' address (00h) has been received
                                                                                                                               */
        __I  uint32_t  LRB_AD0  :  1;               /*!< [3..3] The "Last Received Bit" or "Address 0" (general call)
                                                         bit (LRB/AD0) serves a dual function and is valid only while
                                                          the PIN bit is asserted ('0').
                                                          When the AAS bit is not asserted ('0') (i.e., not addressed
                                                          as a slave), the LRB/AD0 holds the value of the last received
                                                          bit over the bus.
                                                          When the AAS bit is asserted ('1') (i.e., addressed as slave),
                                                          the SMB Controller Core has been addressed as a slave.               */
        __I  uint32_t  BER      :  1;               /*!< [4..4] When Bus Error (BER) is asserted, a misplaced START or
                                                         STOP condition or Bus Time-Outs have been detected.                   */
        __I  uint32_t  STS      :  1;               /*!< [5..5] When in slave receiver mode, STS is asserted ('1') when
                                                         an externally generated STOP condition is detected. Note that
                                                          STS is used only in slave receiver mode.                             */
        __I  uint32_t  SAD      :  1;               /*!< [6..6] SMBus Address Decoded (SAD)                                    */
        __I  uint32_t  PIN      :  1;               /*!< [7..7] Pending Interrupt bit                                          */
      } STATUS_b;                                   /*!< [8] BitSize                                                           */
    };

    union {
      __O  uint32_t  CONTROL;                       /*!< (@ 0x40004000) Control Register                                       */

      struct {
        __IO uint32_t  ACK      :  1;               /*!< [0..0] The Acknowledge bit (ACK) must normally be asserted ('1').
                                                         This causes the controller to send an acknowledge automatically
                                                          after each byte (this occurs during the 9th clock pulse). The
                                                          ACK bit must not be asserted ('0') when the controller is operating
                                                          in master/receiver mode and requires no further data to be sent
                                                          from the slave transmitter. This causes a negative acknowledge
                                                          on the I2C bus, which halts further transmission from the slave
                                                          device.                                                              */
        __IO uint32_t  STO      :  1;               /*!< [1..1] See STA description                                            */
        __IO uint32_t  STA      :  1;               /*!< [2..2] The STA and STO bits control the generation of the I2C
                                                         Start condition and the transmission of the Slave Address and
                                                          R/nW bit (from the Data Register), generation of repeated Start
                                                          condition, and generation of the Stop condition                      */
        __IO uint32_t  ENI      :  1;               /*!< [3..3] Enable Interrupt bit (ENI) controls the Interrupt Interface
                                                                                                                               */
             uint32_t           :  2;
        __IO uint32_t  ESO      :  1;               /*!< [6..6] The Enable Serial Output bit (ESO) enables and disables
                                                         the SMB Controller Core serial data output (SDAT)                     */
        __IO uint32_t  PIN      :  1;               /*!< [7..7] The Pending Interrupt Not (PIN) bit serves as a software
                                                         reset function. Writing the PIN bit to a logic '1' de-asserts
                                                          all status bits except for the nBB bit which is not affected
                                                          by the PIN bit. The PIN bit is a self-clearing bit. Writing
                                                          this bit to a logic '0' has no effect.                               */
      } CONTROL_b;                                  /*!< [8] BitSize                                                           */
    };
  };

  union {
    __IO uint32_t  OWN;                             /*!< (@ 0x40004004) Own Address Register
                                                          Note that the Data Register and Own Address fields are offset
                                                         by one bit, so that programming Own Address 1 with a value of
                                                          55h will result in the value AAh being recognized as the SMB
                                                          Controller Core slave address.                                       */

    struct {
      __IO uint32_t  OWN_ADDRESS_1:  7;             /*!< [0..6] The Own Address 1 bits configure one of the two addresses
                                                         to which the SMB Controller Core will respond when addressed
                                                          as a slave.                                                          */
           uint32_t             :  1;
      __IO uint32_t  OWN_ADDRESS_2:  7;             /*!< [8..14] The Own Address 2 bits configure one of the two addresses
                                                         to which the SMB Controller Core will respond when addressed
                                                          as a slave.                                                          */
    } OWN_b;                                        /*!< [15] BitSize                                                          */
  };
  __IO uint8_t   DATA_REG;                          /*!< (@ 0x40004008) This register holds the data that are either
                                                         shifted out to or shifted in from the I2C port.                       */
  __I  uint8_t   RESERVED[3];

  union {
    __IO uint32_t  MASTER_COMMAND;                  /*!< (@ 0x4000400C) SMBus Master Command Register                          */

    struct {
      __IO uint32_t  MRUN       :  1;               /*!< [0..0] While this bit is 1, transfer bytes over SMBus. As long
                                                         as WriteCount is non-zero, a byte from the Master Transmit Buffer
                                                          is transmitted to the slave device and WriteCount is decremented.
                                                                                                                               */
      __IO uint32_t  MPROCEED   :  1;               /*!< [1..1] When this bit is 0, the Master State Machine does not
                                                         transition out of the IDLE or PAUSE states. When this bit is
                                                          1, the Master State Machine immediately transitions to the WAIT-BUSBUSY
                                                          and MRUN-RECEIVE states, respectively.                               */
           uint32_t             :  6;
      __IO uint32_t  START0     :  1;               /*!< [8..8] If this bit is 1, send a Start bit on the SMBus before
                                                         the first byte of the WriteCount is sent to the SMBus transmitter.
                                                                                                                               */
      __IO uint32_t  STARTN     :  1;               /*!< [9..9] If this bit is 1, send a Start bit just before the last
                                                         byte of the WriteCount is sent to the SMBus transmitter.              */
      __IO uint32_t  STOP       :  1;               /*!< [10..10] If this bit is 1, send a Stop bit after the transaction
                                                         completes.                                                            */
      __IO uint32_t  PEC_TERM   :  1;               /*!< [11..11] If this bit is 1, a copy of the PEC register is transmitted
                                                         when WriteCount is 0. After the PEC register is read, both the
                                                          PEC register and this bit are cleared to 0.                          */
      __IO uint32_t  READM      :  1;               /*!< [12..12] If this bit is 1, then the ReadCount field is replaced
                                                         by the byte that is read from the SMBus when ReadCount[7:0]
                                                          is 1. After ReadCount[7:0] is updated, this bit is cleared to
                                                          0.                                                                   */
      __IO uint32_t  READ_PEC   :  1;               /*!< [13..13] If this bit is 0, reading from the SMBus stops when
                                                         ReadCount reaches 0. If this bit is 1, reading continues when
                                                          ReadCount is 0 for one more byte.                                    */
           uint32_t             :  2;
      __IO uint32_t  WRITE_COUNT:  8;               /*!< [16..23] This field is a count of the number of bytes to transmit
                                                         to the SMBus from the SMBus Master Transmit Buffer Register
                                                          It is decremented by 1 for each byte written to the SMBus from
                                                          the SMBus Master Transmit Buffer Register.                           */
      __IO uint32_t  READ_COUNT :  8;               /*!< [24..31] This field is a count of the number of bytes to read
                                                         in from the SMBus to the SMBus Master Receive Buffer Register
                                                          and must be greater than 0 in order for the Master State Machine
                                                          to initiate a read phase. It is decremented by 1 for each byte
                                                          read from the SMBus into the SMBus Master Receive Buffer Register.
                                                          It can be overwritten by the first byte read in from the SMBus.
                                                                                                                               */
    } MASTER_COMMAND_b;                             /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  SLAVE_COMMAND;                   /*!< (@ 0x40004010) SMBus Slave Command Register                           */

    struct {
      __IO uint32_t  SRUN       :  1;               /*!< [0..0] Setting this bit to 1 enables the Slave State Machine
                                                         to operate.                                                           */
      __IO uint32_t  SPROCEED   :  1;               /*!< [1..1] When this bit is 0, the Slave State Machine does not
                                                         transition out of the IDLE, REPEAT_START_WRITE or REPEAT_START_READ
                                                          states. When this bit is 1, the Slave State Machine immediately
                                                          transitions to the START_WAIT, RECEIVE and TRANSMIT states,
                                                          respectively.                                                        */
      __IO uint32_t  SLAVE_PEC  :  1;               /*!< [2..2] If Slave_WriteCount is 0 and Slave_PEC is 1 when the
                                                         Master requests data, the PEC Register is copied to the DATA
                                                          register. After the PEC Register is copied to the SMBus, the
                                                          PEC Register is cleared and Slave_PEC is set to 0.                   */
           uint32_t             :  5;
      __IO uint32_t  SLAVE_WRITECOUNT:  8;          /*!< [8..15] This field is set to the number of bytes software expects
                                                         to send to the Master.                                                */
      __IO uint32_t  SLAVE_READCOUNT:  8;           /*!< [16..23] This field is decremented each time a byte is copied
                                                         from DATA to the SMBus Slave Receive Buffer Register.                 */
    } SLAVE_COMMAND_b;                              /*!< [24] BitSize                                                          */
  };

  union {
    __IO uint32_t  PEC;                             /*!< (@ 0x40004014) Packet Error Check (PEC) Register                      */

    struct {
      __IO uint32_t  PEC        :  8;               /*!< [0..7] The SMBus Packet Error Check (PEC) byte.                       */
    } PEC_b;                                        /*!< [8] BitSize                                                           */
  };

  union {
    __IO uint32_t  REPEATED_START_HOLD_TIME;        /*!< (@ 0x40004018) Repeated Start Hold Time Register                      */

    struct {
      __IO uint32_t  RPT_START_HOLD_TIME:  8;       /*!< [0..7] This is the value of the timing requirement tHd:Sta in
                                                         the I2C specification for a repeated START bit. This is used
                                                          to hold
                                                          the clock until the Hold Time for the repeated Start Bit has
                                                          been satisfied.                                                      */
    } REPEATED_START_HOLD_TIME_b;                   /*!< [8] BitSize                                                           */
  };
  __I  uint32_t  RESERVED1;

  union {
    __IO uint32_t  COMPLETION;                      /*!< (@ 0x40004020) Completion Register                                    */

    struct {
           uint32_t             :  2;
      __IO uint32_t  DTEN       :  1;               /*!< [2..2] When DTEN is asserted ('1'), Device Time-out checking
                                                         is enabled. When DTEN is not asserted ('0'), Device Time-out
                                                          checking is disabled.                                                */
      __IO uint32_t  MCEN       :  1;               /*!< [3..3] When MCEN is asserted ('1'), Master Cumulative Time-Out
                                                         checking is enabled. When MCEN is not asserted ('0'), Master
                                                          Cumulative Time-Out checking is disabled.                            */
      __IO uint32_t  SCEN       :  1;               /*!< [4..4] When SCEN is asserted ('1'), Slave Cumulative Time-Out
                                                         checking is enabled. When SCEN is not asserted ('0'), Slave
                                                          Cumulative Time-Out checking is disabled.                            */
      __IO uint32_t  BIDEN      :  1;               /*!< [5..5] When BIDEN is asserted ('1'), Bus Idle Detect Time-Out
                                                         checking is enabled. When BIDEN is not asserted ('0'), Bus Idle
                                                          Detect Time-Out checking is disabled.                                */
      __I  uint32_t  TIMERR     :  1;               /*!< [6..6] The Time-out Error Detected bit (TIMERR) is asserted
                                                         ('1') whenever any of the enabled time-out error detect status
                                                          bits (CHDH, CHDL, SCTO, MCTO and DTO) are asserted.                  */
           uint32_t             :  1;
      __IO uint32_t  DTO        :  1;               /*!< [8..8] DTO is the Device Time-out bit. (R/WC)                         */
      __IO uint32_t  MCTO       :  1;               /*!< [9..9] MCTO is the Master Cumulative Time-out bit. (R/WC)             */
      __IO uint32_t  SCTO       :  1;               /*!< [10..10] SCTO is the Slave Cumulative Time-out bit(R/WC)              */
      __IO uint32_t  CHDL       :  1;               /*!< [11..11] CHDL is the clock high time-out detect bit(R/WC)             */
      __IO uint32_t  CHDH       :  1;               /*!< [12..12] CHDH is the bus idle time-out detect bit(R/WC)               */
      __IO uint32_t  BER        :  1;               /*!< [13..13] If this bit is 1, the BER bit in the Status register
                                                         was set while either the Slave state machine or the Master state
                                                          machine was not in the Idle state.(R/WC)                             */
      __IO uint32_t  LAB        :  1;               /*!< [14..14] If this bit is 1, the LAB bit in the Status register
                                                         was set while either the Slave state machine or the Master state
                                                          machine was not in the Idle state.(R/WC)                             */
           uint32_t             :  1;
      __IO uint32_t  SNAKR      :  1;               /*!< [16..16] If this bit is 1, the Slave state machine sent a NACK
                                                         to the transmitting Master while the Slave was receiving data
                                                          from the SMBus interface.                                            */
      __I  uint32_t  STR        :  1;               /*!< [17..17] 0: Slave has just finished the receive phase of a transaction.

                                                          1: Slave has just finished the transmit phase of a transaction.
                                                                                                                               */
           uint32_t             :  1;
      __IO uint32_t  SPROT      :  1;               /*!< [19..19] If this bit is 1, the WriteCount[7:0] counter in the
                                                         Slave state machine either counted down to 0 before the Master
                                                          sent a NACK signal, or the Slave received a NACK signal before
                                                          the counter reached 0.                                               */
      __IO uint32_t  REPEAT_READ:  1;               /*!< [20..20] If this bit is 1, the Slave State Machine stopped because
                                                         it detected a Repeat Start bit, with bit[0] of the byte containing
                                                          the slave address equal to 1, indicating that the Master requested
                                                          a Read operation.                                                    */
      __IO uint32_t  REPEAT_WRITE:  1;              /*!< [21..21] If this bit is 1, the Slave State Machine stopped because
                                                         it detected a Repeat Start bit, with bit[0] of the byte containing
                                                          the slave address equal to 0, indicating that the Master requested
                                                          a Write operation.                                                   */
           uint32_t             :  2;
      __IO uint32_t  MNAKX      :  1;               /*!< [24..24] If this bit is 1, the Master state machine received
                                                         a NACK from the receiving Slave while the Master was transmitting
                                                          data over the SMBus interface. (R/WC)                                */
      __I  uint32_t  MTR        :  1;               /*!< [25..25] 0: Master has just finished the receive phase of a
                                                         transaction.
                                                          1: Master has just finished the transmit phase of a transaction.
                                                                                                                               */
           uint32_t             :  3;
      __IO uint32_t  IDLE       :  1;               /*!< [29..29] This bit is set when the I2C bus becomes idle (on the
                                                         rising edge of nBB). (R/WC)                                           */
      __IO uint32_t  MDONE      :  1;               /*!< [30..30] If this bit is 1, Master State machine completed operation
                                                         and returned to the Idle state. It is cleared when written with
                                                          a 1. Writes of a 0 have no effect. (R/WC)                            */
      __IO uint32_t  SDONE      :  1;               /*!< [31..31] If this bit is 1, Slave State machine completed operation
                                                         and returned to the Idle state. It is cleared when written with
                                                          a 1. Writes of a 0 have no effect.(R/WC)                             */
    } COMPLETION_b;                                 /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  IDLE_SCALING;                    /*!< (@ 0x40004024) Idle Scaling Register                                  */

    struct {
      __IO uint32_t  FAIR_BUS_IDLE_MIN: 12;         /*!< [0..11] This field defines the number of ticks of the baud clock
                                                         required to satisfy the fairness protocol. The default value
                                                          for this field sets the idle window to 31us, which is the appropriate
                                                          value for a 100 KHz bus                                              */
           uint32_t             :  4;
      __IO uint32_t  FAIR_IDLE_DELAY: 12;           /*!< [16..27] This field defines the number of ticks of the baud
                                                         clock required to program the delay. The default value for this
                                                          field sets the delay period to 32us, which is the appropriate
                                                          value for a 100 KHz bus                                              */
    } IDLE_SCALING_b;                               /*!< [28] BitSize                                                          */
  };

  union {
    __IO uint32_t  CONFIGURATION;                   /*!< (@ 0x40004028) Configuration Register                                 */

    struct {
      __IO uint32_t  PORT_SEL   :  4;               /*!< [0..3] The PORT SEL [3:0] bits determine which one of 16 possible
                                                         bus ports apply to the active 2-wire SDAT and SCLK bus pair.
                                                                                                                               */
      __IO uint32_t  TCEN       :  1;               /*!< [4..4] When the Timing Check Enable bit (TCEN) is asserted ('1'),
                                                         Bus Time-Outs are enabled                                             */
      __I  uint32_t  SLOW_CLOCK :  1;               /*!< [5..5] When this bit is 1, the base period for the Bus Clock
                                                         Register is multiplied by 4, and thus the frequency is divided
                                                          by 4.                                                                */
      __IO uint32_t  TEST       :  1;               /*!< [6..6] Must be always written with 0.                                 */
      __IO uint32_t  PECEN      :  1;               /*!< [7..7] When the PEC Enable bit (PECEN) is asserted ('1'), Hardware
                                                         PEC Support is enabled                                                */
      __IO uint32_t  FEN        :  1;               /*!< [8..8] Input filtering enable. Input filtering is required by
                                                         the I2C specification if external filtering is not available.
                                                          1=Input filtering is enabled; 0=Input filtering is disabled.
                                                                                                                               */
      __IO uint32_t  RESET      :  1;               /*!< [9..9] When RESET is asserted ('1'), all logic and registers
                                                         except for the RESET bit itself are initialized to the power-on
                                                          default state.                                                       */
      __IO uint32_t  ENAB       :  1;               /*!< [10..10] When ENAB (Enable) is not asserted ('0') (default),
                                                         the SMB Controller Core is disabled and in the lowest power
                                                          consumption state (Disabled State).
                                                          The ENAB bit must be asserted ('1') for normal operation.            */
      __IO uint32_t  DSA        :  1;               /*!< [11..11] 0: Slave Address I2C Compatibility Mode (default).
                                                         1: SMBus Address Decode Mode                                          */
      __IO uint32_t  FAIR       :  1;               /*!< [12..12] If this bit is 1, the MCTP Fairness protocol is in
                                                         effect.                                                               */
      __IO uint32_t  TEST0      :  1;               /*!< [13..13] Must be always written with 0.                               */
      __I  uint32_t  GC_DIS     :  1;               /*!< [14..14] This is the General Call Disable bit.
                                                          0: the response to the General Call address as a slave is enabled
                                                          1: the response to the General Call address as a slave is disabled.
                                                                                                                               */
           uint32_t             :  1;
      __O  uint32_t  FLUSH_SXBUF:  1;               /*!< [16..16] A write of a 1 to this bit forces the SMBus Slave Transmit
                                                         Buffer Register to be marked empty. A write of 0 has no effect.
                                                          This is a self-clearing bit.                                         */
      __O  uint32_t  FLUSH_SRBUF:  1;               /*!< [17..17] A write of a 1 to this bit forces the SMBus Slave Receive
                                                         Buffer Register to be marked empty. A write of 0 has no effect.
                                                          This is a self-clearing bit.                                         */
      __O  uint32_t  FLUSH_MXBUF:  1;               /*!< [18..18] A write of a 1 to this bit forces the SMBus Master
                                                         Transmit Buffer Register to be marked empty. A write of 0 has
                                                          no effect. This is a self-clearing bit.                              */
      __O  uint32_t  FLUSH_MRBUF:  1;               /*!< [19..19] A write of a 1 to this bit forces the SMBus Master
                                                         Receive Buffer Register to be marked empty. A write of 0 has
                                                          no effect. This is a self-clearing bit.                              */
           uint32_t             :  8;
      __I  uint32_t  EN_AAS     :  1;               /*!< [28..28] 0: Disable the AAS, 1: Enable the AAS Interrupt              */
      __IO uint32_t  ENIDI      :  1;               /*!< [29..29] If this bit is 1, the Idle interrupt is enabled. If
                                                         this bit is 0, the Idle interrupt is disabled.                        */
      __IO uint32_t  ENMI       :  1;               /*!< [30..30] If this bit is 1, the Master Done interrupt is enabled.
                                                         If this bit is 0, the Master Done interrupt is disabled.              */
      __IO uint32_t  ENSI       :  1;               /*!< [31..31] If this bit is 1, the Slave Done interrupt is enabled.
                                                         If this bit is 0, the Slave Done interrupt is disabled                */
    } CONFIGURATION_b;                              /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  BUS_CLOCK;                       /*!< (@ 0x4000402C) Bus Clock Register                                     */

    struct {
      __IO uint32_t  LOW_PERIOD :  8;               /*!< [0..7] This field defines the number of I2C Baud Clock periods
                                                         that make up the low phase of the I2C/SMBus bus clock.                */
      __IO uint32_t  HIGH_PERIOD:  8;               /*!< [8..15] This field defines the number of I2C Baud Clock periods
                                                         that make up the high phase of the I2C/SMBus bus clock.               */
    } BUS_CLOCK_b;                                  /*!< [16] BitSize                                                          */
  };

  union {
    __I  uint8_t   BLOCK_ID;                        /*!< (@ 0x40004030) Block ID Register                                      */

    struct {
      __IO uint8_t   ID         :  8;               /*!< [0..7] Block ID.                                                      */
    } BLOCK_ID_b;                                   /*!< [8] BitSize                                                           */
  };
  __I  uint8_t   RESERVED2[3];

  union {
    __I  uint8_t   REVISION;                        /*!< (@ 0x40004034) Revision Register                                      */

    struct {
      __IO uint8_t   REVISION   :  8;               /*!< [0..7] Block Revision Number                                          */
    } REVISION_b;                                   /*!< [8] BitSize                                                           */
  };
  __I  uint8_t   RESERVED3[3];

  union {
    __IO uint32_t  BIT_BANG_CONTROL;                /*!< (@ 0x40004038) Bit-Bang Control Register                              */

    struct {
      __IO uint32_t  BBEN       :  1;               /*!< [0..0] Bit-Bang Mode Enable. 0 - Bit Bang Mode Disabled. 1 -
                                                         Bit Bang Mode Enabled                                                 */
      __IO uint32_t  CLDIR      :  1;               /*!< [1..1] Bit-Bang Clock Direction. The CLDIR bit controls the
                                                         direction of SCLK. 0 - Input, 1 - Output                              */
      __IO uint32_t  DADIR      :  1;               /*!< [2..2] Bit-Bang Data Direction. The DADIR bit controls the direction
                                                         of SDAT. 0 - Input. 1 - Output                                        */
      __IO uint32_t  BBCLK      :  1;               /*!< [3..3] Bit-Bang Clock. The BBCLK bit controls the state of SCLK
                                                         when BBEN = and CLDIR = '1'                                           */
      __IO uint32_t  BBDAT      :  1;               /*!< [4..4] Bit-Bang Data. The BBDAT bit controls the state of SDAT
                                                         when BBEN = and DADIR = '1'                                           */
      __I  uint32_t  BBCLKI     :  1;               /*!< [5..5] Bit-Bang Clock In. The BBCLKI bit always returns the
                                                         state of SCLK.                                                        */
      __I  uint32_t  BBDATI     :  1;               /*!< [6..6] Bit-Bang Data In. The BBDATI bit always returns the state
                                                         of SDAT                                                               */
    } BIT_BANG_CONTROL_b;                           /*!< [7] BitSize                                                           */
  };

  union {
    __I  uint8_t   TEST;                            /*!< (@ 0x4000403C) Test                                                   */

    struct {
      __IO uint8_t   TEST       :  8;               /*!< [0..7] This register must not be written, or undesirable results
                                                         may occur.                                                            */
    } TEST_b;                                       /*!< [8] BitSize                                                           */
  };
  __I  uint8_t   RESERVED4[3];

  union {
    __IO uint32_t  DATA_TIMING;                     /*!< (@ 0x40004040) Data Timing Register                                   */

    struct {
      __IO uint32_t  DATA_HOLD  :  8;               /*!< [0..7] The Data Hold [7:0] timer determines the SDAT hold time
                                                         following SCLK driven low.                                            */
      __IO uint32_t  RESTART_SETUP:  8;             /*!< [8..15] The Restart Setup [7:0] timer determines the SDAT setup
                                                         time from the rising edge of SCLK for a repeated START condition.
                                                                                                                               */
      __IO uint32_t  STOP_SETUP :  8;               /*!< [16..23] The Stop Setup [7:0] timer determines the SDAT setup
                                                         time from the rising edge of SCLK for a STOP condition.               */
      __IO uint32_t  FIRST_START_HOLD:  8;          /*!< [24..31] This field determines the SCL hold time following SDA
                                                         driven low during the first START bit in a transfer. It is the
                                                          parameter
                                                          THD:STA in the I2C Specification for an initial START bit.
                                                          Repeated START hold time is determined by the Repeated START
                                                          Hold Time Register.                                                  */
    } DATA_TIMING_b;                                /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  TIME_OUT_SCALING;                /*!< (@ 0x40004044) Time-Out Scaling Register                              */

    struct {
      __IO uint32_t  CLOCK_HIGH_TIME_OUT:  8;       /*!< [0..7] Clock High time out period = Clock High Time-Out [7:0]
                                                         x Baud_Clock_Period x 2                                               */
      __IO uint32_t  SLAVE_CUM_TIME_OUT:  8;        /*!< [8..15] Slave Cumulative Time-Out duration = Slave Cum Time-Out
                                                         [7:0] x Baud_Clock_Period x 1024                                      */
      __IO uint32_t  MASTER_CUM_TIME_OUT:  8;       /*!< [16..23] Master Cumulative Time-Out duration = Master Cum Time-Out
                                                         [7:0] x Baud_Clock_Period x 512                                       */
      __IO uint32_t  BUS_IDLE_MIN:  8;              /*!< [24..31] Bus Idle Minimum time = Bus Idle Min [7:0] x Baud_Clock_Period
                                                                                                                               */
    } TIME_OUT_SCALING_b;                           /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  SLAVE_TRANSMIT_BUFFER;           /*!< (@ 0x40004048) SMBus Slave Transmit Buffer Register                   */

    struct {
      __IO uint32_t  SLAVE_TRANSMIT_BUFFER:  8;     /*!< [0..7] SLAVE_TRANSMIT_BUFFER                                          */
    } SLAVE_TRANSMIT_BUFFER_b;                      /*!< [8] BitSize                                                           */
  };

  union {
    __IO uint32_t  SLAVE_RECEIVE_BUFFER;            /*!< (@ 0x4000404C) SMBus Slave Receive Buffer Register                    */

    struct {
      __IO uint32_t  SLAVE_RECEIVE_BUFFER:  8;      /*!< [0..7] SLAVE_RECEIVE_BUFFER                                           */
    } SLAVE_RECEIVE_BUFFER_b;                       /*!< [8] BitSize                                                           */
  };

  union {
    __IO uint32_t  MASTER_TRANSMIT_BUFER;           /*!< (@ 0x40004050) SMBus Master Transmit Buffer Register                  */

    struct {
      __IO uint32_t  MASTER_TRANSMIT_BUFFER:  8;    /*!< [0..7] MASTER_TRANSMIT_BUFFER                                         */
    } MASTER_TRANSMIT_BUFER_b;                      /*!< [8] BitSize                                                           */
  };

  union {
    __IO uint32_t  MASTER_RECEIVE_BUFFER;           /*!< (@ 0x40004054) SMBus Master Receive Buffer Register                   */

    struct {
      __IO uint32_t  MASTER_RECEIVE_BUFFER:  8;     /*!< [0..7] MASTER_RECEIVE_BUFFER                                          */
    } MASTER_RECEIVE_BUFFER_b;                      /*!< [8] BitSize                                                           */
  };
  __I  uint32_t  RESERVED5[2];

  union {
    __IO uint32_t  WAKE_STATUS;                     /*!< (@ 0x40004060) WAKE STATUS Register                                   */

    struct {
      __IO uint32_t  START_BIT_DETECTION:  1;       /*!< [0..0] This bit is set to '1' when a START bit is detected while
                                                         the controller is enabled. This bit is cleared to '0' when
                                                          written with a '1'. Writes of '0' have no effect. (R/WC)             */
    } WAKE_STATUS_b;                                /*!< [1] BitSize                                                           */
  };

  union {
    __IO uint32_t  WAKE_ENABLE;                     /*!< (@ 0x40004064) WAKE ENABLE Register                                   */

    struct {
      __IO uint32_t  START_DETECT_INT_EN:  1;       /*!< [0..0] Enable Start Bit Detection Interrupt. The Start Bit Detection
                                                         Interrupt is wake-capable.
                                                          1=Start Bit Detection Interrupt enabled; 0=Start Bit Detection
                                                          Interrupt disabled                                                   */
    } WAKE_ENABLE_b;                                /*!< [1] BitSize                                                           */
  };
} SMB0_INST_Type;


/* ================================================================================ */
/* ================                  GP_SPI0_INST                  ================ */
/* ================================================================================ */


/**
  * @brief The General Purpose Serial Peripheral Interface (GP-SPI) may be used
 to communicate with various peripheral devices, e.g., EEPROMS, DACs, ADCs, that use a
 standard Serial Peripheral Interface.  (GP_SPI0_INST)
  */

typedef struct {                                    /*!< (@ 0x40009400) GP_SPI0_INST Structure                                 */
  __IO uint32_t  ENABLE;                            /*!< (@ 0x40009400) [0:0] 1=Enabled. The device is fully operational
                                                          0=Disabled. Clocks are gated to conserve power and the SPDOUT
                                                         and SPI_CLK signals are set to their inactive state                   */

  union {
    __IO uint32_t  CONTROL;                         /*!< (@ 0x40009404) SPI Control                                            */

    struct {
      __IO uint32_t  LSBF       :  1;               /*!< [0..0] Least Significant Bit First
                                                          1= The data is transferred in LSB-first order.
                                                          0= The data is transferred in MSB-first order. (default)             */
      __IO uint32_t  BIOEN      :  1;               /*!< [1..1] Bidirectional Output Enable control.
                                                          1=The SPDOUT_Direction signal configures the SPDOUT signal
                                                         as an output.
                                                          0=The SPDOUT_Direction signal configures the SPDOUT signal
                                                          as an input.                                                         */
      __IO uint32_t  SPDIN_SELECT:  2;              /*!< [2..3] [3:2] 1xb=SPDIN1 and SPDIN2. Select this option for Dual
                                                         Mode
                                                          [3:2] 01b=SPDIN2 only. Select this option for Half Duplex
                                                          [3:2] 00b=SPDIN1 only. Select this option for Full Duplex            */
      __IO uint32_t  SOFT_RESET :  1;               /*!< [4..4] Soft Reset is a self-clearing bit. Writing zero to this
                                                         bit has no effect. Writing a one to this bit resets the entire
                                                          SPI Interface, including all counters and registers back to
                                                          their initial state.                                                 */
      __IO uint32_t  AUTO_READ  :  1;               /*!< [5..5] Auto Read Enable.
                                                          1=A read of the SPI RX_DATA Register will clear both the RXBF
                                                         status bit and the TXBE status bit
                                                          0=A read of the SPI RX_DATA Register will clear the RXBF status
                                                          bit. The TXBE status bit will not be modified                        */
      __IO uint32_t  CE         :  1;               /*!< [6..6] SPI Chip Select Enable.
                                                          1= SPI_CS# output signal is asserted, i.e., driven to logic
                                                         '0'
                                                          0= SPI_CS# output signal is deasserted, i.e., driven to logic
                                                          '1'                                                                  */
    } CONTROL_b;                                    /*!< [7] BitSize                                                           */
  };

  union {
    __I  uint32_t  STATUS;                          /*!< (@ 0x40009408) SPI Status                                             */

    struct {
      __I  uint32_t  TXBE       :  1;               /*!< [0..0] 1=TX_Data buffer is empty, 0=TX_Data buffer is not empty
                                                                                                                               */
      __I  uint32_t  RXBF       :  1;               /*!< [1..1] 1=RX_Data buffer is full, 0=RX_Data buffer is not full
                                                                                                                               */
      __I  uint32_t  ACTIVE     :  1;               /*!< [2..2] ACTIVE status                                                  */
    } STATUS_b;                                     /*!< [3] BitSize                                                           */
  };
  __IO uint32_t  TX_DATA;                           /*!< (@ 0x4000940C) [7:0] A write to this register when the Tx_Data
                                                         buffer is empty (TXBE in the SPI Status Register is '1') initiates
                                                          a SPI transaction.                                                   */
  __IO uint32_t  RX_DATA;                           /*!< (@ 0x40009410) [7:0] This register is used to read the value
                                                         returned by the external SPI device.                                  */

  union {
    __IO uint32_t  CLOCK_Control;                   /*!< (@ 0x40009414) SPI Clock Control. This register should not be
                                                         changed during an active SPI transaction.                             */

    struct {
      __IO uint32_t  TCLKPH     :  1;               /*!< [0..0] 1=Valid data is clocked out on the first SPI_CLK edge
                                                         on SPDOUT signal. The slave device should sample this data on
                                                          the second and following even SPI_CLK edges (i.e., sample data
                                                          on falling edge)
                                                          0=Valid data is clocked out on the SPDOUT signal prior to the
                                                          first SPI_CLK edge. The slave device should sample this data
                                                          on the first and following odd SPI_CLK edges (i.e., sample data
                                                          on rising edge)                                                      */
      __IO uint32_t  RCLKPH     :  1;               /*!< [1..1] 1=Valid data on SPDIN signal is expected after the first
                                                         SPI_CLK edge. This data is sampled on the second and following
                                                          even SPI_CLK edges (i.e., sample data on falling edge)
                                                          0=Valid data is expected on the SPDIN signal on the first SPI_CLK
                                                          edge. This data is sampled on the first and following odd SPI_-CLK
                                                          edges (i.e., sample data on rising edge)                             */
      __IO uint32_t  CLKPOL     :  1;               /*!< [2..2] 1=The SPI_CLK signal is high when the interface is idle
                                                         and the first clock edge is a falling edge
                                                          0=The SPI_CLK is low when the interface is idle and the first
                                                          clock edge is a rising edge                                          */
           uint32_t             :  1;
      __IO uint32_t  CLKSRC     :  1;               /*!< [4..4] 1=2MHz, 0=48 MHz Ring Oscillator                               */
    } CLOCK_Control_b;                              /*!< [5] BitSize                                                           */
  };
  __IO uint32_t  CLOCK_GENERATOR;                   /*!< (@ 0x40009418) [5:0] PRELOAD SPI Clock Generator Preload value.
                                                                                                                               */
} GP_SPI0_INST_Type;


/* ================================================================================ */
/* ================                   QMSPI_INST                   ================ */
/* ================================================================================ */


/**
  * @brief The Quad SPI Master Controller may be used to communicate with various
 peripheral devices that use a Serial Peripheral Interface, such as EEPROMS, DACs and ADCs.
 The controller can be configured to support advanced SPI Flash devices with multi-phase access protocols.  (QMSPI_INST)
  */

typedef struct {                                    /*!< (@ 0x40005400) QMSPI_INST Structure                                   */

  union {
    __IO uint32_t  QMSPI_MODE;                      /*!< (@ 0x40005400) QMSPI Mode Register                                    */

    struct {
      __IO uint32_t  ACTIVATE   :  1;               /*!< [0..0] This bit is used to activate the QMSPI block.
                                                         1=Enabled. The block is fully operational
                                                          0=Disabled. Clocks are gated to conserve power and the output
                                                         signals are set to their inactive state.                              */
      __O  uint32_t  SOFT_RESET :  1;               /*!< [1..1] Writing this bit with a 1 will reset the Quad SPI block.
                                                         It is self-clearing.                                                  */
           uint32_t             :  6;
      __IO uint32_t  CPOL       :  1;               /*!< [8..8] Polarity of the SPI clock line when there are no transactions
                                                         in process. 1=SPI Clock starts High; 0=SPI Clock starts Low.
                                                                                                                               */
      __IO uint32_t  CHPA_MOSI  :  1;               /*!< [9..9] Clock phase of the Master data out. Common SPI modes
                                                         require this field to be programmed with the same value as CHPA_MISO
                                                          in this register.
                                                         e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1;
                                                          CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings.
                                                          If CPOL=1: 1=Data changes on the falling edge of the SPI clock;
                                                          0=Data changes on the rising edge of the SPI clock
                                                          If CPOL=0: 1=Data changes on the rising edge of the SPI clock;
                                                          0=Data changes on the falling edge of the SPI clock                  */
      __IO uint32_t  CHPA_MISO  :  1;               /*!< [10..10] Clock phase of the Master data in. Common SPI modes
                                                         require this field to be programmed with the same value as CHPA_MOSI
                                                          in this register.
                                                         e.g. Mode 0: CPOL=0; CHPA_MISO=0; CHPA_MOSI=0; Mode 3: CPOL=1;
                                                          CHPA_MISO=1; CHPA_MOSI=1. See datasheet for alternate mode settings.
                                                          If CPOL=1: 1=Data are captured on the rising edge of the SPI
                                                          clock; 0=Data are captured on the falling edge of the SPI clock
                                                          If CPOL=0: 1=Data are captured on the falling edge of the SPI
                                                          clock; 0=Data are captured on the rising edge of th                  */
           uint32_t             :  5;
      __IO uint32_t  CLOCK_DIVIDE:  9;              /*!< [16..24] The SPI clock divide in number of system clocks. A
                                                         value of 1 divides the master clock by 1, a value of 255 divides
                                                          the master clock by 255. A value of 0 divides the master clock
                                                          by 256.                                                              */
    } QMSPI_MODE_b;                                 /*!< [25] BitSize                                                          */
  };

  union {
    __IO uint32_t  QMSPI_CONTROL;                   /*!< (@ 0x40005404) QMSPI SPI Control                                      */

    struct {
      __IO uint32_t  INTERFACE_MODE:  2;            /*!< [0..1] This field sets the transmission mode. If this field
                                                         is set for Dual Mode or Quad Mode then either
                                                         TX_TRANSFER_ENABLE or RX_TRANSFER_ENABLE must be 0.
                                                          3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode.
                                                                                                                               */
      __IO uint32_t  TX_TRANSFER_ENABLE:  2;        /*!< [2..3] This field bit selects the transmit function of the SPI
                                                         interface.
                                                          3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send
                                                          out only 1's. The Transmit Buffer will not be used.
                                                          2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send
                                                          out only 0's. The Transmit Buffer will not be used.
                                                          1=Transmit Enabled. Data will be fetched from the Transmit
                                                          Buffer and sent out on the MOSI or IO Bus.
                                                          0=Transmit is Disabled. Not data is sent. This will cause the
                                                          MOSI be to be undriven, or the IO bus to be undriven i               */
      __IO uint32_t  TX_DMA_ENABLE:  2;             /*!< [4..5] This bit enables DMA support for Transmit Transfer. If
                                                         enabled, DMA will be requested to fill the FIFO until either
                                                         the interface reaches TRANSFER_LENGTH or the DMA sends a termination
                                                          request. The size defined here must match DMA programmed access
                                                          size.
                                                         1=DMA is enabled.and set to 1 Byte
                                                          2=DMA is enabled and set to 2 Bytes
                                                          3=DMA is enabled and set to 4 Bytes.
                                                         0=DMA is disabled. All data in the Transmit Buffer must be emptied
                                                          by firmware                                                          */
      __IO uint32_t  RX_TRANSFER_ENABLE:  1;        /*!< [6..6] This bit enables the receive function of the SPI interface.
                                                          1=Receive is enabled. Data received from the SPI Slave is stored
                                                         in the Receive Buffer
                                                          0=Receive is disabled                                                */
      __IO uint32_t  RX_DMA_ENABLE:  2;             /*!< [7..8] This bit enables DMA support for Receive Transfer. If
                                                         enabled, DMA will be requested to empty the FIFO until either
                                                          the interface
                                                          reaches TRANSFER_LENGTH or the DMA sends a termination request.
                                                          The size defined here must match DMA programmed access size.
                                                          1=DMA is enabled.and set to 1 Byte
                                                          2=DMA is enabled and set to 2 Bytes
                                                          3=DMA is enabled and set to 4 Bytes
                                                          0=DMA is disabled. All data in the Receive Buffer must be emptied
                                                          by firmware                                                          */
      __IO uint32_t  CLOSE_TRANSFER_ENABLE:  1;     /*!< [9..9] This selects what action is taken at the end of a transfer.
                                                         When the transaction closes, the Chip Select de-asserts, the
                                                          SPI
                                                         interface returns to IDLE and the DMA interface terminates When
                                                          Description Buffers are in use this bit must be set only on
                                                          the Last Buffer.
                                                         1=The transaction is terminated
                                                         0=The transaction is not terminated                                   */
      __IO uint32_t  TRANSFER_UNITS:  2;            /*!< [10..11] 3=TRANSFER_LENGTH defined in units of 16-byte segments
                                                         2=TRANSFER_LENGTH defined in units of 4-byte segments
                                                         1=TRANSFER_LENGTH defined in units of bytes
                                                         0=TRANSFER_LENGTH defined in units of bits.                           */
      __IO uint32_t  DESCRIPTION_BUFFER_POINTER:  4;/*!< [12..15] This field selects the first buffer used if Description
                                                         Buffers are enabled.                                                  */
      __IO uint32_t  DESCRIPTION_BUFFER_ENABLE:  1; /*!< [16..16] This enables the Description Buffers to be used.
                                                         1=Description Buffers in use. The first buffer is defined in
                                                         DESCRIPTION_BUFFER_POINTER
                                                         0=Description Buffers disabled.                                       */
      __IO uint32_t  TRANSFER_LENGTH: 15;           /*!< [17..31] The length of the SPI transfer. The count is in bytes
                                                         or bits, depending on the value of TRANSFER_LENGTH_BITS.
                                                         A value of 0 means an infinite length transfer.                       */
    } QMSPI_CONTROL_b;                              /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  QMSPI_EXECUTE;                   /*!< (@ 0x40005408) QMSPI Execute Register                                 */

    struct {
      __O  uint32_t  START      :  1;               /*!< [0..0] Writing a 1 to this bit will start the SPI transfer.
                                                         Writing a 0 to this bit has no effect. This bit is self-clearing.
                                                         This bit must not be set to 1 if the field STOP in this register
                                                          is set to 1.                                                         */
      __O  uint32_t  STOP       :  1;               /*!< [1..1] Writing a 1 to this bit will stop any transfer in progress
                                                         at the next byte boundary. Writing a 0 to this bit has no effect.
                                                         This bit is self clearing. This bit must not be set to 1 if
                                                          the field START in this register is set to 1.                        */
      __O  uint32_t  CLEAR_DATA_BUFFER:  1;         /*!< [2..2] Writing a 1 to this bit will clear out the Transmit and
                                                         Receive FIFOs. Any data stored in the FIFOs is discarded and
                                                          all count fields are reset.
                                                         Writing a 0 to this bit has no effect. This bit is self clearing.
                                                                                                                               */
    } QMSPI_EXECUTE_b;                              /*!< [3] BitSize                                                           */
  };

  union {
    __IO uint32_t  QMSPI_INTERFACE_CONTROL;         /*!< (@ 0x4000540C) QMSPI Interface Control Register                       */

    struct {
      __IO uint32_t  WRITE_PROTECT_OUT_VALUE:  1;   /*!< [0..0] This bit sets the value on the WRITE PROTECT SPI Output
                                                         Port if it is driven.
                                                          1=WRITE PROTECT is driven to 1; 0=WRITE PROTECT is driven to
                                                          0                                                                    */
      __IO uint32_t  WRITE_PROTECT_OUT_ENABLE:  1;  /*!< [1..1] 1=WRITE PROTECT SPI Output Port is driven
                                                          0=WRITE PROTECT SPI Output Port is not driven                        */
      __IO uint32_t  HOLD_OUT_VALUE:  1;            /*!< [2..2] This bit sets the value on the HOLD SPI Output Port if
                                                         it is driven.
                                                          1=HOLD is driven to 1; 0=HOLD is driven to 0.                        */
      __IO uint32_t  HOLD_OUT_ENABLE:  1;           /*!< [3..3] 1=HOLD SPI Output Port is driven
                                                          0=HOLD SPI Output Port is not driven.                                */
      __IO uint32_t  PULLDOWN_ON_NOT_SELECTED:  1;  /*!< [4..4] 1=Enable pull-down resistors on Receive pins while the
                                                         SPI Chip Select signal is not asserted
                                                         0=No pull-down resistors enabled on Receive pins                      */
      __IO uint32_t  PULLUP_ON_NOT_SELECTED:  1;    /*!< [5..5] 1=Enable pull-up resistors on Receive pins while the
                                                         SPI Chip Select signal is not asserted
                                                         0=No pull-up resistors enabled on Receive pins.                       */
      __IO uint32_t  PULLDOWN_ON_NOT_DRIVEN:  1;    /*!< [6..6] 1=Enable pull-down resistors on Transmit pins while the
                                                         pins are not driven
                                                         0=No pull-down resistors enabled ion Transmit pins.                   */
      __IO uint32_t  PULLUP_ON_NOT_DRIVEN:  1;      /*!< [7..7] 1=Enable pull-up resistors on Transmit pins while the
                                                         pins are not driven
                                                         0=No pull-up resistors enabled ion Transmit pins.                     */
    } QMSPI_INTERFACE_CONTROL_b;                    /*!< [8] BitSize                                                           */
  };

  union {
    __IO uint32_t  QMSPI_STATUS;                    /*!< (@ 0x40005410) QMSPI Status Register                                  */

    struct {
      __IO uint32_t  TRANSFER_COMPLETE:  1;         /*!< [0..0] In Manual Mode (neither DMA nor Description Buffers are
                                                         enabled), this bit will be set to 1 when the transfer matches
                                                          TRANSFER_LENGTH.
                                                          If DMA Mode is enabled, this bit will be set to 1 when DMA_COMPLETE
                                                          is set to 1. In Description Buffer Mode, this bit will be set
                                                          to 1 only when the Last Buffer completes its transfer.
                                                         In all cases, this bit will be set to 1 if the STOP bit is set
                                                          to 1 and the controller has completed the current 8 bits being
                                                          copied.
                                                          1=Transfer completed; 0=Transfer not complete.                       */
      __IO uint32_t  DMA_COMPLETE:  1;              /*!< [1..1] This field has no meaning if DMA is not enabled. This
                                                         bit will be set to 1 when the DMA controller asserts the DONE
                                                          signal to the SPI controller.
                                                         This occurs either when the SPI controller has closed the DMA
                                                          transfer, or the DMA channel has completed its count. If both
                                                          Transmit and Receive DMA transfers are
                                                          active, then this bit will only assert after both have completed.
                                                          If CLOSE_TRANSFER_ENABLE is enabled, DMA_COMPLETE and TRANSFER_COMPLETE
                                                          will be asserted simultaneously.
                                                         This status is not inhibited b                                        */
      __IO uint32_t  TRANSMIT_BUFFER_ERROR:  1;     /*!< [2..2] 1=Overflow error occurred (attempt to write to a full
                                                         Transmit Buffer)
                                                          0=No overflow occurred.                                              */
      __IO uint32_t  RECEIVE_BUFFER_ERROR:  1;      /*!< [3..3] 1=Underflow error occurred (attempt to read from an empty
                                                         Receive Buffer)
                                                          0=No underflow occurred.                                             */
      __IO uint32_t  PROGRAMMING_ERROR:  1;         /*!< [4..4] This bit if a programming error is detected.
                                                         1=Programming Error detected; 0=No programming error detected.
                                                                                                                               */
           uint32_t             :  3;
      __I  uint32_t  TRANSMIT_BUFFER_FULL:  1;      /*!< [8..8] 1=The Transmit Buffer is full
                                                         0=The Transmit Buffer is not full.                                    */
      __I  uint32_t  TRANSMIT_BUFFER_EMPTY:  1;     /*!< [9..9] 1=The Transmit Buffer is empty
                                                         0=The Transmit Buffer is not empty.                                   */
      __IO uint32_t  TRANSMIT_BUFFER_REQUEST:  1;   /*!< [10..10] This status is asserted if the Transmit Buffer reaches
                                                         a high water mark established by the TRANSMIT_BUFFER_TRIGGER
                                                          field.
                                                         1=TRANSMIT_BUFFER_COUNT is less than or equal to TRANSMIT_BUFFER_TRIGGER;
                                                          0=TRANSMIT_BUFFER_COUNT is greater than TRANSMIT_BUFFER_TRIGGER.
                                                                                                                               */
      __IO uint32_t  TRANSMIT_BUFFER_STALL:  1;     /*!< [11..11] 1=The SPI interface had been stalled due to a flow
                                                         issue (an attempt by the interface to read from an empty Transmit
                                                          Buffer)
                                                         0=No stalls occurred.                                                 */
      __I  uint32_t  RECEIVE_BUFFER_FULL:  1;       /*!< [12..12] 1=The Receive Buffer is full
                                                         0=The Receive Buffer is not full.                                     */
      __I  uint32_t  RECEIVE_BUFFER_EMPTY:  1;      /*!< [13..13] 1=The Receive Buffer is empty
                                                         0=The Receive Buffer is not empty.                                    */
      __IO uint32_t  RECEIVE_BUFFER_REQUEST:  1;    /*!< [14..14] This status is asserted if the Receive Buffer reaches
                                                         a high water mark established by the RECEIVE_BUFFER_TRIGGER
                                                          field.
                                                          1=RECEIVE_BUFFER_COUNT is greater than or equal to RECEIVE_BUFFER_TRIGGER
                                                          0=RECEIVE_BUFFER_COUNT is less than RECEIVE_BUFFER_TRIGGER.
                                                                                                                               */
      __IO uint32_t  RECEIVE_BUFFER_STALL:  1;      /*!< [15..15] 1=The SPI interface had been stalled due to a flow
                                                         issue (an attempt by the interface to write to a full Receive
                                                          Buffer)
                                                         0=No stalls occurred.                                                 */
      __I  uint32_t  TRANSFER_ACTIVE:  1;           /*!< [16..16] 1=A transfer is currently executing
                                                         0=No transfer currently in progress.                                  */
           uint32_t             :  7;
      __I  uint32_t  CURRENT_DESCRIPTION_BUFFER:  4;/*!< [24..27] This field shows the Description Buffer currently active.
                                                         This field has no meaning if Description Buffers are not enabled.
                                                                                                                               */
    } QMSPI_STATUS_b;                               /*!< [28] BitSize                                                          */
  };

  union {
    __IO uint32_t  QMSPI_BUFFER_COUNT_STATUS;       /*!< (@ 0x40005414) QMSPI Buffer Count Status Register                     */

    struct {
      __IO uint32_t  TRANSMIT_BUFFER_COUNT: 16;     /*!< [0..15] This is a count of the number of bytes currently valid
                                                         in the Transmit Buffer.                                               */
      __IO uint32_t  RECEIVE_BUFFER_COUNT: 16;      /*!< [16..31] This is a count of the number of bytes currently valid
                                                         in the Receive Buffer.                                                */
    } QMSPI_BUFFER_COUNT_STATUS_b;                  /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  QMSPI_INTERRUPT_ENABLE;          /*!< (@ 0x40005418) QMSPI Interrupt Enable Register                        */

    struct {
      __IO uint32_t  TRANSFER_COMPLETE_ENABLE:  1;  /*!< [0..0] 1=Enable an interrupt if TRANSFER_COMPLETE is asserted
                                                         0=Disable the interrupt.                                              */
      __IO uint32_t  DMA_COMPLETE_ENABLE:  1;       /*!< [1..1] 1=Enable an interrupt if DMA_COMPLETE is asserted
                                                         0=Disable the interrupt.                                              */
      __IO uint32_t  TRANSMIT_BUFFER_ERROR_ENABLE:  1;/*!< [2..2] 1=Enable an interrupt if TRANSMIT_BUFFER_ERROR is asserted
                                                         0=Disable the interrupt.                                              */
      __IO uint32_t  RECEIVE_BUFFER_ERROR_ENABLE:  1;/*!< [3..3] 1=Enable an interrupt if RECEIVE_BUFFER_ERROR is asserted
                                                         0=Disable the interrupt.                                              */
      __IO uint32_t  PROGRAMMING_ERROR_ENABLE:  1;  /*!< [4..4] 1=Enable an interrupt if PROGRAMMING_ERROR is asserted
                                                         0=Disable the interrupt.                                              */
           uint32_t             :  3;
      __I  uint32_t  TRANSMIT_BUFFER_FULL_ENABLE:  1;/*!< [8..8] 1=Enable an interrupt if TRANSMIT_BUFFER_FULL is asserted
                                                         0=Disable the interrupt.                                              */
      __I  uint32_t  TRANSMIT_BUFFER_EMPTY_ENABLE:  1;/*!< [9..9] 1=Enable an interrupt if TRANSMIT_BUFFER_EMPTY is asserted
                                                         0=Disable the interrupt.                                              */
      __IO uint32_t  TRANSMIT_BUFFER_REQUEST_ENABLE:  1;/*!< [10..10] 1=Enable an interrupt if TRANSMIT_BUFFER_REQUEST is
                                                         asserted
                                                         0=Disable the interrupt.                                              */
           uint32_t             :  1;
      __I  uint32_t  RECEIVE_BUFFER_FULL_ENABLE:  1;/*!< [12..12] 1=Enable an interrupt if RECEIVE_BUFFER_FULL is asserted
                                                         0=Disable the interrupt.                                              */
      __I  uint32_t  RECEIVE_BUFFER_EMPTY_ENABLE:  1;/*!< [13..13] 1=Enable an interrupt if RECEIVE_BUFFER_EMPTY is asserted
                                                         0=Disable the interrupt.                                              */
      __IO uint32_t  RECEIVE_BUFFER_REQUEST_ENABLE:  1;/*!< [14..14] 1=Enable an interrupt if RECEIVE_BUFFER_REQUEST is
                                                         asserted
                                                         0=Disable the interrupt.                                              */
    } QMSPI_INTERRUPT_ENABLE_b;                     /*!< [15] BitSize                                                          */
  };

  union {
    __IO uint32_t  QMSPI_BUFFER_COUNT_TRIGGER;      /*!< (@ 0x4000541C) QMSPI Buffer Count Trigger Register                    */

    struct {
      __IO uint32_t  TRANSMIT_BUFFER_TRIGGER: 16;   /*!< [0..15] An interrupt is triggered if the TRANSMIT_BUFFER_COUNT
                                                         field is less than or equal to this value. A value of 0 disables
                                                          the interrupt.                                                       */
      __IO uint32_t  RECEIVE_BUFFER_TRIGGER: 16;    /*!< [16..31] An interrupt is triggered if the RECEIVE_BUFFER_COUNT
                                                         field is greater than or equal to this value. A value of 0 disables
                                                          the interrupt.                                                       */
    } QMSPI_BUFFER_COUNT_TRIGGER_b;                 /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  QMSPI_TRAMSMIT_BUFFER;           /*!< (@ 0x40005420) QMSPI Transmit Buffer Register                         */

    struct {
      __O  uint32_t  TRANSMIT_BUFFER: 32;           /*!< [0..31] Writes to this register store data to be transmitted
                                                         from the SPI Master to the external SPI Slave.
                                                         Writes to this block will be written to the Transmit FIFO. A
                                                          1 Byte write fills 1 byte of the FIFO. A Word write fills 2
                                                          Bytes and a Doubleword write fills 4 bytes.
                                                         The data must always be aligned to the bottom most byte (so
                                                          1 byte write is on bits [7:0] and Word write is on [15:0]).
                                                         An overflow condition, TRANSMIT_BUFFER_ERROR, if a write to
                                                          a full FIFO occurs. Write accesses to this register increment
                                                          the                                                                  */
    } QMSPI_TRAMSMIT_BUFFER_b;                      /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  QMSPI_RECEIVE_BUFFER;            /*!< (@ 0x40005424) QMSPI Receive Buffer Register                          */

    struct {
      __I  uint32_t  RECEIVE_BUFFER: 32;            /*!< [0..31] Buffer that stores data from the external SPI Slave
                                                         device to the SPI Master (this block), which is received over
                                                          MISO or IO.
                                                         Reads from this register will empty the Rx FIFO. A 1 Byte read
                                                          will have valid data on bits [7:0] and a Word read will have
                                                          data on bits [15:0].
                                                         It is possible to request more data than the FIFO has (underflow
                                                          condition), but this will cause an error (Rx Buffer Error).
                                                         Read accesses to this register decrement the RECEIVE_BUFFER_COUNT
                                                          field.                                                               */
    } QMSPI_RECEIVE_BUFFER_b;                       /*!< [32] BitSize                                                          */
  };
  __I  uint32_t  RESERVED[2];

  union {
    __IO uint32_t  QMSPI_DESCRIPTION_BUFFER_0;      /*!< (@ 0x40005430) QMSPI Description Buffer 0 Register                    */

    struct {
      __IO uint32_t  INTERFACE_MODE:  2;            /*!< [0..1] This field sets the transmission mode. If this field
                                                         is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE
                                                          or RX_TRANSFER_ENABLE must be 0.
                                                         3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode.
                                                                                                                               */
      __IO uint32_t  TX_TRANSFER_ENABLE:  2;        /*!< [2..3] This field bit selects the transmit function of the SPI
                                                         interface.
                                                         3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out
                                                          only 1's. The Transmit Buffer will not be used
                                                         2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out
                                                          only 0's. The Transmit Buffer will not be used.
                                                         1=Transmit Enabled. Data will be fetched from the Transmit Buffer
                                                          and sent out on the MOSI or IO Bus.
                                                         0=Transmit is Disabled. No data is sent. This will cause the
                                                          MOSI be to be undriven, or the IO bus to be undriven if Rece         */
      __IO uint32_t  TX_DMA_ENABLE:  2;             /*!< [4..5] This bit enables DMA support for Transmit Transfer. If
                                                         enabled, DMA will be requested to fill the FIFO until either
                                                          the interface
                                                         reaches TRANSFER_LENGTH or the DMA sends a termination request.
                                                          The size defined here must match DMA programmed access size.
                                                         1=DMA is enabled.and set to 1 Byte
                                                          2=DMA is enabled and set to 2 Bytes
                                                          3=DMA is enabled and set to 4 Bytes0=DMA is disabled. All data
                                                          in the Transmit Buffer must be emptied by firmware.                  */
      __IO uint32_t  RX_TRANSFER_ENABLE:  1;        /*!< [6..6] This bit enables the receive function of the SPI interface.
                                                         1=Receive is enabled. Data received from the SPI Slave is stored
                                                         in the Receive Buffer; 0=Receive is disabled.                         */
      __I  uint32_t  RX_DMA_ENABLE:  2;             /*!< [7..8] This bit enables DMA support for Receive Transfer. If
                                                         enabled, DMA will be requested to empty the FIFO until either
                                                          the interface reaches TRANSFER_LENGTH or the DMA sends a termination
                                                          request.
                                                          The size defined here must match DMA programmed access size.
                                                         1=DMA is enabled.and set to 1 Byte
                                                         2=DMA is enabled and set to 2 Bytes
                                                         3=DMA is enabled and set to 4 Bytes
                                                         0=DMA is disabled. All data in the Receive Buffer must be emptied
                                                          by firmware.                                                         */
      __I  uint32_t  CLOSE_TRANFSER_ENABLE:  1;     /*!< [9..9] This selects what action is taken at the end of a transfer.
                                                         This bit must be set only on the Last Buffer.
                                                         1=The transfer is terminated. The Chip Select de-asserts, the
                                                          SPI interface returns to IDLE and the DMA interface completes
                                                          the transfer.
                                                         0=The transfer is not closed. Chip Select remains asserted and
                                                          the DMA interface and the SPI interface remain active                */
      __IO uint32_t  TRANSFER_LENGTH_BITS:  1;      /*!< [10..10] 1=TRANSFER_LENGTH defined in bits
                                                          0=TRANSFER_LENGTH defined in bytes                                   */
      __I  uint32_t  DESCRIPTION_BUFFER_LAST:  1;   /*!< [11..11] If this bit is 1 then this is the last Description
                                                         Buffer in the chain. When the transfer described by this buffer
                                                          completes the TRANSFER_ COMPLETE status will be set to 1.
                                                         If this bit is 0, then this is not the last buffer in use. When
                                                          the transfer completes the next buffer will be activated, and
                                                          no additional status will be asserted.                               */
      __I  uint32_t  DESCRIPTION_BUFFER_NEXT_POINTER:  4;/*!< [12..15] This defines the next buffer to be used if Description
                                                         Buffers are enabled and this is not the last buffer. This can
                                                          point to the current buffer, creating an infinite loop.              */
      __IO uint32_t  TRANSFER_LENGTH: 16;           /*!< [16..31] The length of the SPI transfer. The count is in bytes
                                                         or bits, depending on the value of TRANSFER_LENGTH_BITS. A value
                                                          of 0 means an infinite length transfer.                              */
    } QMSPI_DESCRIPTION_BUFFER_0_b;                 /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  QMSPI_DESCRIPTION_BUFFER_1;      /*!< (@ 0x40005434) QMSPI Description Buffer 1 Register                    */

    struct {
      __IO uint32_t  INTERFACE_MODE:  2;            /*!< [0..1] This field sets the transmission mode. If this field
                                                         is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE
                                                          or RX_TRANSFER_ENABLE must be 0.
                                                         3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode.
                                                                                                                               */
      __IO uint32_t  TX_TRANSFER_ENABLE:  2;        /*!< [2..3] This field bit selects the transmit function of the SPI
                                                         interface.
                                                         3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out
                                                          only 1's. The Transmit Buffer will not be used
                                                         2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out
                                                          only 0's. The Transmit Buffer will not be used.
                                                         1=Transmit Enabled. Data will be fetched from the Transmit Buffer
                                                          and sent out on the MOSI or IO Bus.
                                                         0=Transmit is Disabled. No data is sent. This will cause the
                                                          MOSI be to be undriven, or the IO bus to be undriven if Rece         */
      __IO uint32_t  TX_DMA_ENABLE:  2;             /*!< [4..5] This bit enables DMA support for Transmit Transfer. If
                                                         enabled, DMA will be requested to fill the FIFO until either
                                                          the interface
                                                         reaches TRANSFER_LENGTH or the DMA sends a termination request.
                                                          The size defined here must match DMA programmed access size.
                                                         1=DMA is enabled.and set to 1 Byte
                                                          2=DMA is enabled and set to 2 Bytes
                                                          3=DMA is enabled and set to 4 Bytes0=DMA is disabled. All data
                                                          in the Transmit Buffer must be emptied by firmware.                  */
      __IO uint32_t  RX_TRANSFER_ENABLE:  1;        /*!< [6..6] This bit enables the receive function of the SPI interface.
                                                         1=Receive is enabled. Data received from the SPI Slave is stored
                                                         in the Receive Buffer; 0=Receive is disabled.                         */
      __I  uint32_t  RX_DMA_ENABLE:  2;             /*!< [7..8] This bit enables DMA support for Receive Transfer. If
                                                         enabled, DMA will be requested to empty the FIFO until either
                                                          the interface reaches TRANSFER_LENGTH or the DMA sends a termination
                                                          request.
                                                          The size defined here must match DMA programmed access size.
                                                         1=DMA is enabled.and set to 1 Byte
                                                         2=DMA is enabled and set to 2 Bytes
                                                         3=DMA is enabled and set to 4 Bytes
                                                         0=DMA is disabled. All data in the Receive Buffer must be emptied
                                                          by firmware.                                                         */
      __I  uint32_t  CLOSE_TRANFSER_ENABLE:  1;     /*!< [9..9] This selects what action is taken at the end of a transfer.
                                                         This bit must be set only on the Last Buffer.
                                                         1=The transfer is terminated. The Chip Select de-asserts, the
                                                          SPI interface returns to IDLE and the DMA interface completes
                                                          the transfer.
                                                         0=The transfer is not closed. Chip Select remains asserted and
                                                          the DMA interface and the SPI interface remain active                */
      __IO uint32_t  TRANSFER_LENGTH_BITS:  1;      /*!< [10..10] 1=TRANSFER_LENGTH defined in bits
                                                          0=TRANSFER_LENGTH defined in bytes                                   */
      __I  uint32_t  DESCRIPTION_BUFFER_LAST:  1;   /*!< [11..11] If this bit is 1 then this is the last Description
                                                         Buffer in the chain. When the transfer described by this buffer
                                                          completes the TRANSFER_ COMPLETE status will be set to 1.
                                                         If this bit is 0, then this is not the last buffer in use. When
                                                          the transfer completes the next buffer will be activated, and
                                                          no additional status will be asserted.                               */
      __I  uint32_t  DESCRIPTION_BUFFER_NEXT_POINTER:  4;/*!< [12..15] This defines the next buffer to be used if Description
                                                         Buffers are enabled and this is not the last buffer. This can
                                                          point to the current buffer, creating an infinite loop.              */
      __IO uint32_t  TRANSFER_LENGTH: 16;           /*!< [16..31] The length of the SPI transfer. The count is in bytes
                                                         or bits, depending on the value of TRANSFER_LENGTH_BITS. A value
                                                          of 0 means an infinite length transfer.                              */
    } QMSPI_DESCRIPTION_BUFFER_1_b;                 /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  QMSPI_DESCRIPTION_BUFFER_2;      /*!< (@ 0x40005438) QMSPI Description Buffer 2 Register                    */

    struct {
      __IO uint32_t  INTERFACE_MODE:  2;            /*!< [0..1] This field sets the transmission mode. If this field
                                                         is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE
                                                          or RX_TRANSFER_ENABLE must be 0.
                                                         3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode.
                                                                                                                               */
      __IO uint32_t  TX_TRANSFER_ENABLE:  2;        /*!< [2..3] This field bit selects the transmit function of the SPI
                                                         interface.
                                                         3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out
                                                          only 1's. The Transmit Buffer will not be used
                                                         2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out
                                                          only 0's. The Transmit Buffer will not be used.
                                                         1=Transmit Enabled. Data will be fetched from the Transmit Buffer
                                                          and sent out on the MOSI or IO Bus.
                                                         0=Transmit is Disabled. No data is sent. This will cause the
                                                          MOSI be to be undriven, or the IO bus to be undriven if Rece         */
      __IO uint32_t  TX_DMA_ENABLE:  2;             /*!< [4..5] This bit enables DMA support for Transmit Transfer. If
                                                         enabled, DMA will be requested to fill the FIFO until either
                                                          the interface
                                                         reaches TRANSFER_LENGTH or the DMA sends a termination request.
                                                          The size defined here must match DMA programmed access size.
                                                         1=DMA is enabled.and set to 1 Byte
                                                          2=DMA is enabled and set to 2 Bytes
                                                          3=DMA is enabled and set to 4 Bytes0=DMA is disabled. All data
                                                          in the Transmit Buffer must be emptied by firmware.                  */
      __IO uint32_t  RX_TRANSFER_ENABLE:  1;        /*!< [6..6] This bit enables the receive function of the SPI interface.
                                                         1=Receive is enabled. Data received from the SPI Slave is stored
                                                         in the Receive Buffer; 0=Receive is disabled.                         */
      __I  uint32_t  RX_DMA_ENABLE:  2;             /*!< [7..8] This bit enables DMA support for Receive Transfer. If
                                                         enabled, DMA will be requested to empty the FIFO until either
                                                          the interface reaches TRANSFER_LENGTH or the DMA sends a termination
                                                          request.
                                                          The size defined here must match DMA programmed access size.
                                                         1=DMA is enabled.and set to 1 Byte
                                                         2=DMA is enabled and set to 2 Bytes
                                                         3=DMA is enabled and set to 4 Bytes
                                                         0=DMA is disabled. All data in the Receive Buffer must be emptied
                                                          by firmware.                                                         */
      __I  uint32_t  CLOSE_TRANFSER_ENABLE:  1;     /*!< [9..9] This selects what action is taken at the end of a transfer.
                                                         This bit must be set only on the Last Buffer.
                                                         1=The transfer is terminated. The Chip Select de-asserts, the
                                                          SPI interface returns to IDLE and the DMA interface completes
                                                          the transfer.
                                                         0=The transfer is not closed. Chip Select remains asserted and
                                                          the DMA interface and the SPI interface remain active                */
      __IO uint32_t  TRANSFER_LENGTH_BITS:  1;      /*!< [10..10] 1=TRANSFER_LENGTH defined in bits
                                                          0=TRANSFER_LENGTH defined in bytes                                   */
      __I  uint32_t  DESCRIPTION_BUFFER_LAST:  1;   /*!< [11..11] If this bit is 1 then this is the last Description
                                                         Buffer in the chain. When the transfer described by this buffer
                                                          completes the TRANSFER_ COMPLETE status will be set to 1.
                                                         If this bit is 0, then this is not the last buffer in use. When
                                                          the transfer completes the next buffer will be activated, and
                                                          no additional status will be asserted.                               */
      __I  uint32_t  DESCRIPTION_BUFFER_NEXT_POINTER:  4;/*!< [12..15] This defines the next buffer to be used if Description
                                                         Buffers are enabled and this is not the last buffer. This can
                                                          point to the current buffer, creating an infinite loop.              */
      __IO uint32_t  TRANSFER_LENGTH: 16;           /*!< [16..31] The length of the SPI transfer. The count is in bytes
                                                         or bits, depending on the value of TRANSFER_LENGTH_BITS. A value
                                                          of 0 means an infinite length transfer.                              */
    } QMSPI_DESCRIPTION_BUFFER_2_b;                 /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  QMSPI_DESCRIPTION_BUFFER_3;      /*!< (@ 0x4000543C) QMSPI Description Buffer 3 Register                    */

    struct {
      __IO uint32_t  INTERFACE_MODE:  2;            /*!< [0..1] This field sets the transmission mode. If this field
                                                         is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE
                                                          or RX_TRANSFER_ENABLE must be 0.
                                                         3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode.
                                                                                                                               */
      __IO uint32_t  TX_TRANSFER_ENABLE:  2;        /*!< [2..3] This field bit selects the transmit function of the SPI
                                                         interface.
                                                         3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out
                                                          only 1's. The Transmit Buffer will not be used
                                                         2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out
                                                          only 0's. The Transmit Buffer will not be used.
                                                         1=Transmit Enabled. Data will be fetched from the Transmit Buffer
                                                          and sent out on the MOSI or IO Bus.
                                                         0=Transmit is Disabled. No data is sent. This will cause the
                                                          MOSI be to be undriven, or the IO bus to be undriven if Rece         */
      __IO uint32_t  TX_DMA_ENABLE:  2;             /*!< [4..5] This bit enables DMA support for Transmit Transfer. If
                                                         enabled, DMA will be requested to fill the FIFO until either
                                                          the interface
                                                         reaches TRANSFER_LENGTH or the DMA sends a termination request.
                                                          The size defined here must match DMA programmed access size.
                                                         1=DMA is enabled.and set to 1 Byte
                                                          2=DMA is enabled and set to 2 Bytes
                                                          3=DMA is enabled and set to 4 Bytes0=DMA is disabled. All data
                                                          in the Transmit Buffer must be emptied by firmware.                  */
      __IO uint32_t  RX_TRANSFER_ENABLE:  1;        /*!< [6..6] This bit enables the receive function of the SPI interface.
                                                         1=Receive is enabled. Data received from the SPI Slave is stored
                                                         in the Receive Buffer; 0=Receive is disabled.                         */
      __I  uint32_t  RX_DMA_ENABLE:  2;             /*!< [7..8] This bit enables DMA support for Receive Transfer. If
                                                         enabled, DMA will be requested to empty the FIFO until either
                                                          the interface reaches TRANSFER_LENGTH or the DMA sends a termination
                                                          request.
                                                          The size defined here must match DMA programmed access size.
                                                         1=DMA is enabled.and set to 1 Byte
                                                         2=DMA is enabled and set to 2 Bytes
                                                         3=DMA is enabled and set to 4 Bytes
                                                         0=DMA is disabled. All data in the Receive Buffer must be emptied
                                                          by firmware.                                                         */
      __I  uint32_t  CLOSE_TRANFSER_ENABLE:  1;     /*!< [9..9] This selects what action is taken at the end of a transfer.
                                                         This bit must be set only on the Last Buffer.
                                                         1=The transfer is terminated. The Chip Select de-asserts, the
                                                          SPI interface returns to IDLE and the DMA interface completes
                                                          the transfer.
                                                         0=The transfer is not closed. Chip Select remains asserted and
                                                          the DMA interface and the SPI interface remain active                */
      __IO uint32_t  TRANSFER_LENGTH_BITS:  1;      /*!< [10..10] 1=TRANSFER_LENGTH defined in bits
                                                          0=TRANSFER_LENGTH defined in bytes                                   */
      __I  uint32_t  DESCRIPTION_BUFFER_LAST:  1;   /*!< [11..11] If this bit is 1 then this is the last Description
                                                         Buffer in the chain. When the transfer described by this buffer
                                                          completes the TRANSFER_ COMPLETE status will be set to 1.
                                                         If this bit is 0, then this is not the last buffer in use. When
                                                          the transfer completes the next buffer will be activated, and
                                                          no additional status will be asserted.                               */
      __I  uint32_t  DESCRIPTION_BUFFER_NEXT_POINTER:  4;/*!< [12..15] This defines the next buffer to be used if Description
                                                         Buffers are enabled and this is not the last buffer. This can
                                                          point to the current buffer, creating an infinite loop.              */
      __IO uint32_t  TRANSFER_LENGTH: 16;           /*!< [16..31] The length of the SPI transfer. The count is in bytes
                                                         or bits, depending on the value of TRANSFER_LENGTH_BITS. A value
                                                          of 0 means an infinite length transfer.                              */
    } QMSPI_DESCRIPTION_BUFFER_3_b;                 /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  QMSPI_DESCRIPTION_BUFFER_4;      /*!< (@ 0x40005440) QMSPI Description Buffer 4 Register                    */

    struct {
      __IO uint32_t  INTERFACE_MODE:  2;            /*!< [0..1] This field sets the transmission mode. If this field
                                                         is set for Dual Mode or Quad Mode then either TX_TRANSFER_ENABLE
                                                          or RX_TRANSFER_ENABLE must be 0.
                                                         3=Reserved; 2=Quad Mode; 1=Dual Mode; 0=Single/Duplex Mode.
                                                                                                                               */
      __IO uint32_t  TX_TRANSFER_ENABLE:  2;        /*!< [2..3] This field bit selects the transmit function of the SPI
                                                         interface.
                                                         3=Transmit Enabled in 1 Mode. The MOSI or IO Bus will send out
                                                          only 1's. The Transmit Buffer will not be used
                                                         2=Transmit Enabled in 0 Mode. The MOSI or IO Bus will send out
                                                          only 0's. The Transmit Buffer will not be used.
                                                         1=Transmit Enabled. Data will be fetched from the Transmit Buffer
                                                          and sent out on the MOSI or IO Bus.
                                                         0=Transmit is Disabled. No data is sent. This will cause the
                                                          MOSI be to be undriven, or the IO bus to be undriven if Rece         */
      __IO uint32_t  TX_DMA_ENABLE:  2;             /*!< [4..5] This bit enables DMA support for Transmit Transfer. If
                                                         enabled, DMA will be requested to fill the FIFO until either
                                                          the interface
                                                         reaches TRANSFER_LENGTH or the DMA sends a termination request.
                                                          The size defined here must match DMA programmed access size.
                                                         1=DMA is enabled.and set to 1 Byte
                                                          2=DMA is enabled and set to 2 Bytes
                                                          3=DMA is enabled and set to 4 Bytes0=DMA is disabled. All data
                                                          in the Transmit Buffer must be emptied by firmware.                  */
      __IO uint32_t  RX_TRANSFER_ENABLE:  1;        /*!< [6..6] This bit enables the receive function of the SPI interface.
                                                         1=Receive is enabled. Data received from the SPI Slave is stored
                                                         in the Receive Buffer; 0=Receive is disabled.                         */
      __I  uint32_t  RX_DMA_ENABLE:  2;             /*!< [7..8] This bit enables DMA support for Receive Transfer. If
                                                         enabled, DMA will be requested to empty the FIFO until either
                                                          the interface reaches TRANSFER_LENGTH or the DMA sends a termination
                                                          request.
                                                          The size defined here must match DMA programmed access size.
                                                         1=DMA is enabled.and set to 1 Byte
                                                         2=DMA is enabled and set to 2 Bytes
                                                         3=DMA is enabled and set to 4 Bytes
                                                         0=DMA is disabled. All data in the Receive Buffer must be emptied
                                                          by firmware.                                                         */
      __I  uint32_t  CLOSE_TRANFSER_ENABLE:  1;     /*!< [9..9] This selects what action is taken at the end of a transfer.
                                                         This bit must be set only on the Last Buffer.
                                                         1=The transfer is terminated. The Chip Select de-asserts, the
                                                          SPI interface returns to IDLE and the DMA interface completes
                                                          the transfer.
                                                         0=The transfer is not closed. Chip Select remains asserted and
                                                          the DMA interface and the SPI interface remain active                */
      __IO uint32_t  TRANSFER_LENGTH_BITS:  1;      /*!< [10..10] 1=TRANSFER_LENGTH defined in bits
                                                          0=TRANSFER_LENGTH defined in bytes                                   */
      __I  uint32_t  DESCRIPTION_BUFFER_LAST:  1;   /*!< [11..11] If this bit is 1 then this is the last Description
                                                         Buffer in the chain. When the transfer described by this buffer
                                                          completes the TRANSFER_ COMPLETE status will be set to 1.
                                                         If this bit is 0, then this is not the last buffer in use. When
                                                          the transfer completes the next buffer will be activated, and
                                                          no additional status will be asserted.                               */
      __I  uint32_t  DESCRIPTION_BUFFER_NEXT_POINTER:  4;/*!< [12..15] This defines the next buffer to be used if Description
                                                         Buffers are enabled and this is not the last buffer. This can
                                                          point to the current buffer, creating an infinite loop.              */
      __IO uint32_t  TRANSFER_LENGTH: 16;           /*!< [16..31] The length of the SPI transfer. The count is in bytes
                                                         or bits, depending on the value of TRANSFER_LENGTH_BITS. A value
                                                          of 0 means an infinite length transfer.                              */
    } QMSPI_DESCRIPTION_BUFFER_4_b;                 /*!< [32] BitSize                                                          */
  };
} QMSPI_INST_Type;


/* ================================================================================ */
/* ================                    TFDP_INST                   ================ */
/* ================================================================================ */


/**
  * @brief The TFDP serially transmits Embedded Controller (EC)-originated
 diagnostic vectors to an external debug trace system.  (TFDP_INST)
  */

typedef struct {                                    /*!< (@ 0x40008C00) TFDP_INST Structure                                    */
  __IO uint8_t   DEBUG_DATA;                        /*!< (@ 0x40008C00) Debug data to be shifted out on the TFDP Debug
                                                         port. While data is being shifted out, the Host Interface will
                                                          'hold-off' additional writes to the data register until the
                                                          transfer is complete.                                                */
  __I  uint8_t   RESERVED[3];

  union {
    __IO uint8_t   DEBUG_CONTROL;                   /*!< (@ 0x40008C04) Debug Control Register                                 */

    struct {
      __IO uint8_t   EN         :  1;               /*!< [0..0] Enable. 1=Clock enabled, 0=Clock is disabled (Default)
                                                                                                                               */
      __IO uint8_t   EDGE_SEL   :  1;               /*!< [1..1] 1= Data is shifted out on the falling edge of the debug
                                                         clock, 0= Data is shifted out on the rising edge of the debug
                                                          clock (Default)                                                      */
      __IO uint8_t   DIVSEL     :  2;               /*!< [2..3] Clock Divider Select.                                          */
      __IO uint8_t   IP_DELAY   :  3;               /*!< [4..6] Inter-packet Delay. The delay is in terms of TFDP Debug
                                                         output clocks.                                                        */
    } DEBUG_CONTROL_b;                              /*!< [7] BitSize                                                           */
  };
} TFDP_INST_Type;


/* ================================================================================ */
/* ================                    VCI_INST                    ================ */
/* ================================================================================ */


/**
  * @brief The VBAT-Powered Control Interface has VBAT-powered combinational logic and input and output signal pins.
 The block interfaces with the RTC With Date and DST Adjustment as well as the Week Alarm.  (VCI_INST)
  */

typedef struct {                                    /*!< (@ 0x4000AE00) VCI_INST Structure                                     */

  union {
    __IO uint32_t  VCI_REG;                         /*!< (@ 0x4000AE00) VCI Register                                           */

    struct {
      __I  uint32_t  VCI_IN     :  7;               /*!< [0..6] These bits provide the latched state of the associated
                                                         VCI_IN# pin, if latching is enabled or the current state of
                                                          the pin
                                                         if latching is not enabled. In both cases, the value is determined
                                                          after the action of the VCI Polarity Register.
                                                         Note: The VCI_IN[6:0]# bits default to the state of their respective
                                                          input pins.                                                          */
           uint32_t             :  1;
      __I  uint32_t  VCI_OVRD_IN:  1;               /*!< [8..8] This bit provides the current status of the VCI_OVRD_IN
                                                         pin.
                                                         Note: The VCI_OVRD_IN bit defaults to the state of the respective
                                                          input pin.                                                           */
      __I  uint32_t  VCI_OUT    :  1;               /*!< [9..9] This bit provides the current status of the VCI_OUT pin.
                                                                                                                               */
      __IO uint32_t  VCI_FW_CNTRL:  1;              /*!< [10..10] This bit can allow EC firmware to control the state
                                                         of the VCI_OUT pin. For example, when VTR_PWRGD is asserted
                                                          and the
                                                         FW_EXT bit is 1, clearing the VCI_FW_CNTRL bit de-asserts the
                                                          active high VCI_OUT pin. BIOS must set this bit to 1 prior to
                                                          setting
                                                         the FW_EXT bit to 1 on power up, in order to avoid glitches
                                                          on the VCI_OUT pin.                                                  */
      __IO uint32_t  FW_EXT     :  1;               /*!< [11..11] This bit controls selecting between the external VBAT-Powered
                                                         Control Interface inputs, or the VCI_FW_CNTRL bit output to
                                                          control the VCI_OUT pin.
                                                         1=VCI_OUT is determined by the VCI_FW_CNTRL field, when VTR
                                                          is active
                                                         0=VCI_OUT is determined by the external inputs.
                                                         Note: This bit used to be called GPO/nEXT. The name was changed
                                                          to distinguish it from the BGPOs, which are elsewhere, and to
                                                          remove a / in a bit name.                                            */
      __IO uint32_t  FILTERS_BYPASS:  1;            /*!< [12..12] The Filters Bypass bit is used to enable and disable
                                                         the input filters on the VCI_IN# pins.
                                                         1=Filters disabled; 0=Filters enabled (default).                      */
           uint32_t             :  3;
      __I  uint32_t  WEEK_ALRM  :  1;               /*!< [16..16] If enabled by WEEK_ALRM_LE, this bit is set to 1 if
                                                         the Week Alarm signal is asserted. It is reset by writes to
                                                          WEEK_ALRM_LS.                                                        */
      __I  uint32_t  RTC_ALRM   :  1;               /*!< [17..17] If enabled by RTC_ALRM_LE, this bit is set to 1 if
                                                         the RTC Alarm signal is asserted. It is reset by writes to RTC_ALRM_LS.
                                                                                                                               */
    } VCI_REG_b;                                    /*!< [18] BitSize                                                          */
  };

  union {
    __IO uint32_t  LATCH_ENABLE;                    /*!< (@ 0x4000AE04) Latch Enable Register                                  */

    struct {
      __IO uint32_t  LE         :  7;               /*!< [0..6] Latching Enables. Latching occurs after the Polarity
                                                         configuration, so a VCI_INi# pin is asserted when it is '0'
                                                          if VCI_IN_POL is '0', and asserted when it is '1' if VCI_IN_POL
                                                          is '1'.
                                                         For each bit in the field:
                                                         1=Enabled. Assertions of the VCI_INi# pin are held until the
                                                          latch is reset by writing the corresponding LS bit
                                                         0=Not Enabled. The VCI_INi# signal is not latched but passed
                                                          directly to the VCI_OUT logic                                        */
           uint32_t             :  9;
      __IO uint32_t  WEEK_ALRM_LE:  1;              /*!< [16..16] Latch enable for the Week Alarm Power-Up signal.
                                                         1=Enabled. Assertions of the Week Alarm are held until the latch
                                                         is reset by writing the corresponding LS bit
                                                         0=Not Enabled. The Week Alarm signal is not latched but passed
                                                          directly to the VCI_OUT logic                                        */
      __IO uint32_t  RTC_ALRM_LE:  1;               /*!< [17..17] Latch enable for the RTC Power-Up signal.
                                                         1=Enabled. Assertions of the RTC Alarm are held until the latch
                                                         is reset by writing the corresponding LS bit
                                                         0=Not Enabled. The RTC Alarm signal is not latched but passed
                                                          directly to the VCI_OUT logic                                        */
    } LATCH_ENABLE_b;                               /*!< [18] BitSize                                                          */
  };

  union {
    __IO uint32_t  LATCH_RESETS;                    /*!< (@ 0x4000AE08) Latch Resets Register                                  */

    struct {
      __O  uint32_t  LS         :  7;               /*!< [0..6] Latch Resets. When a Latch Resets bit is written with
                                                         a '1', the corresponding VCI_INi# latch is de-asserted ('1').
                                                          The VCI_INi#
                                                         input to the latch has priority over the Latch Reset input,
                                                          so firmware cannot reset the latch while the VCI_INi# pin is
                                                          asserted. Firmware
                                                         should sample the state of the pin in the VCI Register before
                                                          attempting to reset the latch. As noted in the Latch Enable
                                                          Register,
                                                         the assertion level is determined by the VCI_IN_POL bit. Reads
                                                          of this register are undefined.                                      */
           uint32_t             :  9;
      __O  uint32_t  WEEK_ALRM_LS:  1;              /*!< [16..16] Week Alarm Latch Reset. When this bit is written with
                                                         a '1', the Week Alarm Event latch is reset.
                                                         The Week Alarm input to the latch has priority over the Reset
                                                          input Reads of this register are undefined.                          */
      __O  uint32_t  RTC_ALRM_LS:  1;               /*!< [17..17] RTC Alarm Latch Reset. When this bit is written with
                                                         a '1', the RTC Alarm Event latch is reset.
                                                         The RTC Alarm input to the latch has priority over the Reset
                                                          input Reads of this register are undefined.                          */
    } LATCH_RESETS_b;                               /*!< [18] BitSize                                                          */
  };

  union {
    __IO uint32_t  VCI_INPUT_ENABLE;                /*!< (@ 0x4000AE0C) VCI Input Enable Register                              */

    struct {
      __IO uint32_t  IE         :  7;               /*!< [0..6] Input Enables for VCI_IN# signals. After changing the
                                                         input enable for a VCI input, firmware should reset the input
                                                          latch and clear
                                                         any potential interrupt that may have been triggered by the
                                                          input, as changing the enable may cause the internal status
                                                          to change.
                                                         For each bit in the field:
                                                         1=Enabled. The corresponding VCI_IN# input is not gated and
                                                          toggling the pin will affect the VCI_OUT pin
                                                         0=Not Enabled. the corresponding VCI_IN# input does not affect
                                                          the VCI_OUT pin, even if the input is '0'. Unless the                */
    } VCI_INPUT_ENABLE_b;                           /*!< [7] BitSize                                                           */
  };

  union {
    __IO uint32_t  HOLDOFF_COUNT;                   /*!< (@ 0x4000AE10) Holdoff Count Register                                 */

    struct {
      __IO uint32_t  HOLDOFF_TIME:  8;              /*!< [0..7] These bits determine the period of time the VCI_OUT logic
                                                         is inhibited from re-asserting VCI_OUT after a SYS_SHDN# event.
                                                         FFh-01h=The Power On Inhibit Holdoff Time is set to a period
                                                          between 125ms and 31.875 seconds.
                                                         0=The Power On Inhibit function is disabled.                          */
    } HOLDOFF_COUNT_b;                              /*!< [8] BitSize                                                           */
  };

  union {
    __IO uint32_t  VCI_POLARITY;                    /*!< (@ 0x4000AE14) VCI Polarity Register                                  */

    struct {
      __IO uint32_t  VCI_IN_POL :  7;               /*!< [0..6] These bits determine the polarity of the VCI_IN input
                                                         signals: For each bit in the field:
                                                         1=Active High. The value on the pins is inverted before use
                                                         0=Active Low (default).                                               */
    } VCI_POLARITY_b;                               /*!< [7] BitSize                                                           */
  };

  union {
    __IO uint32_t  VCI_POSEDGE_DETECT;              /*!< (@ 0x4000AE18) VCI Posedge Detect Register                            */

    struct {
      __IO uint32_t  VCI_IN_POS :  7;               /*!< [0..6] These bits record a low to high transition on the VCI_IN#
                                                         pins. A 1 indicates a transition occurred. For each bit in the
                                                          field:
                                                         1=Positive Edge Detected; 0=No edge detected.                         */
    } VCI_POSEDGE_DETECT_b;                         /*!< [7] BitSize                                                           */
  };

  union {
    __IO uint32_t  VCI_NEGEDGE_DETECT;              /*!< (@ 0x4000AE1C) VCI Negedge Detect Register                            */

    struct {
      __IO uint32_t  VCI_IN_NEG :  7;               /*!< [0..6] These bits record a high to low transition on the VCI_IN#
                                                         pins. A 1 indicates a transition occurred. For each bit in the
                                                          field:
                                                         1=Negative Edge Detected; 0=No edge detected.                         */
    } VCI_NEGEDGE_DETECT_b;                         /*!< [7] BitSize                                                           */
  };

  union {
    __IO uint32_t  VCI_BUFFER_ENABLE;               /*!< (@ 0x4000AE20) VCI Buffer Enable Register                             */

    struct {
      __IO uint32_t  VCI_BUFFER_EN:  7;             /*!< [0..6] Input Buffer enable. After changing the buffer enable
                                                         for a VCI input, firmware should reset the input latch and clear
                                                          any
                                                         potential interrupt that may have been triggered by the input,
                                                          as changing the buffer may cause the internal status to change.
                                                          This register
                                                         has no effect when VTR is powered. When VTR is on, the input
                                                          buffers are enabled only by the IE bit. For each bit in the
                                                          field:
                                                         1=VCI_IN# input buffer enabled independent of the IE bit. The
                                                          edge detection latches for this input are always enabled
                                                                                                                               */
    } VCI_BUFFER_ENABLE_b;                          /*!< [7] BitSize                                                           */
  };
} VCI_INST_Type;


/* ================================================================================ */
/* ================                  VBAT_RAM_INST                 ================ */
/* ================================================================================ */


/**
  * @brief The VBAT Powered RAM provides a 128 Byte Random Accessed Memory that is operational while the main
 power rail is operational, and will retain its values powered by battery power while the main rail is unpowered.  (VBAT_RAM_INST)
  */

typedef struct {                                    /*!< (@ 0x4000A800) VBAT_RAM_INST Structure                                */
  __IO uint32_t  VBAT_RAM_DW_[32];                  /*!< (@ 0x4000A800) 32-bits of VBAT powered RAM.                           */
} VBAT_RAM_INST_Type;


/* ================================================================================ */
/* ================                    VBAT_INST                   ================ */
/* ================================================================================ */


/**
  * @brief The VBAT Register Bank block is a block implemented for aggregating miscellaneous
 battery-backed registers required the host and by the Embedded Controller (EC) Subsystem that are
 not unique to a block implemented in the EC subsystem.  (VBAT_INST)
  */

typedef struct {                                    /*!< (@ 0x4000A400) VBAT_INST Structure                                    */

  union {
    __IO uint8_t   PFR_STS;                         /*!< (@ 0x4000A400) The Power-Fail and Reset Status Register collects
                                                         and retains the VBAT RST and WDT event status when VCC1 is unpowered.
                                                                                                                               */

    struct {
           uint8_t              :  2;
      __IO uint8_t   SOFT       :  1;               /*!< [2..2] This bit is set to '1b' if a was triggered by an assertion
                                                         of the SOFT_SYS_RESET bit in the System Reset Register.
                                                          This bit is cleared to '0b' when written with a '1b'; writes
                                                          of a '0b' have no effect. (R/WC)                                     */
      __IO uint8_t   TEST       :  1;               /*!< [3..3] Test                                                           */
      __IO uint8_t   RESETI     :  1;               /*!< [4..4] This bit is set to '1b' if a RESET_SYS was triggered
                                                         by a low signal on the RESETI# input pin. This bit is
                                                          cleared to '0b' when written with a '1b'; writes of a '0b'
                                                          have no effect. (R/WC)                                               */
      __IO uint8_t   WDT_EVT    :  1;               /*!< [5..5] This bit is set to '1b' if a RESET_SYS was triggered
                                                         by a Watchdog Timer event. This bit is cleared to '0b' when
                                                          written with a '1b'; writes of a '0b' have no effect. (R/WC)
                                                                                                                               */
      __IO uint8_t   SYSRESETREQ:  1;               /*!< [6..6] This bit is set to '1b' if a RESET_SYS was triggered
                                                         by an ARM SYSRESETREQ event. This bit is cleared to '0b' when
                                                          written with a '1b'; writes of a '0b' have no effect. (R/WC)
                                                                                                                               */
      __IO uint8_t   VBAT_RST   :  1;               /*!< [7..7] The VBAT RST bit is set to '1' by hardware when a RESET_VBAT
                                                         is detected. This is the register default value.
                                                          To clear VBAT RST EC firmware must write a '1' to this bit;
                                                          writing a '0' to VBAT RST has no affect.(R/WC)                       */
    } PFR_STS_b;                                    /*!< [8] BitSize                                                           */
  };
  __I  uint8_t   RESERVED[7];

  union {
    __IO uint32_t  CLOCK_EN;                        /*!< (@ 0x4000A408) CLOCK ENABLE                                           */

    struct {
      __IO uint32_t  C32K_SUPPRESS:  1;             /*!< [0..0] 1=32KHz clock domain is off while VTR is off (i.e., while
                                                         on VBAT only). The 32KHz domain is always on
                                                          while VTR is on, so the PLL always has a reference.
                                                          0=32KHz clock domain is enabled while VTR is off (i.e., while
                                                          on VBAT only). The clock source for the 32KHz domain is
                                                          determined by the other bits in this register                        */
      __IO uint32_t  EXT_32K    :  1;               /*!< [1..1] This bit selects the source for the 32KHz clock domain.
                                                          1=The 32KHZ_IN VTR-powered pin is used as a source for the
                                                         32KHz clock domain. If an activity detector does not detect
                                                          a
                                                          clock on the selected source, the always-on 32KHz internal
                                                          clock source is automatically selected
                                                          0=The always-on32Khz clock source is used as the source for
                                                          the 32KHz clock domain.                                              */
      __IO uint32_t  C32KHZ_SOURCE:  1;             /*!< [2..2] This field determines the source for the always-on 32KHz
                                                         internal clock source. If set to '1b', this bit
                                                          will only take effect if an active clock has been detected
                                                          on the crystal pins. Once the 32KHz source has been switched,
                                                          activity detection on the crystal no longer functions. Therefore,
                                                          if the crystal oscillator uses a single-ended
                                                          input, once started that input must not stop while this bit
                                                          is '1b'.
                                                          1=Crystal Oscillator. The selection between a singled-ended
                                                          input or a resonant crystal is determine                             */
      __IO uint32_t  XOSEL      :  1;               /*!< [3..3] This bit selects between a single-ended clock source
                                                         for the crystal oscillator or an external parallel crystal.
                                                          1= the Crystal Oscillator is driven by a single-ended 32KHz
                                                          clock source connected to the XTAL2 pin.
                                                          0= the Crystal Oscillator requires a 32KHz parallel resonant
                                                          crystal connected between the XTAL1 and XTAL2 pins (default).
                                                                                                                               */
    } CLOCK_EN_b;                                   /*!< [4] BitSize                                                           */
  };
  __I  uint32_t  RESERVED1[5];

  union {
    __IO uint32_t  MONOTONIC_COUNTER;               /*!< (@ 0x4000A420) MONOTONIC COUNTER                                      */

    struct {
      __I  uint32_t  MONOTONIC_COUNTER: 32;         /*!< [0..31] Read-only register that increments by 1 every time it
                                                         is read. It is reset to 0 on a VBAT Power On Reset.                   */
    } MONOTONIC_COUNTER_b;                          /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  COUNTER_HIWORD;                  /*!< (@ 0x4000A424) COUNTER HIWORD                                         */

    struct {
      __IO uint32_t  COUNTER_HIWORD: 32;            /*!< [0..31] Thirty-two bit read/write register. If software sets
                                                         this register to an incrementing value, based on an external
                                                          non-volatile store, this register may be combined with the
                                                          Monotonic Counter Register to form a 64-bit monotonic counter.
                                                                                                                               */
    } COUNTER_HIWORD_b;                             /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  VWIRE_BACKUP;                    /*!< (@ 0x4000A428) VWIRE_BACKUP                                           */

    struct {
      __IO uint32_t  M2S_2H_BACKUP:  4;             /*!< [0..3] The Boot ROM firmware will copy this field into the SRC3
                                                         to SRC0 bits of the Master-to-Slave Virtual Wire Register
                                                          that corresponds to Virtual Wire Index 2h on a RESET_SYS. If
                                                          software always saves the state of the Index 2h SRC bits on
                                                          the falling
                                                          edge of the SUSWARN# virtual wire, the state of the four SRC
                                                          bits will be synchronized to the state of the four bits in the
                                                          core logic.                                                          */
      __IO uint32_t  M2S_42H_BACKUP:  4;            /*!< [4..7] The Boot ROM firmware will copy this field into the SRC3
                                                         to SRC0 bits of the Master-to-Slave Virtual Wire Register
                                                          that corresponds to Virtual Wire Index 42h on a RESET_SYS.
                                                          If software always saves the state of the Index 2h SRC bits
                                                          on the falling
                                                          edge of the SUSWARN# virtual wire, the state of the four SRC
                                                          bits will be synchronized to the state of the four bits in the
                                                          core logic.                                                          */
    } VWIRE_BACKUP_b;                               /*!< [8] BitSize                                                           */
  };
} VBAT_INST_Type;


/* ================================================================================ */
/* ================                EC_REG_BANK_INST                ================ */
/* ================================================================================ */


/**
  * @brief This block is designed to be accessed internally by the EC via the register interface.  (EC_REG_BANK_INST)
  */

typedef struct {                                    /*!< (@ 0x4000FC00) EC_REG_BANK_INST Structure                             */
  __I  uint32_t  RESERVED;
  __IO uint32_t  AHB_ERROR_ADDRESS;                 /*!< (@ 0x4000FC04) AHB Error Address [0:0] AHB_ERR_ADDR, In priority
                                                         order:
                                                          1. AHB address is registered when an AHB error occurs on the
                                                          processor's AHB master port and the register value was
                                                          already 0. This way only the first address to generate an exception
                                                          is captured.
                                                          2. The processor can clear this register by writing any 32-bit
                                                          value to this register.                                              */
  __I  uint32_t  RESERVED1[3];
  __IO uint8_t   AHB_ERROR_CONTROL;                 /*!< (@ 0x4000FC14) AHB Error Control [0:0] AHB_ERROR_DISABLE, 0:
                                                         EC memory exceptions are enabled. 1: EC memory exceptions are
                                                          disabled.                                                            */
  __I  uint8_t   RESERVED2[3];
  __IO uint32_t  INTERRUPT_CONTROL;                 /*!< (@ 0x4000FC18) Interrupt Control [0:0] NVIC_EN (NVIC_EN) This
                                                         bit enables Alternate NVIC IRQ's Vectors. The Alternate NVIC
                                                          Vectors provides each interrupt event with a dedicated (direct)
                                                          NVIC vector.
                                                          0 = Alternate NVIC vectors disabled, 1= Alternate NVIC vectors
                                                          enabled                                                              */
  __IO uint32_t  ETM_TRACE_ENABLE;                  /*!< (@ 0x4000FC1C) ETM TRACE Enable [0:0] TRACE_EN (TRACE_EN) This
                                                         bit enables the ARM TRACE debug port (ETM/ITM). The Trace Debug
                                                          Interface pins are forced to the TRACE functions. 0 = ARM TRACE
                                                          port disabled, 1= ARM TRACE port enabled                             */

  union {
    __IO uint32_t  DEBUG_Enable;                    /*!< (@ 0x4000FC20) Debug Enable Register                                  */

    struct {
      __IO uint32_t  DEBUG_EN   :  1;               /*!< [0..0] DEBUG_EN (JTAG_EN) This bit enables the JTAG/SWD debug
                                                         port.
                                                          0= JTAG/SWD port disabled. JTAG/SWD cannot be enabled (i.e.,
                                                          the TRST# pin is ignored and the JTAG signals remain in their
                                                          non-JTAG state)
                                                          1= JTAG/SWD port enabled. A high on TRST# enables JTAG or SWD,
                                                          as determined by SWD_EN.                                             */
      __IO uint32_t  DEBUG_PIN_CFG:  2;             /*!< [1..2] This field determines which pins are affected by the
                                                         TRST# debug enable pin.
                                                          3=Reserved
                                                          2=The pins associated with the JTAG TCK and TMS switch to the
                                                          debug interface when TRST# is de-asserted high. The pins
                                                          associated with TDI and TDO remain controlled by the associated
                                                          GPIO. This setting should be used when the ARM Serial
                                                          Wire Debug (SWD) is required for debugging and the Serial Wire
                                                          Viewer is not required
                                                          1=The pins associated with the JTAG TCK, TMS and TDO switch
                                                          to the debug interface when TRST# i                                  */
      __IO uint32_t  DEBUG_PU_EN:  1;               /*!< [3..3] If this bit is set to '1b' internal pull-up resistors
                                                         are automatically enabled on the appropriate debugging port
                                                          wires whenever the debug port is enabled (the DEBUG_EN bit
                                                          in this register is '1b' and the JTAG_RST# pin is high). The
                                                          setting
                                                          of DEBUG_PIN_CFG determines which pins have pull-ups enabled
                                                          when the debug port is enabled.                                      */
    } DEBUG_Enable_b;                               /*!< [4] BitSize                                                           */
  };

  union {
    __IO uint32_t  OTP_LOCK;                        /*!< (@ 0x4000FC24) OTP Lock                                               */

    struct {
      __IO uint32_t  TEST       :  1;               /*!< [0..0] Test                                                           */
      __IO uint32_t  MCHIP_LOCK :  1;               /*!< [1..1] This bit controls access to Microchip region of the eFuse
                                                         memory, bytes 32 to 127. Once written, this bit becomes Read
                                                          Only.
                                                          If the JTAG_EN bit is 1 (enabled), the Private Key is inaccessible,
                                                          independent of the state of this bit.
                                                          1=The Microchip region is inaccessible (i.e, always returns
                                                          0 or 1 for every bit); 0=The Microchip region is accessible.
                                                                                                                               */
      __IO uint32_t  PRIVATE_KEY_LOCK:  1;          /*!< [2..2] This bit controls access to Private Key region of the
                                                         eFuse memory, bytes 0 to 31. Once written, this bit becomes
                                                          Read Only.
                                                          If the JTAG_EN bit is 1 (enabled), the Private Key is inaccessible,
                                                          independent of the state of this bit.
                                                          1=The Private Key is inaccessible (i.e, always returns 0 or
                                                          1 for every bit); 0=The Private Key is accessible.                   */
      __IO uint32_t  USER_OTP_LOCK:  1;             /*!< [3..3] This bit controls access to the User region of the eFuse
                                                         memory, bytes 192 to 511. Once written, this bit becomes Read
                                                          Only.
                                                          If the JTAG_EN bit is 1 (enabled), the User region is inaccessible,
                                                          independent of the state of this bit.
                                                          1=The User region is inaccessible (i.e, always returns 0 or
                                                          1 for every bit); 0=The User region is accessible                    */
      __IO uint32_t  PUBLIC_KEY_LOCK:  1;           /*!< [4..4] This bit controls access to the Public Key region of
                                                         the eFuse memory, bytes 128 to 191. Once written, this bit becomes
                                                          Read Only.
                                                          If the JTAG_EN bit is 1 (enabled), the Public Key is inaccessible,
                                                          independent of the state of this bit.
                                                          1=The Public Key is inaccessible (i.e, always returns 0 or
                                                          1 for every bit); 0=The Public Key is accessible                     */
    } OTP_LOCK_b;                                   /*!< [5] BitSize                                                           */
  };
  __IO uint32_t  WDT_EVENT_COUNT;                   /*!< (@ 0x4000FC28) WDT Event Count [3:0] WDT_COUNT (WDT_COUNT) These
                                                         EC R/W bits are cleared to 0 on VCC1 POR, but not on a WDT.
                                                          Note: This field is written by Boot ROM firmware to indicate
                                                          the number of times a WDT fired before loading a good EC code
                                                          image.                                                               */

  union {
    __IO uint32_t  AES_HASH_BYTE_SWAP_CONTROL;      /*!< (@ 0x4000FC2C) AES HASH Byte Swap Control Register.                   */

    struct {
      __I  uint32_t  INPUT_BYTE_SWAP_ENABLE:  1;    /*!< [0..0] Used to enable byte swap on a DWORD during AHB read from
                                                         AES / HASH block: 1=Enable; 0=Disable.                                */
      __IO uint32_t  OUTPUT_BYTE_SWAP_ENABLE:  1;   /*!< [1..1] Used to enable byte swap on a DWORD during AHB write
                                                         from AES / HASH block: 1=Enable; 0=Disable.                           */
      __IO uint32_t  INPUT_BLOCK_SWAP_ENABLE:  3;   /*!< [2..4] Used to enable word swap on a DWORD during AHB read from
                                                         AES / HASH block
                                                          4=Swap 32-bit doublewords in 128-byte blocks
                                                          3=Swap doublewords in 64-byte blocks. Useful for SHA-256. Bus
                                                          references issued in the order 0x3C, 0x38, 0x34, 0x30, 0x2C,
                                                          0x28, 0x24, 0x20, 0x1C, 0x18, 0x14, 0x10, 0xC, 0x8, 0x4, 0x0,...
                                                          2=Swap doublewords in 16-byte blocks. Useful for AES. Bus references
                                                          issued in the order 0xC, 0x8, 0x4, 0x0, 0x1C, 0x18,...
                                                          1=Swap doublewords in 8-byte blocks. Useful for SHA-512, which
                                                          works on 64-                                                         */
      __IO uint32_t  OUTPUT_BLOCK_SWAP_ENABLE:  3;  /*!< [5..7] Used to enable word swap on a DWORD during AHB write
                                                         from AES / HASH block
                                                          4=Swap 32-bit doublewords in 128-byte blocks
                                                          3=Swap doublewords in 64-byte blocks. Useful for SHA-256. Bus
                                                          references issued in the order 0x3C, 0x38, 0x34, 0x30, 0x2C,
                                                          0x28, 0x24, 0x20, 0x1C, 0x18, 0x14, 0x10, 0xC, 0x8, 0x4, 0x0,...
                                                          2=Swap doublewords in 16-byte blocks. Useful for AES. Bus references
                                                          issued in the order 0xC, 0x8, 0x4, 0x0, 0x1C, 0x18,...
                                                          1=Swap doublewords in 8-byte blocks. Useful for SHA-512, which
                                                          works on 64                                                          */
    } AES_HASH_BYTE_SWAP_CONTROL_b;                 /*!< [8] BitSize                                                           */
  };
  __I  uint32_t  RESERVED3[4];

  union {
    __IO uint32_t  PECI_DISABLE;                    /*!< (@ 0x4000FC40) PECI Disable                                           */

    struct {
      __O  uint32_t  PECI_DISABLE:  1;              /*!< [0..0] When this bit is asserted ('1'), it disables the PECI
                                                         pads to reduce leakage.                                               */
    } PECI_DISABLE_b;                               /*!< [1] BitSize                                                           */
  };
  __I  uint32_t  RESERVED4[6];

  union {
    __IO uint32_t  CRYPTO_SOFT_RESET;               /*!< (@ 0x4000FC5C) System Shutdown Reset                                  */

    struct {
      __O  uint32_t  RNG_SOFT_RESET:  1;            /*!< [0..0] When this bit is asserted ('1'), the Random Number Generator
                                                         block is reset.                                                       */
      __O  uint32_t  PUBLIC_KEY_SOFT_RESET:  1;     /*!< [1..1] When this bit is asserted ('1'), the Public Key block
                                                         is reset.                                                             */
      __O  uint32_t  AES_HASH_SOFT_RESET:  1;       /*!< [2..2] When this bit is asserted ('1'), the AES and Hash blocks
                                                         are reset.                                                            */
    } CRYPTO_SOFT_RESET_b;                          /*!< [3] BitSize                                                           */
  };
  __I  uint32_t  RESERVED5;

  union {
    __IO uint32_t  GPIO_BANK_POWER;                 /*!< (@ 0x4000FC64) GPIO Bank Power Register                               */

    struct {
      __IO uint32_t  VTR_LEVEL1 :  1;               /*!< [0..0] Voltage value on VTR1. This bit is set by hardware after
                                                         a VTR Power On Reset, but may be overridden by software.
                                                          It must be set by software if the VTR power rail is not active
                                                          when RESET_SYS is de-asserted. Write access is determined by
                                                          bit 7.
                                                          1=VTR1 is powered by 3.3V
                                                          0=VTR1 is powered by 1.8V.                                           */
      __IO uint32_t  VTR_LEVEL2 :  1;               /*!< [1..1] Voltage value on VTR2. This bit is set by hardware after
                                                         a VTR Power On Reset, but may be overridden by software.
                                                          It must be set by software if the VTR power rail is not active
                                                          when RESET_SYS is de-asserted. Write access is determined by
                                                          bit 7.
                                                          1=VTR2 is powered by 3.3V
                                                          0=VTR2 is powered by 1.8V.                                           */
      __IO uint32_t  VTR_LEVEL3 :  1;               /*!< [2..2] Voltage value on VTR3. This bit is set by hardware after
                                                         a VTR Power On Reset, but may be overridden by software.
                                                          It must be set by software if the VTR power rail is not active
                                                          when RESET_SYS is de-asserted. Write access is determined by
                                                          bit 7.
                                                          1=VTR3 is powered by 3.3V
                                                          0=VTR3 is powered by 1.8V.                                           */
           uint32_t             :  4;
      __IO uint32_t  GPIO_BANK_POWER_LOCK:  1;      /*!< [7..7] GPIO Bank Power Lock. 0: VTR_LEVEL bits[2:0] and GPIO
                                                         Bank Power Lock bit are R/W
                                                          1 = VTR_LEVEL bits[2:0] and GPIO Bank Power Lock bit are Read
                                                          Only.                                                                */
    } GPIO_BANK_POWER_b;                            /*!< [8] BitSize                                                           */
  };
  __I  uint32_t  RESERVED6[2];

  union {
    __IO uint32_t  JTAG_MASTER_CFG;                 /*!< (@ 0x4000FC70) JTAG Master Configuration Register                     */

    struct {
      __IO uint32_t  JTM_CLK    :  3;               /*!< [0..2] This field determines the JTAG Master clock rate, derived
                                                         from the 48MHz master clock.
                                                          7=375KHz; 6=750KHz; 5=1.5Mhz; 4=3Mhz; 3=6Mhz; 2=12Mhz; 1=24MHz;
                                                          0=Reserved.                                                          */
      __IO uint32_t  MASTER_SLAVE:  1;              /*!< [3..3] This bit controls the direction of the JTAG port. 1=The
                                                         JTAG Port is configured as a Master
                                                          0=The JTAG Port is configures as a Slave.                            */
    } JTAG_MASTER_CFG_b;                            /*!< [4] BitSize                                                           */
  };

  union {
    __I  uint32_t  JTAG_MASTER_STS;                 /*!< (@ 0x4000FC74) JTAG Master Status Register                            */

    struct {
      __I  uint32_t  JTM_DONE   :  1;               /*!< [0..0] This bit is set to '1b' when the JTAG Master Command
                                                         Register is written. It becomes '0b' when shifting has completed.
                                                          Software can poll this bit to determine when a command has
                                                          completed and it is therefore safe to remove the data in the
                                                          JTAG Master TDO
                                                          Register and load new data into the JTAG Master TMS Register
                                                          and the JTAG Master TDI Register.                                    */
    } JTAG_MASTER_STS_b;                            /*!< [1] BitSize                                                           */
  };

  union {
    __IO uint32_t  JTAG_MASTER_TDO;                 /*!< (@ 0x4000FC78) JTAG Master TDO Register                               */

    struct {
      __IO uint32_t  JTM_TDO    : 32;               /*!< [0..31] When the JTAG Master Command Register is written, from
                                                         1 to 32 bits are shifted into this register, starting with bit
                                                          0,
                                                          from the JTAG_TDO pin. Shifting is at the rate determined by
                                                          the JTM_CLK field in the JTAG Master Configuration Register.
                                                                                                                               */
    } JTAG_MASTER_TDO_b;                            /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  JTAG_MASTER_TDI;                 /*!< (@ 0x4000FC7C) JTAG Master TDI Register                               */

    struct {
      __IO uint32_t  JTM_TDI    : 32;               /*!< [0..31] When the JTAG Master Command Register is written, from
                                                         1 to 32 bits are shifted out of this register, starting with
                                                          bit 0,
                                                          onto the JTAG_TDI pin. Shifting is at the rate determined by
                                                          the JTM_CLK field in the JTAG Master Configuration Register.
                                                                                                                               */
    } JTAG_MASTER_TDI_b;                            /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  JTAG_MASTER_TMS;                 /*!< (@ 0x4000FC80) JTAG Master TMS Register                               */

    struct {
      __IO uint32_t  JTM_TMS    : 32;               /*!< [0..31] When the JTAG Master Command Register is written, from
                                                         1 to 32 bits are shifted out of this register, starting with
                                                          bit 0,
                                                          onto the JTAG_TMS pin. Shifting is at the rate determined by
                                                          the JTM_CLK field in the JTAG Master Configuration Register.
                                                                                                                               */
    } JTAG_MASTER_TMS_b;                            /*!< [32] BitSize                                                          */
  };

  union {
    __IO uint32_t  JTAG_MASTER_CMD;                 /*!< (@ 0x4000FC84) JTAG Master Command Register                           */

    struct {
      __IO uint32_t  JTM_COUNT  :  5;               /*!< [0..4] If the JTAG Port is configured as a Master, writing this
                                                         register starts clocking and shifting on the JTAG port. The
                                                          JTAG
                                                          Master port will shift JTM_COUNT+1 times, so writing a '0h'
                                                          will shift 1 bit, and writing '31h' will shift 32 bits. The
                                                          signal JTAG_CLK
                                                          will cycle JTM_COUNT+1 times. The contents of the JTAG Master
                                                          TMS Register and the JTAG Master TDI Register will be shifted
                                                          out on
                                                          the falling edge of JTAG_CLK and the.JTAG Master TDO Register
                                                          will get shifted in on the rising edge of JTAG_CLK.
                                                          If t                                                                 */
    } JTAG_MASTER_CMD_b;                            /*!< [5] BitSize                                                           */
  };
} EC_REG_BANK_INST_Type;


/* ================================================================================ */
/* ================                   EFUSE_INST                   ================ */
/* ================================================================================ */


/**
  * @brief The eFUSE block provides a means of programming and accessing the eFUSE bits.  (EFUSE_INST)
  */

typedef struct {                                    /*!< (@ 0x40082000) EFUSE_INST Structure                                   */

  union {
    __IO uint32_t  CONTROL;                         /*!< (@ 0x40082000) eFUSE CONTROL Register                                 */

    struct {
      __O  uint32_t  ENABLE     :  1;               /*!< [0..0] Block enable: 1=block is enabled for operation; 0=block
                                                         is disabled and in lowest power state.                                */
      __IO uint32_t  RESET      :  1;               /*!< [1..1] Block reset: 1=Block is reset; 0=Normal operation. This
                                                         bit self-clears and always reads back 0.                              */
      __IO uint32_t  EXT_PGM    :  1;               /*!< [2..2] External programming enable: 1=eFUSE programming is done
                                                         via external pin interface 0=Manual/Normal mode.
                                                          eFUSE programming is done via this block's register set.             */
      __IO uint32_t  FSOURCE_EN_PRGM:  1;           /*!< [3..3] FSOURCE pin enable for programming: 1=FSOURCE switch
                                                         logic connects eFUSE FSOURCE pin to a power pad for PROGRAM
                                                          mode.
                                                          Only set this bit when FSOURCE_EN_READ bit is already 0 to
                                                          avoid shorting the power pad to ground;
                                                          0=FSOURCE switch logic isolates eFUSE FSOURCE pin from power
                                                          pad.                                                                 */
      __IO uint32_t  FSOURCE_EN_READ:  1;           /*!< [4..4] FSOURCE pin enable for reading: 1=FSOURCE switch logic
                                                         connects eFUSE FSOURCE pin to a power pad for read mode.
                                                          Only set this bit when FSOURCE_EN_PRGM bit is already 0 to
                                                          avoid shorting the power pad to ground;
                                                          0=FSOURCE switch logic isolates eFUSE FSOURCE pin from ground.
                                                                                                                               */
    } CONTROL_b;                                    /*!< [5] BitSize                                                           */
  };

  union {
    __IO uint16_t  MANUAL_CONTROL;                  /*!< (@ 0x40082004) Manual Control Register                                */

    struct {
      __O  uint16_t  MAN_ENABLE :  1;               /*!< [0..0] Manual mode enable bit: 1=Manual mode is enabled and
                                                         this register interfaces to the eFUSE;
                                                          0=Normal mode, internal controller interfaces to eFUSE IP.
                                                          This bit only takes affect when REG_CTRL.EXT_PRGM bit is 0.
                                                                                                                               */
      __IO uint16_t  IP_CS      :  1;               /*!< [1..1] eFUSE chip select (CS) pin: 1=eFUSE is enabled for PROGRAM/READ
                                                         modes; 0=eFUSE is disabled and in low power state.                    */
      __IO uint16_t  IP_PRGM_EN :  1;               /*!< [2..2] eFUSE program enable. Can also be considered the write
                                                         signal: 1=eFUSE is programming; 0=eFUSE is in read mode.              */
      __IO uint16_t  IP_PRCHG   :  1;               /*!< [3..3] eFUSE precharge: 1=outputs are being precharged; 0=outputs
                                                         are not precharged.                                                   */
      __IO uint16_t  IP_SENSE_PULSE:  1;            /*!< [4..4] eFUSE sense, outputs are valid on falling edge of this
                                                         bit.                                                                  */
      __IO uint16_t  IP_OE      :  1;               /*!< [5..5] eFUSE output enable. The IP might tri-state at various
                                                         times, so this bit isolates the outputs to avoid potential crowbar.
                                                          1=eFUSE outputs enabled for read; 0=eFUSE outputs isolated
                                                                                                                               */
    } MANUAL_CONTROL_b;                             /*!< [6] BitSize                                                           */
  };

  union {
    __IO uint16_t  MANUAL_MODE_ADDRESS;             /*!< (@ 0x40082006) MANUAL MODE ADDRESS REGISTER                           */

    struct {
      __IO uint16_t  IP_ADDR_LO : 10;               /*!< [0..9] Manual mode address, selecting the bit address within
                                                         a 1K bit block.                                                       */
      __IO uint16_t  IP_ADDR_HI :  2;               /*!< [10..11] Manual mode address, selecting a 1K bit block of eFuse
                                                         data                                                                  */
    } MANUAL_MODE_ADDRESS_b;                        /*!< [12] BitSize                                                          */
  };
  __I  uint32_t  RESERVED;

  union {
    __IO uint32_t  MANUAL_MODE_DATA;                /*!< (@ 0x4008200C) MANUAL MODE DATA REGISTER                              */

    struct {
      __IO uint32_t  IP_DATA    : 16;               /*!< [0..15] Manual mode data: This field connects to the eFUSE data
                                                         output pins.                                                          */
    } MANUAL_MODE_DATA_b;                           /*!< [16] BitSize                                                          */
  };
  __IO uint32_t  EFUSE_MEMORY_DW_[128];             /*!< (@ 0x40082010) 512 Bytes of EFUSE Memory (IP_MEM) Represented
                                                         in 128 DW chunks: eFUSE memory read-back data. Access to this
                                                          region depends on the operating mode: NORMAL MODE: Reading any
                                                          of the bytes
                                                          starting at this base will automatically start the controller
                                                          to sequence all eFUSE signals to generate read data. Wait cycles
                                                          added
                                                          to the read cycle as appropriate. MANUAL MODE: Refer to the
                                                          manual mode section for the proper procedure for accessing data
                                                          in this mode.
                                                          See REG_MAN_CTRL.MAN_EN and REG_CTRL.                                */
} EFUSE_INST_Type;


/* --------------------  End of section using anonymous unions  ------------------- */
#if defined(__CC_ARM)
  #pragma pop
#elif defined(__ICCARM__)
  /* leave anonymous unions enabled */
#elif defined(__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined(__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined(__TASKING__)
  #pragma warning restore
#else
  #warning Not supported compiler type
#endif



/* ================================================================================ */
/* ================        struct 'PCR_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ---------------------------  PCR_INST_SYS_SLP_CNTRL  --------------------------- */
#define PCR_INST_SYS_SLP_CNTRL_SLEEP_MODE_Pos (0UL)                     /*!< PCR_INST SYS_SLP_CNTRL: SLEEP_MODE (Bit 0)                  */
#define PCR_INST_SYS_SLP_CNTRL_SLEEP_MODE_Msk (0x1UL)                   /*!< PCR_INST SYS_SLP_CNTRL: SLEEP_MODE (Bitfield-Mask: 0x01)    */
#define PCR_INST_SYS_SLP_CNTRL_TEST_Pos       (2UL)                     /*!< PCR_INST SYS_SLP_CNTRL: TEST (Bit 2)                        */
#define PCR_INST_SYS_SLP_CNTRL_TEST_Msk       (0x4UL)                   /*!< PCR_INST SYS_SLP_CNTRL: TEST (Bitfield-Mask: 0x01)          */
#define PCR_INST_SYS_SLP_CNTRL_SLEEP_ALL_Pos  (3UL)                     /*!< PCR_INST SYS_SLP_CNTRL: SLEEP_ALL (Bit 3)                   */
#define PCR_INST_SYS_SLP_CNTRL_SLEEP_ALL_Msk  (0x8UL)                   /*!< PCR_INST SYS_SLP_CNTRL: SLEEP_ALL (Bitfield-Mask: 0x01)     */

/* ---------------------------  PCR_INST_PROC_CLK_CNTRL  -------------------------- */
#define PCR_INST_PROC_CLK_CNTRL_PROCESSOR_CLOCK_DIVIDE_Pos (0UL)        /*!< PCR_INST PROC_CLK_CNTRL: PROCESSOR_CLOCK_DIVIDE (Bit 0)     */
#define PCR_INST_PROC_CLK_CNTRL_PROCESSOR_CLOCK_DIVIDE_Msk (0xffUL)     /*!< PCR_INST PROC_CLK_CNTRL: PROCESSOR_CLOCK_DIVIDE (Bitfield-Mask: 0xff) */

/* ---------------------------  PCR_INST_SLOW_CLK_CNTRL  -------------------------- */
#define PCR_INST_SLOW_CLK_CNTRL_SLOW_CLOCK_DIVIDE_Pos (0UL)             /*!< PCR_INST SLOW_CLK_CNTRL: SLOW_CLOCK_DIVIDE (Bit 0)          */
#define PCR_INST_SLOW_CLK_CNTRL_SLOW_CLOCK_DIVIDE_Msk (0x3ffUL)         /*!< PCR_INST SLOW_CLK_CNTRL: SLOW_CLOCK_DIVIDE (Bitfield-Mask: 0x3ff) */

/* -------------------------------  PCR_INST_OSC_ID  ------------------------------ */
#define PCR_INST_OSC_ID_TEST_Pos              (0UL)                     /*!< PCR_INST OSC_ID: TEST (Bit 0)                               */
#define PCR_INST_OSC_ID_TEST_Msk              (0xffUL)                  /*!< PCR_INST OSC_ID: TEST (Bitfield-Mask: 0xff)                 */
#define PCR_INST_OSC_ID_PLL_LOCK_Pos          (8UL)                     /*!< PCR_INST OSC_ID: PLL_LOCK (Bit 8)                           */
#define PCR_INST_OSC_ID_PLL_LOCK_Msk          (0x100UL)                 /*!< PCR_INST OSC_ID: PLL_LOCK (Bitfield-Mask: 0x01)             */

/* --------------------------  PCR_INST_PCR_PWR_RST_STS  -------------------------- */
#define PCR_INST_PCR_PWR_RST_STS_VCC_PWRGD_STATUS_Pos (2UL)             /*!< PCR_INST PCR_PWR_RST_STS: VCC_PWRGD_STATUS (Bit 2)          */
#define PCR_INST_PCR_PWR_RST_STS_VCC_PWRGD_STATUS_Msk (0x4UL)           /*!< PCR_INST PCR_PWR_RST_STS: VCC_PWRGD_STATUS (Bitfield-Mask: 0x01) */
#define PCR_INST_PCR_PWR_RST_STS_RESET_HOST_STATUS_Pos (3UL)            /*!< PCR_INST PCR_PWR_RST_STS: RESET_HOST_STATUS (Bit 3)         */
#define PCR_INST_PCR_PWR_RST_STS_RESET_HOST_STATUS_Msk (0x8UL)          /*!< PCR_INST PCR_PWR_RST_STS: RESET_HOST_STATUS (Bitfield-Mask: 0x01) */
#define PCR_INST_PCR_PWR_RST_STS_VBAT_RESET_STATUS_Pos (5UL)            /*!< PCR_INST PCR_PWR_RST_STS: VBAT_RESET_STATUS (Bit 5)         */
#define PCR_INST_PCR_PWR_RST_STS_VBAT_RESET_STATUS_Msk (0x20UL)         /*!< PCR_INST PCR_PWR_RST_STS: VBAT_RESET_STATUS (Bitfield-Mask: 0x01) */
#define PCR_INST_PCR_PWR_RST_STS_VTR_RESET_STATUS_Pos (6UL)             /*!< PCR_INST PCR_PWR_RST_STS: VTR_RESET_STATUS (Bit 6)          */
#define PCR_INST_PCR_PWR_RST_STS_VTR_RESET_STATUS_Msk (0x40UL)          /*!< PCR_INST PCR_PWR_RST_STS: VTR_RESET_STATUS (Bitfield-Mask: 0x01) */
#define PCR_INST_PCR_PWR_RST_STS_JTAG_RESET_STATUS_Pos (7UL)            /*!< PCR_INST PCR_PWR_RST_STS: JTAG_RESET_STATUS (Bit 7)         */
#define PCR_INST_PCR_PWR_RST_STS_JTAG_RESET_STATUS_Msk (0x80UL)         /*!< PCR_INST PCR_PWR_RST_STS: JTAG_RESET_STATUS (Bitfield-Mask: 0x01) */
#define PCR_INST_PCR_PWR_RST_STS__32K_ACTIVE_Pos (10UL)                 /*!< PCR_INST PCR_PWR_RST_STS: _32K_ACTIVE (Bit 10)              */
#define PCR_INST_PCR_PWR_RST_STS__32K_ACTIVE_Msk (0x400UL)              /*!< PCR_INST PCR_PWR_RST_STS: _32K_ACTIVE (Bitfield-Mask: 0x01) */
#define PCR_INST_PCR_PWR_RST_STS_PCICLK_ACTIVE_Pos (11UL)               /*!< PCR_INST PCR_PWR_RST_STS: PCICLK_ACTIVE (Bit 11)            */
#define PCR_INST_PCR_PWR_RST_STS_PCICLK_ACTIVE_Msk (0x800UL)            /*!< PCR_INST PCR_PWR_RST_STS: PCICLK_ACTIVE (Bitfield-Mask: 0x01) */
#define PCR_INST_PCR_PWR_RST_STS_ESPI_CLK_ACTIVE_Pos (12UL)             /*!< PCR_INST PCR_PWR_RST_STS: ESPI_CLK_ACTIVE (Bit 12)          */
#define PCR_INST_PCR_PWR_RST_STS_ESPI_CLK_ACTIVE_Msk (0x1000UL)         /*!< PCR_INST PCR_PWR_RST_STS: ESPI_CLK_ACTIVE (Bitfield-Mask: 0x01) */

/* ---------------------------  PCR_INST_PWR_RST_CNTRL  --------------------------- */
#define PCR_INST_PWR_RST_CNTRL_PWR_INV_Pos    (0UL)                     /*!< PCR_INST PWR_RST_CNTRL: PWR_INV (Bit 0)                     */
#define PCR_INST_PWR_RST_CNTRL_PWR_INV_Msk    (0x1UL)                   /*!< PCR_INST PWR_RST_CNTRL: PWR_INV (Bitfield-Mask: 0x01)       */
#define PCR_INST_PWR_RST_CNTRL_HOST_RESET_SELECT_Pos (8UL)              /*!< PCR_INST PWR_RST_CNTRL: HOST_RESET_SELECT (Bit 8)           */
#define PCR_INST_PWR_RST_CNTRL_HOST_RESET_SELECT_Msk (0x100UL)          /*!< PCR_INST PWR_RST_CNTRL: HOST_RESET_SELECT (Bitfield-Mask: 0x01) */

/* ------------------------------  PCR_INST_SYS_RST  ------------------------------ */
#define PCR_INST_SYS_RST_SOFT_SYS_RESET_Pos   (8UL)                     /*!< PCR_INST SYS_RST: SOFT_SYS_RESET (Bit 8)                    */
#define PCR_INST_SYS_RST_SOFT_SYS_RESET_Msk   (0x100UL)                 /*!< PCR_INST SYS_RST: SOFT_SYS_RESET (Bitfield-Mask: 0x01)      */

/* ------------------------------  PCR_INST_SLP_EN_0  ----------------------------- */
#define PCR_INST_SLP_EN_0_JTAG_STAP_SLP_EN_Pos (0UL)                    /*!< PCR_INST SLP_EN_0: JTAG_STAP_SLP_EN (Bit 0)                 */
#define PCR_INST_SLP_EN_0_JTAG_STAP_SLP_EN_Msk (0x1UL)                  /*!< PCR_INST SLP_EN_0: JTAG_STAP_SLP_EN (Bitfield-Mask: 0x01)   */
#define PCR_INST_SLP_EN_0_EFUSE_SLP_EN_Pos    (1UL)                     /*!< PCR_INST SLP_EN_0: EFUSE_SLP_EN (Bit 1)                     */
#define PCR_INST_SLP_EN_0_EFUSE_SLP_EN_Msk    (0x2UL)                   /*!< PCR_INST SLP_EN_0: EFUSE_SLP_EN (Bitfield-Mask: 0x01)       */

/* ------------------------------  PCR_INST_SLP_EN_1  ----------------------------- */
#define PCR_INST_SLP_EN_1_INT_SLP_EN_Pos      (0UL)                     /*!< PCR_INST SLP_EN_1: INT_SLP_EN (Bit 0)                       */
#define PCR_INST_SLP_EN_1_INT_SLP_EN_Msk      (0x1UL)                   /*!< PCR_INST SLP_EN_1: INT_SLP_EN (Bitfield-Mask: 0x01)         */
#define PCR_INST_SLP_EN_1_TACH0_SLP_EN_Pos    (2UL)                     /*!< PCR_INST SLP_EN_1: TACH0_SLP_EN (Bit 2)                     */
#define PCR_INST_SLP_EN_1_TACH0_SLP_EN_Msk    (0x4UL)                   /*!< PCR_INST SLP_EN_1: TACH0_SLP_EN (Bitfield-Mask: 0x01)       */
#define PCR_INST_SLP_EN_1_PWM0_SLP_EN_Pos     (4UL)                     /*!< PCR_INST SLP_EN_1: PWM0_SLP_EN (Bit 4)                      */
#define PCR_INST_SLP_EN_1_PWM0_SLP_EN_Msk     (0x10UL)                  /*!< PCR_INST SLP_EN_1: PWM0_SLP_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_SLP_EN_1_PMC_SLP_EN_Pos      (5UL)                     /*!< PCR_INST SLP_EN_1: PMC_SLP_EN (Bit 5)                       */
#define PCR_INST_SLP_EN_1_PMC_SLP_EN_Msk      (0x20UL)                  /*!< PCR_INST SLP_EN_1: PMC_SLP_EN (Bitfield-Mask: 0x01)         */
#define PCR_INST_SLP_EN_1_DMA_SLP_EN_Pos      (6UL)                     /*!< PCR_INST SLP_EN_1: DMA_SLP_EN (Bit 6)                       */
#define PCR_INST_SLP_EN_1_DMA_SLP_EN_Msk      (0x40UL)                  /*!< PCR_INST SLP_EN_1: DMA_SLP_EN (Bitfield-Mask: 0x01)         */
#define PCR_INST_SLP_EN_1_TFDP_SLP_EN_Pos     (7UL)                     /*!< PCR_INST SLP_EN_1: TFDP_SLP_EN (Bit 7)                      */
#define PCR_INST_SLP_EN_1_TFDP_SLP_EN_Msk     (0x80UL)                  /*!< PCR_INST SLP_EN_1: TFDP_SLP_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_SLP_EN_1_PROCESSOR_SLP_EN_Pos (8UL)                    /*!< PCR_INST SLP_EN_1: PROCESSOR_SLP_EN (Bit 8)                 */
#define PCR_INST_SLP_EN_1_PROCESSOR_SLP_EN_Msk (0x100UL)                /*!< PCR_INST SLP_EN_1: PROCESSOR_SLP_EN (Bitfield-Mask: 0x01)   */
#define PCR_INST_SLP_EN_1_WDT_SLP_EN_Pos      (9UL)                     /*!< PCR_INST SLP_EN_1: WDT_SLP_EN (Bit 9)                       */
#define PCR_INST_SLP_EN_1_WDT_SLP_EN_Msk      (0x200UL)                 /*!< PCR_INST SLP_EN_1: WDT_SLP_EN (Bitfield-Mask: 0x01)         */
#define PCR_INST_SLP_EN_1_SMB0_SLP_EN_Pos     (10UL)                    /*!< PCR_INST SLP_EN_1: SMB0_SLP_EN (Bit 10)                     */
#define PCR_INST_SLP_EN_1_SMB0_SLP_EN_Msk     (0x400UL)                 /*!< PCR_INST SLP_EN_1: SMB0_SLP_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_SLP_EN_1_TACH1_SLP_EN_Pos    (11UL)                    /*!< PCR_INST SLP_EN_1: TACH1_SLP_EN (Bit 11)                    */
#define PCR_INST_SLP_EN_1_TACH1_SLP_EN_Msk    (0x800UL)                 /*!< PCR_INST SLP_EN_1: TACH1_SLP_EN (Bitfield-Mask: 0x01)       */
#define PCR_INST_SLP_EN_1_TACH2_SLP_EN_Pos    (12UL)                    /*!< PCR_INST SLP_EN_1: TACH2_SLP_EN (Bit 12)                    */
#define PCR_INST_SLP_EN_1_TACH2_SLP_EN_Msk    (0x1000UL)                /*!< PCR_INST SLP_EN_1: TACH2_SLP_EN (Bitfield-Mask: 0x01)       */
#define PCR_INST_SLP_EN_1_PWM1_SLP_EN_Pos     (20UL)                    /*!< PCR_INST SLP_EN_1: PWM1_SLP_EN (Bit 20)                     */
#define PCR_INST_SLP_EN_1_PWM1_SLP_EN_Msk     (0x100000UL)              /*!< PCR_INST SLP_EN_1: PWM1_SLP_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_SLP_EN_1_PWM2_SLP_EN_Pos     (21UL)                    /*!< PCR_INST SLP_EN_1: PWM2_SLP_EN (Bit 21)                     */
#define PCR_INST_SLP_EN_1_PWM2_SLP_EN_Msk     (0x200000UL)              /*!< PCR_INST SLP_EN_1: PWM2_SLP_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_SLP_EN_1_PWM3_SLP_EN_Pos     (22UL)                    /*!< PCR_INST SLP_EN_1: PWM3_SLP_EN (Bit 22)                     */
#define PCR_INST_SLP_EN_1_PWM3_SLP_EN_Msk     (0x400000UL)              /*!< PCR_INST SLP_EN_1: PWM3_SLP_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_SLP_EN_1_PWM4_SLP_EN_Pos     (23UL)                    /*!< PCR_INST SLP_EN_1: PWM4_SLP_EN (Bit 23)                     */
#define PCR_INST_SLP_EN_1_PWM4_SLP_EN_Msk     (0x800000UL)              /*!< PCR_INST SLP_EN_1: PWM4_SLP_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_SLP_EN_1_PWM5_SLP_EN_Pos     (24UL)                    /*!< PCR_INST SLP_EN_1: PWM5_SLP_EN (Bit 24)                     */
#define PCR_INST_SLP_EN_1_PWM5_SLP_EN_Msk     (0x1000000UL)             /*!< PCR_INST SLP_EN_1: PWM5_SLP_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_SLP_EN_1_PWM6_SLP_EN_Pos     (25UL)                    /*!< PCR_INST SLP_EN_1: PWM6_SLP_EN (Bit 25)                     */
#define PCR_INST_SLP_EN_1_PWM6_SLP_EN_Msk     (0x2000000UL)             /*!< PCR_INST SLP_EN_1: PWM6_SLP_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_SLP_EN_1_PWM7_SLP_EN_Pos     (26UL)                    /*!< PCR_INST SLP_EN_1: PWM7_SLP_EN (Bit 26)                     */
#define PCR_INST_SLP_EN_1_PWM7_SLP_EN_Msk     (0x4000000UL)             /*!< PCR_INST SLP_EN_1: PWM7_SLP_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_SLP_EN_1_PWM8_SLP_EN_Pos     (27UL)                    /*!< PCR_INST SLP_EN_1: PWM8_SLP_EN (Bit 27)                     */
#define PCR_INST_SLP_EN_1_PWM8_SLP_EN_Msk     (0x8000000UL)             /*!< PCR_INST SLP_EN_1: PWM8_SLP_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_SLP_EN_1_EC_REG_BANK_SLP_EN_Pos (29UL)                 /*!< PCR_INST SLP_EN_1: EC_REG_BANK_SLP_EN (Bit 29)              */
#define PCR_INST_SLP_EN_1_EC_REG_BANK_SLP_EN_Msk (0x20000000UL)         /*!< PCR_INST SLP_EN_1: EC_REG_BANK_SLP_EN (Bitfield-Mask: 0x01) */
#define PCR_INST_SLP_EN_1_TIMER16_0_SLP_EN_Pos (30UL)                   /*!< PCR_INST SLP_EN_1: TIMER16_0_SLP_EN (Bit 30)                */
#define PCR_INST_SLP_EN_1_TIMER16_0_SLP_EN_Msk (0x40000000UL)           /*!< PCR_INST SLP_EN_1: TIMER16_0_SLP_EN (Bitfield-Mask: 0x01)   */
#define PCR_INST_SLP_EN_1_TIMER16_1_SLP_EN_Pos (31UL)                   /*!< PCR_INST SLP_EN_1: TIMER16_1_SLP_EN (Bit 31)                */
#define PCR_INST_SLP_EN_1_TIMER16_1_SLP_EN_Msk (0x80000000UL)           /*!< PCR_INST SLP_EN_1: TIMER16_1_SLP_EN (Bitfield-Mask: 0x01)   */

/* ------------------------------  PCR_INST_SLP_EN_2  ----------------------------- */
#define PCR_INST_SLP_EN_2_UART_0_SLP_EN_Pos   (1UL)                     /*!< PCR_INST SLP_EN_2: UART_0_SLP_EN (Bit 1)                    */
#define PCR_INST_SLP_EN_2_UART_0_SLP_EN_Msk   (0x2UL)                   /*!< PCR_INST SLP_EN_2: UART_0_SLP_EN (Bitfield-Mask: 0x01)      */
#define PCR_INST_SLP_EN_2_UART_1_SLP_EN_Pos   (2UL)                     /*!< PCR_INST SLP_EN_2: UART_1_SLP_EN (Bit 2)                    */
#define PCR_INST_SLP_EN_2_UART_1_SLP_EN_Msk   (0x4UL)                   /*!< PCR_INST SLP_EN_2: UART_1_SLP_EN (Bitfield-Mask: 0x01)      */
#define PCR_INST_SLP_EN_2_GLBL_CFG_SLP_EN_Pos (12UL)                    /*!< PCR_INST SLP_EN_2: GLBL_CFG_SLP_EN (Bit 12)                 */
#define PCR_INST_SLP_EN_2_GLBL_CFG_SLP_EN_Msk (0x1000UL)                /*!< PCR_INST SLP_EN_2: GLBL_CFG_SLP_EN (Bitfield-Mask: 0x01)    */
#define PCR_INST_SLP_EN_2_RTC_SLP_EN_Pos      (18UL)                    /*!< PCR_INST SLP_EN_2: RTC_SLP_EN (Bit 18)                      */
#define PCR_INST_SLP_EN_2_RTC_SLP_EN_Msk      (0x40000UL)               /*!< PCR_INST SLP_EN_2: RTC_SLP_EN (Bitfield-Mask: 0x01)         */

/* ------------------------------  PCR_INST_SLP_EN_3  ----------------------------- */
#define PCR_INST_SLP_EN_3_ADC_SLP_EN_Pos      (3UL)                     /*!< PCR_INST SLP_EN_3: ADC_SLP_EN (Bit 3)                       */
#define PCR_INST_SLP_EN_3_ADC_SLP_EN_Msk      (0x8UL)                   /*!< PCR_INST SLP_EN_3: ADC_SLP_EN (Bitfield-Mask: 0x01)         */
#define PCR_INST_SLP_EN_3_GP_SPI0_SLP_EN_Pos  (9UL)                     /*!< PCR_INST SLP_EN_3: GP_SPI0_SLP_EN (Bit 9)                   */
#define PCR_INST_SLP_EN_3_GP_SPI0_SLP_EN_Msk  (0x200UL)                 /*!< PCR_INST SLP_EN_3: GP_SPI0_SLP_EN (Bitfield-Mask: 0x01)     */
#define PCR_INST_SLP_EN_3_HTIMER_0_SLP_EN_Pos (10UL)                    /*!< PCR_INST SLP_EN_3: HTIMER_0_SLP_EN (Bit 10)                 */
#define PCR_INST_SLP_EN_3_HTIMER_0_SLP_EN_Msk (0x400UL)                 /*!< PCR_INST SLP_EN_3: HTIMER_0_SLP_EN (Bitfield-Mask: 0x01)    */
#define PCR_INST_SLP_EN_3_KEYSCAN_SLP_EN_Pos  (11UL)                    /*!< PCR_INST SLP_EN_3: KEYSCAN_SLP_EN (Bit 11)                  */
#define PCR_INST_SLP_EN_3_KEYSCAN_SLP_EN_Msk  (0x800UL)                 /*!< PCR_INST SLP_EN_3: KEYSCAN_SLP_EN (Bitfield-Mask: 0x01)     */
#define PCR_INST_SLP_EN_3_RPMPWM_SLP_EN_Pos   (12UL)                    /*!< PCR_INST SLP_EN_3: RPMPWM_SLP_EN (Bit 12)                   */
#define PCR_INST_SLP_EN_3_RPMPWM_SLP_EN_Msk   (0x1000UL)                /*!< PCR_INST SLP_EN_3: RPMPWM_SLP_EN (Bitfield-Mask: 0x01)      */
#define PCR_INST_SLP_EN_3_SMB1_SLP_EN_Pos     (13UL)                    /*!< PCR_INST SLP_EN_3: SMB1_SLP_EN (Bit 13)                     */
#define PCR_INST_SLP_EN_3_SMB1_SLP_EN_Msk     (0x2000UL)                /*!< PCR_INST SLP_EN_3: SMB1_SLP_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_SLP_EN_3_SMB2_SLP_EN_Pos     (14UL)                    /*!< PCR_INST SLP_EN_3: SMB2_SLP_EN (Bit 14)                     */
#define PCR_INST_SLP_EN_3_SMB2_SLP_EN_Msk     (0x4000UL)                /*!< PCR_INST SLP_EN_3: SMB2_SLP_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_SLP_EN_3_SMB3_SLP_EN_Pos     (15UL)                    /*!< PCR_INST SLP_EN_3: SMB3_SLP_EN (Bit 15)                     */
#define PCR_INST_SLP_EN_3_SMB3_SLP_EN_Msk     (0x8000UL)                /*!< PCR_INST SLP_EN_3: SMB3_SLP_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_SLP_EN_3_LED0_SLP_EN_Pos     (16UL)                    /*!< PCR_INST SLP_EN_3: LED0_SLP_EN (Bit 16)                     */
#define PCR_INST_SLP_EN_3_LED0_SLP_EN_Msk     (0x10000UL)               /*!< PCR_INST SLP_EN_3: LED0_SLP_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_SLP_EN_3_LED1_SLP_EN_Pos     (17UL)                    /*!< PCR_INST SLP_EN_3: LED1_SLP_EN (Bit 17)                     */
#define PCR_INST_SLP_EN_3_LED1_SLP_EN_Msk     (0x20000UL)               /*!< PCR_INST SLP_EN_3: LED1_SLP_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_SLP_EN_3_LED2_SLP_EN_Pos     (18UL)                    /*!< PCR_INST SLP_EN_3: LED2_SLP_EN (Bit 18)                     */
#define PCR_INST_SLP_EN_3_LED2_SLP_EN_Msk     (0x40000UL)               /*!< PCR_INST SLP_EN_3: LED2_SLP_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_SLP_EN_3_GP_SPI1_SLP_EN_Pos  (20UL)                    /*!< PCR_INST SLP_EN_3: GP_SPI1_SLP_EN (Bit 20)                  */
#define PCR_INST_SLP_EN_3_GP_SPI1_SLP_EN_Msk  (0x100000UL)              /*!< PCR_INST SLP_EN_3: GP_SPI1_SLP_EN (Bitfield-Mask: 0x01)     */
#define PCR_INST_SLP_EN_3_TIMER16_2_SLP_EN_Pos (21UL)                   /*!< PCR_INST SLP_EN_3: TIMER16_2_SLP_EN (Bit 21)                */
#define PCR_INST_SLP_EN_3_TIMER16_2_SLP_EN_Msk (0x200000UL)             /*!< PCR_INST SLP_EN_3: TIMER16_2_SLP_EN (Bitfield-Mask: 0x01)   */
#define PCR_INST_SLP_EN_3_TIMER16_3_SLP_EN_Pos (22UL)                   /*!< PCR_INST SLP_EN_3: TIMER16_3_SLP_EN (Bit 22)                */
#define PCR_INST_SLP_EN_3_TIMER16_3_SLP_EN_Msk (0x400000UL)             /*!< PCR_INST SLP_EN_3: TIMER16_3_SLP_EN (Bitfield-Mask: 0x01)   */
#define PCR_INST_SLP_EN_3_TIMER32_0_SLP_EN_Pos (23UL)                   /*!< PCR_INST SLP_EN_3: TIMER32_0_SLP_EN (Bit 23)                */
#define PCR_INST_SLP_EN_3_TIMER32_0_SLP_EN_Msk (0x800000UL)             /*!< PCR_INST SLP_EN_3: TIMER32_0_SLP_EN (Bitfield-Mask: 0x01)   */
#define PCR_INST_SLP_EN_3_TIMER32_1_SLP_EN_Pos (24UL)                   /*!< PCR_INST SLP_EN_3: TIMER32_1_SLP_EN (Bit 24)                */
#define PCR_INST_SLP_EN_3_TIMER32_1_SLP_EN_Msk (0x1000000UL)            /*!< PCR_INST SLP_EN_3: TIMER32_1_SLP_EN (Bitfield-Mask: 0x01)   */
#define PCR_INST_SLP_EN_3_LED3_SLP_EN_Pos     (25UL)                    /*!< PCR_INST SLP_EN_3: LED3_SLP_EN (Bit 25)                     */
#define PCR_INST_SLP_EN_3_LED3_SLP_EN_Msk     (0x2000000UL)             /*!< PCR_INST SLP_EN_3: LED3_SLP_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_SLP_EN_3_PKE_SLP_EN_Pos      (26UL)                    /*!< PCR_INST SLP_EN_3: PKE_SLP_EN (Bit 26)                      */
#define PCR_INST_SLP_EN_3_PKE_SLP_EN_Msk      (0x4000000UL)             /*!< PCR_INST SLP_EN_3: PKE_SLP_EN (Bitfield-Mask: 0x01)         */
#define PCR_INST_SLP_EN_3_RNG_SLP_EN_Pos      (27UL)                    /*!< PCR_INST SLP_EN_3: RNG_SLP_EN (Bit 27)                      */
#define PCR_INST_SLP_EN_3_RNG_SLP_EN_Msk      (0x8000000UL)             /*!< PCR_INST SLP_EN_3: RNG_SLP_EN (Bitfield-Mask: 0x01)         */
#define PCR_INST_SLP_EN_3_AES_HASH_SLP_EN_Pos (28UL)                    /*!< PCR_INST SLP_EN_3: AES_HASH_SLP_EN (Bit 28)                 */
#define PCR_INST_SLP_EN_3_AES_HASH_SLP_EN_Msk (0x10000000UL)            /*!< PCR_INST SLP_EN_3: AES_HASH_SLP_EN (Bitfield-Mask: 0x01)    */
#define PCR_INST_SLP_EN_3_HTIMER_1_SLP_EN_Pos (29UL)                    /*!< PCR_INST SLP_EN_3: HTIMER_1_SLP_EN (Bit 29)                 */
#define PCR_INST_SLP_EN_3_HTIMER_1_SLP_EN_Msk (0x20000000UL)            /*!< PCR_INST SLP_EN_3: HTIMER_1_SLP_EN (Bitfield-Mask: 0x01)    */
#define PCR_INST_SLP_EN_3_CCTIMER_SLP_EN_Pos  (30UL)                    /*!< PCR_INST SLP_EN_3: CCTIMER_SLP_EN (Bit 30)                  */
#define PCR_INST_SLP_EN_3_CCTIMER_SLP_EN_Msk  (0x40000000UL)            /*!< PCR_INST SLP_EN_3: CCTIMER_SLP_EN (Bitfield-Mask: 0x01)     */
#define PCR_INST_SLP_EN_3_PWM9_SLP_EN_Pos     (31UL)                    /*!< PCR_INST SLP_EN_3: PWM9_SLP_EN (Bit 31)                     */
#define PCR_INST_SLP_EN_3_PWM9_SLP_EN_Msk     (0x80000000UL)            /*!< PCR_INST SLP_EN_3: PWM9_SLP_EN (Bitfield-Mask: 0x01)        */

/* ------------------------------  PCR_INST_SLP_EN_4  ----------------------------- */
#define PCR_INST_SLP_EN_4_PWM10_SLP_EN_Pos    (0UL)                     /*!< PCR_INST SLP_EN_4: PWM10_SLP_EN (Bit 0)                     */
#define PCR_INST_SLP_EN_4_PWM10_SLP_EN_Msk    (0x1UL)                   /*!< PCR_INST SLP_EN_4: PWM10_SLP_EN (Bitfield-Mask: 0x01)       */
#define PCR_INST_SLP_EN_4_PWM11_SLP_EN_Pos    (1UL)                     /*!< PCR_INST SLP_EN_4: PWM11_SLP_EN (Bit 1)                     */
#define PCR_INST_SLP_EN_4_PWM11_SLP_EN_Msk    (0x2UL)                   /*!< PCR_INST SLP_EN_4: PWM11_SLP_EN (Bitfield-Mask: 0x01)       */
#define PCR_INST_SLP_EN_4_CNT_TMER0_SLP_EN_Pos (2UL)                    /*!< PCR_INST SLP_EN_4: CNT_TMER0_SLP_EN (Bit 2)                 */
#define PCR_INST_SLP_EN_4_CNT_TMER0_SLP_EN_Msk (0x4UL)                  /*!< PCR_INST SLP_EN_4: CNT_TMER0_SLP_EN (Bitfield-Mask: 0x01)   */
#define PCR_INST_SLP_EN_4_CNT_TMER1_SLP_EN_Pos (3UL)                    /*!< PCR_INST SLP_EN_4: CNT_TMER1_SLP_EN (Bit 3)                 */
#define PCR_INST_SLP_EN_4_CNT_TMER1_SLP_EN_Msk (0x8UL)                  /*!< PCR_INST SLP_EN_4: CNT_TMER1_SLP_EN (Bitfield-Mask: 0x01)   */
#define PCR_INST_SLP_EN_4_CNT_TMER2_SLP_EN_Pos (4UL)                    /*!< PCR_INST SLP_EN_4: CNT_TMER2_SLP_EN (Bit 4)                 */
#define PCR_INST_SLP_EN_4_CNT_TMER2_SLP_EN_Msk (0x10UL)                 /*!< PCR_INST SLP_EN_4: CNT_TMER2_SLP_EN (Bitfield-Mask: 0x01)   */
#define PCR_INST_SLP_EN_4_CNT_TMER3_SLP_EN_Pos (5UL)                    /*!< PCR_INST SLP_EN_4: CNT_TMER3_SLP_EN (Bit 5)                 */
#define PCR_INST_SLP_EN_4_CNT_TMER3_SLP_EN_Msk (0x20UL)                 /*!< PCR_INST SLP_EN_4: CNT_TMER3_SLP_EN (Bitfield-Mask: 0x01)   */
#define PCR_INST_SLP_EN_4_RTOS_SLP_EN_Pos     (6UL)                     /*!< PCR_INST SLP_EN_4: RTOS_SLP_EN (Bit 6)                      */
#define PCR_INST_SLP_EN_4_RTOS_SLP_EN_Msk     (0x40UL)                  /*!< PCR_INST SLP_EN_4: RTOS_SLP_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_SLP_EN_4_RPMPWM1_SLP_EN_Pos  (7UL)                     /*!< PCR_INST SLP_EN_4: RPMPWM1_SLP_EN (Bit 7)                   */
#define PCR_INST_SLP_EN_4_RPMPWM1_SLP_EN_Msk  (0x80UL)                  /*!< PCR_INST SLP_EN_4: RPMPWM1_SLP_EN (Bitfield-Mask: 0x01)     */
#define PCR_INST_SLP_EN_4_QSPI_SLP_EN_Pos     (8UL)                     /*!< PCR_INST SLP_EN_4: QSPI_SLP_EN (Bit 8)                      */
#define PCR_INST_SLP_EN_4_QSPI_SLP_EN_Msk     (0x100UL)                 /*!< PCR_INST SLP_EN_4: QSPI_SLP_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_SLP_EN_4_RC_ID0_SLP_EN_Pos   (10UL)                    /*!< PCR_INST SLP_EN_4: RC_ID0_SLP_EN (Bit 10)                   */
#define PCR_INST_SLP_EN_4_RC_ID0_SLP_EN_Msk   (0x400UL)                 /*!< PCR_INST SLP_EN_4: RC_ID0_SLP_EN (Bitfield-Mask: 0x01)      */
#define PCR_INST_SLP_EN_4_RC_ID1_SLP_EN_Pos   (11UL)                    /*!< PCR_INST SLP_EN_4: RC_ID1_SLP_EN (Bit 11)                   */
#define PCR_INST_SLP_EN_4_RC_ID1_SLP_EN_Msk   (0x800UL)                 /*!< PCR_INST SLP_EN_4: RC_ID1_SLP_EN (Bitfield-Mask: 0x01)      */
#define PCR_INST_SLP_EN_4_RC_ID2_SLP_EN_Pos   (12UL)                    /*!< PCR_INST SLP_EN_4: RC_ID2_SLP_EN (Bit 12)                   */
#define PCR_INST_SLP_EN_4_RC_ID2_SLP_EN_Msk   (0x1000UL)                /*!< PCR_INST SLP_EN_4: RC_ID2_SLP_EN (Bitfield-Mask: 0x01)      */

/* -----------------------------  PCR_INST_CLK_REQ_0  ----------------------------- */
#define PCR_INST_CLK_REQ_0_JTAG_STAP_CLK_REQ_Pos (0UL)                  /*!< PCR_INST CLK_REQ_0: JTAG_STAP_CLK_REQ (Bit 0)               */
#define PCR_INST_CLK_REQ_0_JTAG_STAP_CLK_REQ_Msk (0x1UL)                /*!< PCR_INST CLK_REQ_0: JTAG_STAP_CLK_REQ (Bitfield-Mask: 0x01) */
#define PCR_INST_CLK_REQ_0_EFUSE_CLK_REQ_Pos  (1UL)                     /*!< PCR_INST CLK_REQ_0: EFUSE_CLK_REQ (Bit 1)                   */
#define PCR_INST_CLK_REQ_0_EFUSE_CLK_REQ_Msk  (0x2UL)                   /*!< PCR_INST CLK_REQ_0: EFUSE_CLK_REQ (Bitfield-Mask: 0x01)     */

/* -----------------------------  PCR_INST_CLK_REQ_1  ----------------------------- */
#define PCR_INST_CLK_REQ_1_INT_CLK_REQ_Pos    (0UL)                     /*!< PCR_INST CLK_REQ_1: INT_CLK_REQ (Bit 0)                     */
#define PCR_INST_CLK_REQ_1_INT_CLK_REQ_Msk    (0x1UL)                   /*!< PCR_INST CLK_REQ_1: INT_CLK_REQ (Bitfield-Mask: 0x01)       */
#define PCR_INST_CLK_REQ_1_TACH0_CLK_REQ_Pos  (2UL)                     /*!< PCR_INST CLK_REQ_1: TACH0_CLK_REQ (Bit 2)                   */
#define PCR_INST_CLK_REQ_1_TACH0_CLK_REQ_Msk  (0x4UL)                   /*!< PCR_INST CLK_REQ_1: TACH0_CLK_REQ (Bitfield-Mask: 0x01)     */
#define PCR_INST_CLK_REQ_1_PWM0_CLK_REQ_Pos   (4UL)                     /*!< PCR_INST CLK_REQ_1: PWM0_CLK_REQ (Bit 4)                    */
#define PCR_INST_CLK_REQ_1_PWM0_CLK_REQ_Msk   (0x10UL)                  /*!< PCR_INST CLK_REQ_1: PWM0_CLK_REQ (Bitfield-Mask: 0x01)      */
#define PCR_INST_CLK_REQ_1_PMC_CLK_REQ_Pos    (5UL)                     /*!< PCR_INST CLK_REQ_1: PMC_CLK_REQ (Bit 5)                     */
#define PCR_INST_CLK_REQ_1_PMC_CLK_REQ_Msk    (0x20UL)                  /*!< PCR_INST CLK_REQ_1: PMC_CLK_REQ (Bitfield-Mask: 0x01)       */
#define PCR_INST_CLK_REQ_1_DMA_CLK_REQ_Pos    (6UL)                     /*!< PCR_INST CLK_REQ_1: DMA_CLK_REQ (Bit 6)                     */
#define PCR_INST_CLK_REQ_1_DMA_CLK_REQ_Msk    (0x40UL)                  /*!< PCR_INST CLK_REQ_1: DMA_CLK_REQ (Bitfield-Mask: 0x01)       */
#define PCR_INST_CLK_REQ_1_TFDP_CLK_REQ_Pos   (7UL)                     /*!< PCR_INST CLK_REQ_1: TFDP_CLK_REQ (Bit 7)                    */
#define PCR_INST_CLK_REQ_1_TFDP_CLK_REQ_Msk   (0x80UL)                  /*!< PCR_INST CLK_REQ_1: TFDP_CLK_REQ (Bitfield-Mask: 0x01)      */
#define PCR_INST_CLK_REQ_1_PROCESSOR_CLK_REQ_Pos (8UL)                  /*!< PCR_INST CLK_REQ_1: PROCESSOR_CLK_REQ (Bit 8)               */
#define PCR_INST_CLK_REQ_1_PROCESSOR_CLK_REQ_Msk (0x100UL)              /*!< PCR_INST CLK_REQ_1: PROCESSOR_CLK_REQ (Bitfield-Mask: 0x01) */
#define PCR_INST_CLK_REQ_1_WDT_CLK_REQ_Pos    (9UL)                     /*!< PCR_INST CLK_REQ_1: WDT_CLK_REQ (Bit 9)                     */
#define PCR_INST_CLK_REQ_1_WDT_CLK_REQ_Msk    (0x200UL)                 /*!< PCR_INST CLK_REQ_1: WDT_CLK_REQ (Bitfield-Mask: 0x01)       */
#define PCR_INST_CLK_REQ_1_SMB0_CLK_REQ_Pos   (10UL)                    /*!< PCR_INST CLK_REQ_1: SMB0_CLK_REQ (Bit 10)                   */
#define PCR_INST_CLK_REQ_1_SMB0_CLK_REQ_Msk   (0x400UL)                 /*!< PCR_INST CLK_REQ_1: SMB0_CLK_REQ (Bitfield-Mask: 0x01)      */
#define PCR_INST_CLK_REQ_1_TACH1_CLK_REQ_Pos  (11UL)                    /*!< PCR_INST CLK_REQ_1: TACH1_CLK_REQ (Bit 11)                  */
#define PCR_INST_CLK_REQ_1_TACH1_CLK_REQ_Msk  (0x800UL)                 /*!< PCR_INST CLK_REQ_1: TACH1_CLK_REQ (Bitfield-Mask: 0x01)     */
#define PCR_INST_CLK_REQ_1_TACH2_CLK_REQ_Pos  (12UL)                    /*!< PCR_INST CLK_REQ_1: TACH2_CLK_REQ (Bit 12)                  */
#define PCR_INST_CLK_REQ_1_TACH2_CLK_REQ_Msk  (0x1000UL)                /*!< PCR_INST CLK_REQ_1: TACH2_CLK_REQ (Bitfield-Mask: 0x01)     */
#define PCR_INST_CLK_REQ_1_PWM1_CLK_REQ_Pos   (20UL)                    /*!< PCR_INST CLK_REQ_1: PWM1_CLK_REQ (Bit 20)                   */
#define PCR_INST_CLK_REQ_1_PWM1_CLK_REQ_Msk   (0x100000UL)              /*!< PCR_INST CLK_REQ_1: PWM1_CLK_REQ (Bitfield-Mask: 0x01)      */
#define PCR_INST_CLK_REQ_1_PWM2_CLK_REQ_Pos   (21UL)                    /*!< PCR_INST CLK_REQ_1: PWM2_CLK_REQ (Bit 21)                   */
#define PCR_INST_CLK_REQ_1_PWM2_CLK_REQ_Msk   (0x200000UL)              /*!< PCR_INST CLK_REQ_1: PWM2_CLK_REQ (Bitfield-Mask: 0x01)      */
#define PCR_INST_CLK_REQ_1_PWM3_CLK_REQ_Pos   (22UL)                    /*!< PCR_INST CLK_REQ_1: PWM3_CLK_REQ (Bit 22)                   */
#define PCR_INST_CLK_REQ_1_PWM3_CLK_REQ_Msk   (0x400000UL)              /*!< PCR_INST CLK_REQ_1: PWM3_CLK_REQ (Bitfield-Mask: 0x01)      */
#define PCR_INST_CLK_REQ_1_PWM4_CLK_REQ_Pos   (23UL)                    /*!< PCR_INST CLK_REQ_1: PWM4_CLK_REQ (Bit 23)                   */
#define PCR_INST_CLK_REQ_1_PWM4_CLK_REQ_Msk   (0x800000UL)              /*!< PCR_INST CLK_REQ_1: PWM4_CLK_REQ (Bitfield-Mask: 0x01)      */
#define PCR_INST_CLK_REQ_1_PWM5_CLK_REQ_Pos   (24UL)                    /*!< PCR_INST CLK_REQ_1: PWM5_CLK_REQ (Bit 24)                   */
#define PCR_INST_CLK_REQ_1_PWM5_CLK_REQ_Msk   (0x1000000UL)             /*!< PCR_INST CLK_REQ_1: PWM5_CLK_REQ (Bitfield-Mask: 0x01)      */
#define PCR_INST_CLK_REQ_1_PWM6_CLK_REQ_Pos   (25UL)                    /*!< PCR_INST CLK_REQ_1: PWM6_CLK_REQ (Bit 25)                   */
#define PCR_INST_CLK_REQ_1_PWM6_CLK_REQ_Msk   (0x2000000UL)             /*!< PCR_INST CLK_REQ_1: PWM6_CLK_REQ (Bitfield-Mask: 0x01)      */
#define PCR_INST_CLK_REQ_1_PWM7_CLK_REQ_Pos   (26UL)                    /*!< PCR_INST CLK_REQ_1: PWM7_CLK_REQ (Bit 26)                   */
#define PCR_INST_CLK_REQ_1_PWM7_CLK_REQ_Msk   (0x4000000UL)             /*!< PCR_INST CLK_REQ_1: PWM7_CLK_REQ (Bitfield-Mask: 0x01)      */
#define PCR_INST_CLK_REQ_1_PWM8_CLK_REQ_Pos   (27UL)                    /*!< PCR_INST CLK_REQ_1: PWM8_CLK_REQ (Bit 27)                   */
#define PCR_INST_CLK_REQ_1_PWM8_CLK_REQ_Msk   (0x8000000UL)             /*!< PCR_INST CLK_REQ_1: PWM8_CLK_REQ (Bitfield-Mask: 0x01)      */
#define PCR_INST_CLK_REQ_1_EC_REG_BANK_CLK_REQ_Pos (29UL)               /*!< PCR_INST CLK_REQ_1: EC_REG_BANK_CLK_REQ (Bit 29)            */
#define PCR_INST_CLK_REQ_1_EC_REG_BANK_CLK_REQ_Msk (0x20000000UL)       /*!< PCR_INST CLK_REQ_1: EC_REG_BANK_CLK_REQ (Bitfield-Mask: 0x01) */
#define PCR_INST_CLK_REQ_1_TIMER16_0_CLK_REQ_Pos (30UL)                 /*!< PCR_INST CLK_REQ_1: TIMER16_0_CLK_REQ (Bit 30)              */
#define PCR_INST_CLK_REQ_1_TIMER16_0_CLK_REQ_Msk (0x40000000UL)         /*!< PCR_INST CLK_REQ_1: TIMER16_0_CLK_REQ (Bitfield-Mask: 0x01) */
#define PCR_INST_CLK_REQ_1_TIMER16_1_CLK_REQ_Pos (31UL)                 /*!< PCR_INST CLK_REQ_1: TIMER16_1_CLK_REQ (Bit 31)              */
#define PCR_INST_CLK_REQ_1_TIMER16_1_CLK_REQ_Msk (0x80000000UL)         /*!< PCR_INST CLK_REQ_1: TIMER16_1_CLK_REQ (Bitfield-Mask: 0x01) */

/* -----------------------------  PCR_INST_CLK_REQ_2  ----------------------------- */
#define PCR_INST_CLK_REQ_2_UART_0_CLK_REQ_Pos (1UL)                     /*!< PCR_INST CLK_REQ_2: UART_0_CLK_REQ (Bit 1)                  */
#define PCR_INST_CLK_REQ_2_UART_0_CLK_REQ_Msk (0x2UL)                   /*!< PCR_INST CLK_REQ_2: UART_0_CLK_REQ (Bitfield-Mask: 0x01)    */
#define PCR_INST_CLK_REQ_2_UART_1_CLK_REQ_Pos (2UL)                     /*!< PCR_INST CLK_REQ_2: UART_1_CLK_REQ (Bit 2)                  */
#define PCR_INST_CLK_REQ_2_UART_1_CLK_REQ_Msk (0x4UL)                   /*!< PCR_INST CLK_REQ_2: UART_1_CLK_REQ (Bitfield-Mask: 0x01)    */
#define PCR_INST_CLK_REQ_2_GLBL_CFG_CLK_REQ_Pos (12UL)                  /*!< PCR_INST CLK_REQ_2: GLBL_CFG_CLK_REQ (Bit 12)               */
#define PCR_INST_CLK_REQ_2_GLBL_CFG_CLK_REQ_Msk (0x1000UL)              /*!< PCR_INST CLK_REQ_2: GLBL_CFG_CLK_REQ (Bitfield-Mask: 0x01)  */
#define PCR_INST_CLK_REQ_2_RTC_CLK_REQ_Pos    (18UL)                    /*!< PCR_INST CLK_REQ_2: RTC_CLK_REQ (Bit 18)                    */
#define PCR_INST_CLK_REQ_2_RTC_CLK_REQ_Msk    (0x40000UL)               /*!< PCR_INST CLK_REQ_2: RTC_CLK_REQ (Bitfield-Mask: 0x01)       */

/* -----------------------------  PCR_INST_CLK_REQ_3  ----------------------------- */
#define PCR_INST_CLK_REQ_3_ADC_CLK_REQ_Pos    (3UL)                     /*!< PCR_INST CLK_REQ_3: ADC_CLK_REQ (Bit 3)                     */
#define PCR_INST_CLK_REQ_3_ADC_CLK_REQ_Msk    (0x8UL)                   /*!< PCR_INST CLK_REQ_3: ADC_CLK_REQ (Bitfield-Mask: 0x01)       */
#define PCR_INST_CLK_REQ_3_GP_SPI0_CLK_REQ_Pos (9UL)                    /*!< PCR_INST CLK_REQ_3: GP_SPI0_CLK_REQ (Bit 9)                 */
#define PCR_INST_CLK_REQ_3_GP_SPI0_CLK_REQ_Msk (0x200UL)                /*!< PCR_INST CLK_REQ_3: GP_SPI0_CLK_REQ (Bitfield-Mask: 0x01)   */
#define PCR_INST_CLK_REQ_3_HTIMER_0_CLK_REQ_Pos (10UL)                  /*!< PCR_INST CLK_REQ_3: HTIMER_0_CLK_REQ (Bit 10)               */
#define PCR_INST_CLK_REQ_3_HTIMER_0_CLK_REQ_Msk (0x400UL)               /*!< PCR_INST CLK_REQ_3: HTIMER_0_CLK_REQ (Bitfield-Mask: 0x01)  */
#define PCR_INST_CLK_REQ_3_KEYSCAN_CLK_REQ_Pos (11UL)                   /*!< PCR_INST CLK_REQ_3: KEYSCAN_CLK_REQ (Bit 11)                */
#define PCR_INST_CLK_REQ_3_KEYSCAN_CLK_REQ_Msk (0x800UL)                /*!< PCR_INST CLK_REQ_3: KEYSCAN_CLK_REQ (Bitfield-Mask: 0x01)   */
#define PCR_INST_CLK_REQ_3_RPMPWM0_CLK_REQ_Pos (12UL)                   /*!< PCR_INST CLK_REQ_3: RPMPWM0_CLK_REQ (Bit 12)                */
#define PCR_INST_CLK_REQ_3_RPMPWM0_CLK_REQ_Msk (0x1000UL)               /*!< PCR_INST CLK_REQ_3: RPMPWM0_CLK_REQ (Bitfield-Mask: 0x01)   */
#define PCR_INST_CLK_REQ_3_SMB1_CLK_REQ_Pos   (13UL)                    /*!< PCR_INST CLK_REQ_3: SMB1_CLK_REQ (Bit 13)                   */
#define PCR_INST_CLK_REQ_3_SMB1_CLK_REQ_Msk   (0x2000UL)                /*!< PCR_INST CLK_REQ_3: SMB1_CLK_REQ (Bitfield-Mask: 0x01)      */
#define PCR_INST_CLK_REQ_3_SMB2_CLK_REQ_Pos   (14UL)                    /*!< PCR_INST CLK_REQ_3: SMB2_CLK_REQ (Bit 14)                   */
#define PCR_INST_CLK_REQ_3_SMB2_CLK_REQ_Msk   (0x4000UL)                /*!< PCR_INST CLK_REQ_3: SMB2_CLK_REQ (Bitfield-Mask: 0x01)      */
#define PCR_INST_CLK_REQ_3_SMB3_CLK_REQ_Pos   (15UL)                    /*!< PCR_INST CLK_REQ_3: SMB3_CLK_REQ (Bit 15)                   */
#define PCR_INST_CLK_REQ_3_SMB3_CLK_REQ_Msk   (0x8000UL)                /*!< PCR_INST CLK_REQ_3: SMB3_CLK_REQ (Bitfield-Mask: 0x01)      */
#define PCR_INST_CLK_REQ_3_LED0_CLK_REQ_Pos   (16UL)                    /*!< PCR_INST CLK_REQ_3: LED0_CLK_REQ (Bit 16)                   */
#define PCR_INST_CLK_REQ_3_LED0_CLK_REQ_Msk   (0x10000UL)               /*!< PCR_INST CLK_REQ_3: LED0_CLK_REQ (Bitfield-Mask: 0x01)      */
#define PCR_INST_CLK_REQ_3_LED1_CLK_REQ_Pos   (17UL)                    /*!< PCR_INST CLK_REQ_3: LED1_CLK_REQ (Bit 17)                   */
#define PCR_INST_CLK_REQ_3_LED1_CLK_REQ_Msk   (0x20000UL)               /*!< PCR_INST CLK_REQ_3: LED1_CLK_REQ (Bitfield-Mask: 0x01)      */
#define PCR_INST_CLK_REQ_3_LED2_CLK_REQ_Pos   (18UL)                    /*!< PCR_INST CLK_REQ_3: LED2_CLK_REQ (Bit 18)                   */
#define PCR_INST_CLK_REQ_3_LED2_CLK_REQ_Msk   (0x40000UL)               /*!< PCR_INST CLK_REQ_3: LED2_CLK_REQ (Bitfield-Mask: 0x01)      */
#define PCR_INST_CLK_REQ_3_GP_SPI1_CLK_REQ_Pos (20UL)                   /*!< PCR_INST CLK_REQ_3: GP_SPI1_CLK_REQ (Bit 20)                */
#define PCR_INST_CLK_REQ_3_GP_SPI1_CLK_REQ_Msk (0x100000UL)             /*!< PCR_INST CLK_REQ_3: GP_SPI1_CLK_REQ (Bitfield-Mask: 0x01)   */
#define PCR_INST_CLK_REQ_3_TIMER16_2_CLK_REQ_Pos (21UL)                 /*!< PCR_INST CLK_REQ_3: TIMER16_2_CLK_REQ (Bit 21)              */
#define PCR_INST_CLK_REQ_3_TIMER16_2_CLK_REQ_Msk (0x200000UL)           /*!< PCR_INST CLK_REQ_3: TIMER16_2_CLK_REQ (Bitfield-Mask: 0x01) */
#define PCR_INST_CLK_REQ_3_TIMER16_3_CLK_REQ_Pos (22UL)                 /*!< PCR_INST CLK_REQ_3: TIMER16_3_CLK_REQ (Bit 22)              */
#define PCR_INST_CLK_REQ_3_TIMER16_3_CLK_REQ_Msk (0x400000UL)           /*!< PCR_INST CLK_REQ_3: TIMER16_3_CLK_REQ (Bitfield-Mask: 0x01) */
#define PCR_INST_CLK_REQ_3_TIMER32_0_CLK_REQ_Pos (23UL)                 /*!< PCR_INST CLK_REQ_3: TIMER32_0_CLK_REQ (Bit 23)              */
#define PCR_INST_CLK_REQ_3_TIMER32_0_CLK_REQ_Msk (0x800000UL)           /*!< PCR_INST CLK_REQ_3: TIMER32_0_CLK_REQ (Bitfield-Mask: 0x01) */
#define PCR_INST_CLK_REQ_3_TIMER32_1_CLK_REQ_Pos (24UL)                 /*!< PCR_INST CLK_REQ_3: TIMER32_1_CLK_REQ (Bit 24)              */
#define PCR_INST_CLK_REQ_3_TIMER32_1_CLK_REQ_Msk (0x1000000UL)          /*!< PCR_INST CLK_REQ_3: TIMER32_1_CLK_REQ (Bitfield-Mask: 0x01) */
#define PCR_INST_CLK_REQ_3_LED3_CLK_REQ_Pos   (25UL)                    /*!< PCR_INST CLK_REQ_3: LED3_CLK_REQ (Bit 25)                   */
#define PCR_INST_CLK_REQ_3_LED3_CLK_REQ_Msk   (0x2000000UL)             /*!< PCR_INST CLK_REQ_3: LED3_CLK_REQ (Bitfield-Mask: 0x01)      */
#define PCR_INST_CLK_REQ_3_PKE_CLK_REQ_Pos    (26UL)                    /*!< PCR_INST CLK_REQ_3: PKE_CLK_REQ (Bit 26)                    */
#define PCR_INST_CLK_REQ_3_PKE_CLK_REQ_Msk    (0x4000000UL)             /*!< PCR_INST CLK_REQ_3: PKE_CLK_REQ (Bitfield-Mask: 0x01)       */
#define PCR_INST_CLK_REQ_3_RNG_CLK_REQ_Pos    (27UL)                    /*!< PCR_INST CLK_REQ_3: RNG_CLK_REQ (Bit 27)                    */
#define PCR_INST_CLK_REQ_3_RNG_CLK_REQ_Msk    (0x8000000UL)             /*!< PCR_INST CLK_REQ_3: RNG_CLK_REQ (Bitfield-Mask: 0x01)       */
#define PCR_INST_CLK_REQ_3_AES_HASH_CLK_REQ_Pos (28UL)                  /*!< PCR_INST CLK_REQ_3: AES_HASH_CLK_REQ (Bit 28)               */
#define PCR_INST_CLK_REQ_3_AES_HASH_CLK_REQ_Msk (0x10000000UL)          /*!< PCR_INST CLK_REQ_3: AES_HASH_CLK_REQ (Bitfield-Mask: 0x01)  */
#define PCR_INST_CLK_REQ_3_HTIMER_1_CLK_REQ_Pos (29UL)                  /*!< PCR_INST CLK_REQ_3: HTIMER_1_CLK_REQ (Bit 29)               */
#define PCR_INST_CLK_REQ_3_HTIMER_1_CLK_REQ_Msk (0x20000000UL)          /*!< PCR_INST CLK_REQ_3: HTIMER_1_CLK_REQ (Bitfield-Mask: 0x01)  */
#define PCR_INST_CLK_REQ_3_CCTIMER_CLK_REQ_Pos (30UL)                   /*!< PCR_INST CLK_REQ_3: CCTIMER_CLK_REQ (Bit 30)                */
#define PCR_INST_CLK_REQ_3_CCTIMER_CLK_REQ_Msk (0x40000000UL)           /*!< PCR_INST CLK_REQ_3: CCTIMER_CLK_REQ (Bitfield-Mask: 0x01)   */
#define PCR_INST_CLK_REQ_3_PWM9_CLK_REQ_Pos   (31UL)                    /*!< PCR_INST CLK_REQ_3: PWM9_CLK_REQ (Bit 31)                   */
#define PCR_INST_CLK_REQ_3_PWM9_CLK_REQ_Msk   (0x80000000UL)            /*!< PCR_INST CLK_REQ_3: PWM9_CLK_REQ (Bitfield-Mask: 0x01)      */

/* -----------------------------  PCR_INST_CLK_REQ_4  ----------------------------- */
#define PCR_INST_CLK_REQ_4_PWM10_CLK_REQ_Pos  (0UL)                     /*!< PCR_INST CLK_REQ_4: PWM10_CLK_REQ (Bit 0)                   */
#define PCR_INST_CLK_REQ_4_PWM10_CLK_REQ_Msk  (0x1UL)                   /*!< PCR_INST CLK_REQ_4: PWM10_CLK_REQ (Bitfield-Mask: 0x01)     */
#define PCR_INST_CLK_REQ_4_PWM11_CLK_REQ_Pos  (1UL)                     /*!< PCR_INST CLK_REQ_4: PWM11_CLK_REQ (Bit 1)                   */
#define PCR_INST_CLK_REQ_4_PWM11_CLK_REQ_Msk  (0x2UL)                   /*!< PCR_INST CLK_REQ_4: PWM11_CLK_REQ (Bitfield-Mask: 0x01)     */
#define PCR_INST_CLK_REQ_4_CNT_TMER0_CLK_REQ_Pos (2UL)                  /*!< PCR_INST CLK_REQ_4: CNT_TMER0_CLK_REQ (Bit 2)               */
#define PCR_INST_CLK_REQ_4_CNT_TMER0_CLK_REQ_Msk (0x4UL)                /*!< PCR_INST CLK_REQ_4: CNT_TMER0_CLK_REQ (Bitfield-Mask: 0x01) */
#define PCR_INST_CLK_REQ_4_CNT_TMER1_CLK_REQ_Pos (3UL)                  /*!< PCR_INST CLK_REQ_4: CNT_TMER1_CLK_REQ (Bit 3)               */
#define PCR_INST_CLK_REQ_4_CNT_TMER1_CLK_REQ_Msk (0x8UL)                /*!< PCR_INST CLK_REQ_4: CNT_TMER1_CLK_REQ (Bitfield-Mask: 0x01) */
#define PCR_INST_CLK_REQ_4_CNT_TMER2_CLK_REQ_Pos (4UL)                  /*!< PCR_INST CLK_REQ_4: CNT_TMER2_CLK_REQ (Bit 4)               */
#define PCR_INST_CLK_REQ_4_CNT_TMER2_CLK_REQ_Msk (0x10UL)               /*!< PCR_INST CLK_REQ_4: CNT_TMER2_CLK_REQ (Bitfield-Mask: 0x01) */
#define PCR_INST_CLK_REQ_4_CNT_TMER3_CLK_REQ_Pos (5UL)                  /*!< PCR_INST CLK_REQ_4: CNT_TMER3_CLK_REQ (Bit 5)               */
#define PCR_INST_CLK_REQ_4_CNT_TMER3_CLK_REQ_Msk (0x20UL)               /*!< PCR_INST CLK_REQ_4: CNT_TMER3_CLK_REQ (Bitfield-Mask: 0x01) */
#define PCR_INST_CLK_REQ_4_RTOS_CLK_REQ_Pos   (6UL)                     /*!< PCR_INST CLK_REQ_4: RTOS_CLK_REQ (Bit 6)                    */
#define PCR_INST_CLK_REQ_4_RTOS_CLK_REQ_Msk   (0x40UL)                  /*!< PCR_INST CLK_REQ_4: RTOS_CLK_REQ (Bitfield-Mask: 0x01)      */
#define PCR_INST_CLK_REQ_4_RPMPWM1_CLK_REQ_Pos (7UL)                    /*!< PCR_INST CLK_REQ_4: RPMPWM1_CLK_REQ (Bit 7)                 */
#define PCR_INST_CLK_REQ_4_RPMPWM1_CLK_REQ_Msk (0x80UL)                 /*!< PCR_INST CLK_REQ_4: RPMPWM1_CLK_REQ (Bitfield-Mask: 0x01)   */
#define PCR_INST_CLK_REQ_4_QSPI_CLK_REQ_Pos   (8UL)                     /*!< PCR_INST CLK_REQ_4: QSPI_CLK_REQ (Bit 8)                    */
#define PCR_INST_CLK_REQ_4_QSPI_CLK_REQ_Msk   (0x100UL)                 /*!< PCR_INST CLK_REQ_4: QSPI_CLK_REQ (Bitfield-Mask: 0x01)      */
#define PCR_INST_CLK_REQ_4_RC_ID0_CLK_REQ_Pos (10UL)                    /*!< PCR_INST CLK_REQ_4: RC_ID0_CLK_REQ (Bit 10)                 */
#define PCR_INST_CLK_REQ_4_RC_ID0_CLK_REQ_Msk (0x400UL)                 /*!< PCR_INST CLK_REQ_4: RC_ID0_CLK_REQ (Bitfield-Mask: 0x01)    */
#define PCR_INST_CLK_REQ_4_RC_ID1_CLK_REQ_Pos (11UL)                    /*!< PCR_INST CLK_REQ_4: RC_ID1_CLK_REQ (Bit 11)                 */
#define PCR_INST_CLK_REQ_4_RC_ID1_CLK_REQ_Msk (0x800UL)                 /*!< PCR_INST CLK_REQ_4: RC_ID1_CLK_REQ (Bitfield-Mask: 0x01)    */
#define PCR_INST_CLK_REQ_4_RC_ID2_CLK_REQ_Pos (12UL)                    /*!< PCR_INST CLK_REQ_4: RC_ID2_CLK_REQ (Bit 12)                 */
#define PCR_INST_CLK_REQ_4_RC_ID2_CLK_REQ_Msk (0x1000UL)                /*!< PCR_INST CLK_REQ_4: RC_ID2_CLK_REQ (Bitfield-Mask: 0x01)    */

/* ------------------------------  PCR_INST_RST_EN_0  ----------------------------- */
#define PCR_INST_RST_EN_0_JTAG_STAP_RST_EN_Pos (0UL)                    /*!< PCR_INST RST_EN_0: JTAG_STAP_RST_EN (Bit 0)                 */
#define PCR_INST_RST_EN_0_JTAG_STAP_RST_EN_Msk (0x1UL)                  /*!< PCR_INST RST_EN_0: JTAG_STAP_RST_EN (Bitfield-Mask: 0x01)   */
#define PCR_INST_RST_EN_0_EFUSE_RST_EN_Pos    (1UL)                     /*!< PCR_INST RST_EN_0: EFUSE_RST_EN (Bit 1)                     */
#define PCR_INST_RST_EN_0_EFUSE_RST_EN_Msk    (0x2UL)                   /*!< PCR_INST RST_EN_0: EFUSE_RST_EN (Bitfield-Mask: 0x01)       */

/* ------------------------------  PCR_INST_RST_EN_1  ----------------------------- */
#define PCR_INST_RST_EN_1_INT_RST_EN_Pos      (0UL)                     /*!< PCR_INST RST_EN_1: INT_RST_EN (Bit 0)                       */
#define PCR_INST_RST_EN_1_INT_RST_EN_Msk      (0x1UL)                   /*!< PCR_INST RST_EN_1: INT_RST_EN (Bitfield-Mask: 0x01)         */
#define PCR_INST_RST_EN_1_TACH0_RST_EN_Pos    (2UL)                     /*!< PCR_INST RST_EN_1: TACH0_RST_EN (Bit 2)                     */
#define PCR_INST_RST_EN_1_TACH0_RST_EN_Msk    (0x4UL)                   /*!< PCR_INST RST_EN_1: TACH0_RST_EN (Bitfield-Mask: 0x01)       */
#define PCR_INST_RST_EN_1_PWM0_RST_EN_Pos     (4UL)                     /*!< PCR_INST RST_EN_1: PWM0_RST_EN (Bit 4)                      */
#define PCR_INST_RST_EN_1_PWM0_RST_EN_Msk     (0x10UL)                  /*!< PCR_INST RST_EN_1: PWM0_RST_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_RST_EN_1_PMC_RST_EN_Pos      (5UL)                     /*!< PCR_INST RST_EN_1: PMC_RST_EN (Bit 5)                       */
#define PCR_INST_RST_EN_1_PMC_RST_EN_Msk      (0x20UL)                  /*!< PCR_INST RST_EN_1: PMC_RST_EN (Bitfield-Mask: 0x01)         */
#define PCR_INST_RST_EN_1_DMA_RST_EN_Pos      (6UL)                     /*!< PCR_INST RST_EN_1: DMA_RST_EN (Bit 6)                       */
#define PCR_INST_RST_EN_1_DMA_RST_EN_Msk      (0x40UL)                  /*!< PCR_INST RST_EN_1: DMA_RST_EN (Bitfield-Mask: 0x01)         */
#define PCR_INST_RST_EN_1_TFDP_RST_EN_Pos     (7UL)                     /*!< PCR_INST RST_EN_1: TFDP_RST_EN (Bit 7)                      */
#define PCR_INST_RST_EN_1_TFDP_RST_EN_Msk     (0x80UL)                  /*!< PCR_INST RST_EN_1: TFDP_RST_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_RST_EN_1_PROCESSOR_RST_EN_Pos (8UL)                    /*!< PCR_INST RST_EN_1: PROCESSOR_RST_EN (Bit 8)                 */
#define PCR_INST_RST_EN_1_PROCESSOR_RST_EN_Msk (0x100UL)                /*!< PCR_INST RST_EN_1: PROCESSOR_RST_EN (Bitfield-Mask: 0x01)   */
#define PCR_INST_RST_EN_1_WDT_RST_EN_Pos      (9UL)                     /*!< PCR_INST RST_EN_1: WDT_RST_EN (Bit 9)                       */
#define PCR_INST_RST_EN_1_WDT_RST_EN_Msk      (0x200UL)                 /*!< PCR_INST RST_EN_1: WDT_RST_EN (Bitfield-Mask: 0x01)         */
#define PCR_INST_RST_EN_1_SMB0_RST_EN_Pos     (10UL)                    /*!< PCR_INST RST_EN_1: SMB0_RST_EN (Bit 10)                     */
#define PCR_INST_RST_EN_1_SMB0_RST_EN_Msk     (0x400UL)                 /*!< PCR_INST RST_EN_1: SMB0_RST_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_RST_EN_1_TACH1_RST_EN_Pos    (11UL)                    /*!< PCR_INST RST_EN_1: TACH1_RST_EN (Bit 11)                    */
#define PCR_INST_RST_EN_1_TACH1_RST_EN_Msk    (0x800UL)                 /*!< PCR_INST RST_EN_1: TACH1_RST_EN (Bitfield-Mask: 0x01)       */
#define PCR_INST_RST_EN_1_TACH2_RST_EN_Pos    (12UL)                    /*!< PCR_INST RST_EN_1: TACH2_RST_EN (Bit 12)                    */
#define PCR_INST_RST_EN_1_TACH2_RST_EN_Msk    (0x1000UL)                /*!< PCR_INST RST_EN_1: TACH2_RST_EN (Bitfield-Mask: 0x01)       */
#define PCR_INST_RST_EN_1_PWM1_RST_EN_Pos     (20UL)                    /*!< PCR_INST RST_EN_1: PWM1_RST_EN (Bit 20)                     */
#define PCR_INST_RST_EN_1_PWM1_RST_EN_Msk     (0x100000UL)              /*!< PCR_INST RST_EN_1: PWM1_RST_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_RST_EN_1_PWM2_RST_EN_Pos     (21UL)                    /*!< PCR_INST RST_EN_1: PWM2_RST_EN (Bit 21)                     */
#define PCR_INST_RST_EN_1_PWM2_RST_EN_Msk     (0x200000UL)              /*!< PCR_INST RST_EN_1: PWM2_RST_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_RST_EN_1_PWM3_RST_EN_Pos     (22UL)                    /*!< PCR_INST RST_EN_1: PWM3_RST_EN (Bit 22)                     */
#define PCR_INST_RST_EN_1_PWM3_RST_EN_Msk     (0x400000UL)              /*!< PCR_INST RST_EN_1: PWM3_RST_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_RST_EN_1_PWM4_RST_EN_Pos     (23UL)                    /*!< PCR_INST RST_EN_1: PWM4_RST_EN (Bit 23)                     */
#define PCR_INST_RST_EN_1_PWM4_RST_EN_Msk     (0x800000UL)              /*!< PCR_INST RST_EN_1: PWM4_RST_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_RST_EN_1_PWM5_RST_EN_Pos     (24UL)                    /*!< PCR_INST RST_EN_1: PWM5_RST_EN (Bit 24)                     */
#define PCR_INST_RST_EN_1_PWM5_RST_EN_Msk     (0x1000000UL)             /*!< PCR_INST RST_EN_1: PWM5_RST_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_RST_EN_1_PWM6_RST_EN_Pos     (25UL)                    /*!< PCR_INST RST_EN_1: PWM6_RST_EN (Bit 25)                     */
#define PCR_INST_RST_EN_1_PWM6_RST_EN_Msk     (0x2000000UL)             /*!< PCR_INST RST_EN_1: PWM6_RST_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_RST_EN_1_PWM7_RST_EN_Pos     (26UL)                    /*!< PCR_INST RST_EN_1: PWM7_RST_EN (Bit 26)                     */
#define PCR_INST_RST_EN_1_PWM7_RST_EN_Msk     (0x4000000UL)             /*!< PCR_INST RST_EN_1: PWM7_RST_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_RST_EN_1_PWM8_RST_EN_Pos     (27UL)                    /*!< PCR_INST RST_EN_1: PWM8_RST_EN (Bit 27)                     */
#define PCR_INST_RST_EN_1_PWM8_RST_EN_Msk     (0x8000000UL)             /*!< PCR_INST RST_EN_1: PWM8_RST_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_RST_EN_1_EC_REG_BANK_RST_EN_Pos (29UL)                 /*!< PCR_INST RST_EN_1: EC_REG_BANK_RST_EN (Bit 29)              */
#define PCR_INST_RST_EN_1_EC_REG_BANK_RST_EN_Msk (0x20000000UL)         /*!< PCR_INST RST_EN_1: EC_REG_BANK_RST_EN (Bitfield-Mask: 0x01) */
#define PCR_INST_RST_EN_1_TIMER16_0_RST_EN_Pos (30UL)                   /*!< PCR_INST RST_EN_1: TIMER16_0_RST_EN (Bit 30)                */
#define PCR_INST_RST_EN_1_TIMER16_0_RST_EN_Msk (0x40000000UL)           /*!< PCR_INST RST_EN_1: TIMER16_0_RST_EN (Bitfield-Mask: 0x01)   */
#define PCR_INST_RST_EN_1_TIMER16_1_RST_EN_Pos (31UL)                   /*!< PCR_INST RST_EN_1: TIMER16_1_RST_EN (Bit 31)                */
#define PCR_INST_RST_EN_1_TIMER16_1_RST_EN_Msk (0x80000000UL)           /*!< PCR_INST RST_EN_1: TIMER16_1_RST_EN (Bitfield-Mask: 0x01)   */

/* ------------------------------  PCR_INST_RST_EN_2  ----------------------------- */
#define PCR_INST_RST_EN_2_UART_0_RST_EN_Pos   (1UL)                     /*!< PCR_INST RST_EN_2: UART_0_RST_EN (Bit 1)                    */
#define PCR_INST_RST_EN_2_UART_0_RST_EN_Msk   (0x2UL)                   /*!< PCR_INST RST_EN_2: UART_0_RST_EN (Bitfield-Mask: 0x01)      */
#define PCR_INST_RST_EN_2_UART_1_RST_EN_Pos   (2UL)                     /*!< PCR_INST RST_EN_2: UART_1_RST_EN (Bit 2)                    */
#define PCR_INST_RST_EN_2_UART_1_RST_EN_Msk   (0x4UL)                   /*!< PCR_INST RST_EN_2: UART_1_RST_EN (Bitfield-Mask: 0x01)      */
#define PCR_INST_RST_EN_2_GLBL_CFG_RST_EN_Pos (12UL)                    /*!< PCR_INST RST_EN_2: GLBL_CFG_RST_EN (Bit 12)                 */
#define PCR_INST_RST_EN_2_GLBL_CFG_RST_EN_Msk (0x1000UL)                /*!< PCR_INST RST_EN_2: GLBL_CFG_RST_EN (Bitfield-Mask: 0x01)    */
#define PCR_INST_RST_EN_2_RTC_RST_EN_Pos      (18UL)                    /*!< PCR_INST RST_EN_2: RTC_RST_EN (Bit 18)                      */
#define PCR_INST_RST_EN_2_RTC_RST_EN_Msk      (0x40000UL)               /*!< PCR_INST RST_EN_2: RTC_RST_EN (Bitfield-Mask: 0x01)         */

/* ------------------------------  PCR_INST_RST_EN_3  ----------------------------- */
#define PCR_INST_RST_EN_3_ADC_RST_EN_Pos      (3UL)                     /*!< PCR_INST RST_EN_3: ADC_RST_EN (Bit 3)                       */
#define PCR_INST_RST_EN_3_ADC_RST_EN_Msk      (0x8UL)                   /*!< PCR_INST RST_EN_3: ADC_RST_EN (Bitfield-Mask: 0x01)         */
#define PCR_INST_RST_EN_3_GP_SPI0_RST_EN_Pos  (9UL)                     /*!< PCR_INST RST_EN_3: GP_SPI0_RST_EN (Bit 9)                   */
#define PCR_INST_RST_EN_3_GP_SPI0_RST_EN_Msk  (0x200UL)                 /*!< PCR_INST RST_EN_3: GP_SPI0_RST_EN (Bitfield-Mask: 0x01)     */
#define PCR_INST_RST_EN_3_HTIMER_0_RST_EN_Pos (10UL)                    /*!< PCR_INST RST_EN_3: HTIMER_0_RST_EN (Bit 10)                 */
#define PCR_INST_RST_EN_3_HTIMER_0_RST_EN_Msk (0x400UL)                 /*!< PCR_INST RST_EN_3: HTIMER_0_RST_EN (Bitfield-Mask: 0x01)    */
#define PCR_INST_RST_EN_3_KEYSCAN_RST_EN_Pos  (11UL)                    /*!< PCR_INST RST_EN_3: KEYSCAN_RST_EN (Bit 11)                  */
#define PCR_INST_RST_EN_3_KEYSCAN_RST_EN_Msk  (0x800UL)                 /*!< PCR_INST RST_EN_3: KEYSCAN_RST_EN (Bitfield-Mask: 0x01)     */
#define PCR_INST_RST_EN_3_RPMPWM0_RST_EN_Pos  (12UL)                    /*!< PCR_INST RST_EN_3: RPMPWM0_RST_EN (Bit 12)                  */
#define PCR_INST_RST_EN_3_RPMPWM0_RST_EN_Msk  (0x1000UL)                /*!< PCR_INST RST_EN_3: RPMPWM0_RST_EN (Bitfield-Mask: 0x01)     */
#define PCR_INST_RST_EN_3_SMB1_RST_EN_Pos     (13UL)                    /*!< PCR_INST RST_EN_3: SMB1_RST_EN (Bit 13)                     */
#define PCR_INST_RST_EN_3_SMB1_RST_EN_Msk     (0x2000UL)                /*!< PCR_INST RST_EN_3: SMB1_RST_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_RST_EN_3_SMB2_RST_EN_Pos     (14UL)                    /*!< PCR_INST RST_EN_3: SMB2_RST_EN (Bit 14)                     */
#define PCR_INST_RST_EN_3_SMB2_RST_EN_Msk     (0x4000UL)                /*!< PCR_INST RST_EN_3: SMB2_RST_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_RST_EN_3_SMB3_RST_EN_Pos     (15UL)                    /*!< PCR_INST RST_EN_3: SMB3_RST_EN (Bit 15)                     */
#define PCR_INST_RST_EN_3_SMB3_RST_EN_Msk     (0x8000UL)                /*!< PCR_INST RST_EN_3: SMB3_RST_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_RST_EN_3_LED0_RST_EN_Pos     (16UL)                    /*!< PCR_INST RST_EN_3: LED0_RST_EN (Bit 16)                     */
#define PCR_INST_RST_EN_3_LED0_RST_EN_Msk     (0x10000UL)               /*!< PCR_INST RST_EN_3: LED0_RST_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_RST_EN_3_LED1_RST_EN_Pos     (17UL)                    /*!< PCR_INST RST_EN_3: LED1_RST_EN (Bit 17)                     */
#define PCR_INST_RST_EN_3_LED1_RST_EN_Msk     (0x20000UL)               /*!< PCR_INST RST_EN_3: LED1_RST_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_RST_EN_3_LED2_RST_EN_Pos     (18UL)                    /*!< PCR_INST RST_EN_3: LED2_RST_EN (Bit 18)                     */
#define PCR_INST_RST_EN_3_LED2_RST_EN_Msk     (0x40000UL)               /*!< PCR_INST RST_EN_3: LED2_RST_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_RST_EN_3_GP_SPI1_RST_EN_Pos  (20UL)                    /*!< PCR_INST RST_EN_3: GP_SPI1_RST_EN (Bit 20)                  */
#define PCR_INST_RST_EN_3_GP_SPI1_RST_EN_Msk  (0x100000UL)              /*!< PCR_INST RST_EN_3: GP_SPI1_RST_EN (Bitfield-Mask: 0x01)     */
#define PCR_INST_RST_EN_3_TIMER16_2_RST_EN_Pos (21UL)                   /*!< PCR_INST RST_EN_3: TIMER16_2_RST_EN (Bit 21)                */
#define PCR_INST_RST_EN_3_TIMER16_2_RST_EN_Msk (0x200000UL)             /*!< PCR_INST RST_EN_3: TIMER16_2_RST_EN (Bitfield-Mask: 0x01)   */
#define PCR_INST_RST_EN_3_TIMER16_3_RST_EN_Pos (22UL)                   /*!< PCR_INST RST_EN_3: TIMER16_3_RST_EN (Bit 22)                */
#define PCR_INST_RST_EN_3_TIMER16_3_RST_EN_Msk (0x400000UL)             /*!< PCR_INST RST_EN_3: TIMER16_3_RST_EN (Bitfield-Mask: 0x01)   */
#define PCR_INST_RST_EN_3_TIMER32_0_RST_EN_Pos (23UL)                   /*!< PCR_INST RST_EN_3: TIMER32_0_RST_EN (Bit 23)                */
#define PCR_INST_RST_EN_3_TIMER32_0_RST_EN_Msk (0x800000UL)             /*!< PCR_INST RST_EN_3: TIMER32_0_RST_EN (Bitfield-Mask: 0x01)   */
#define PCR_INST_RST_EN_3_TIMER32_1_RST_EN_Pos (24UL)                   /*!< PCR_INST RST_EN_3: TIMER32_1_RST_EN (Bit 24)                */
#define PCR_INST_RST_EN_3_TIMER32_1_RST_EN_Msk (0x1000000UL)            /*!< PCR_INST RST_EN_3: TIMER32_1_RST_EN (Bitfield-Mask: 0x01)   */
#define PCR_INST_RST_EN_3_LED3_RST_EN_Pos     (25UL)                    /*!< PCR_INST RST_EN_3: LED3_RST_EN (Bit 25)                     */
#define PCR_INST_RST_EN_3_LED3_RST_EN_Msk     (0x2000000UL)             /*!< PCR_INST RST_EN_3: LED3_RST_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_RST_EN_3_PKE_RST_EN_Pos      (26UL)                    /*!< PCR_INST RST_EN_3: PKE_RST_EN (Bit 26)                      */
#define PCR_INST_RST_EN_3_PKE_RST_EN_Msk      (0x4000000UL)             /*!< PCR_INST RST_EN_3: PKE_RST_EN (Bitfield-Mask: 0x01)         */
#define PCR_INST_RST_EN_3_RNG_RST_EN_Pos      (27UL)                    /*!< PCR_INST RST_EN_3: RNG_RST_EN (Bit 27)                      */
#define PCR_INST_RST_EN_3_RNG_RST_EN_Msk      (0x8000000UL)             /*!< PCR_INST RST_EN_3: RNG_RST_EN (Bitfield-Mask: 0x01)         */
#define PCR_INST_RST_EN_3_AES_HASH_RST_EN_Pos (28UL)                    /*!< PCR_INST RST_EN_3: AES_HASH_RST_EN (Bit 28)                 */
#define PCR_INST_RST_EN_3_AES_HASH_RST_EN_Msk (0x10000000UL)            /*!< PCR_INST RST_EN_3: AES_HASH_RST_EN (Bitfield-Mask: 0x01)    */
#define PCR_INST_RST_EN_3_HTIMER_1_RST_EN_Pos (29UL)                    /*!< PCR_INST RST_EN_3: HTIMER_1_RST_EN (Bit 29)                 */
#define PCR_INST_RST_EN_3_HTIMER_1_RST_EN_Msk (0x20000000UL)            /*!< PCR_INST RST_EN_3: HTIMER_1_RST_EN (Bitfield-Mask: 0x01)    */
#define PCR_INST_RST_EN_3_CCTIMER_RST_EN_Pos  (30UL)                    /*!< PCR_INST RST_EN_3: CCTIMER_RST_EN (Bit 30)                  */
#define PCR_INST_RST_EN_3_CCTIMER_RST_EN_Msk  (0x40000000UL)            /*!< PCR_INST RST_EN_3: CCTIMER_RST_EN (Bitfield-Mask: 0x01)     */
#define PCR_INST_RST_EN_3_PWM9_RST_EN_Pos     (31UL)                    /*!< PCR_INST RST_EN_3: PWM9_RST_EN (Bit 31)                     */
#define PCR_INST_RST_EN_3_PWM9_RST_EN_Msk     (0x80000000UL)            /*!< PCR_INST RST_EN_3: PWM9_RST_EN (Bitfield-Mask: 0x01)        */

/* ------------------------------  PCR_INST_RST_EN_4  ----------------------------- */
#define PCR_INST_RST_EN_4_PWM10_RST_EN_Pos    (0UL)                     /*!< PCR_INST RST_EN_4: PWM10_RST_EN (Bit 0)                     */
#define PCR_INST_RST_EN_4_PWM10_RST_EN_Msk    (0x1UL)                   /*!< PCR_INST RST_EN_4: PWM10_RST_EN (Bitfield-Mask: 0x01)       */
#define PCR_INST_RST_EN_4_PWM11_RST_EN_Pos    (1UL)                     /*!< PCR_INST RST_EN_4: PWM11_RST_EN (Bit 1)                     */
#define PCR_INST_RST_EN_4_PWM11_RST_EN_Msk    (0x2UL)                   /*!< PCR_INST RST_EN_4: PWM11_RST_EN (Bitfield-Mask: 0x01)       */
#define PCR_INST_RST_EN_4_CNT_TMER0_RST_EN_Pos (2UL)                    /*!< PCR_INST RST_EN_4: CNT_TMER0_RST_EN (Bit 2)                 */
#define PCR_INST_RST_EN_4_CNT_TMER0_RST_EN_Msk (0x4UL)                  /*!< PCR_INST RST_EN_4: CNT_TMER0_RST_EN (Bitfield-Mask: 0x01)   */
#define PCR_INST_RST_EN_4_CNT_TMER1_RST_EN_Pos (3UL)                    /*!< PCR_INST RST_EN_4: CNT_TMER1_RST_EN (Bit 3)                 */
#define PCR_INST_RST_EN_4_CNT_TMER1_RST_EN_Msk (0x8UL)                  /*!< PCR_INST RST_EN_4: CNT_TMER1_RST_EN (Bitfield-Mask: 0x01)   */
#define PCR_INST_RST_EN_4_CNT_TMER2_RST_EN_Pos (4UL)                    /*!< PCR_INST RST_EN_4: CNT_TMER2_RST_EN (Bit 4)                 */
#define PCR_INST_RST_EN_4_CNT_TMER2_RST_EN_Msk (0x10UL)                 /*!< PCR_INST RST_EN_4: CNT_TMER2_RST_EN (Bitfield-Mask: 0x01)   */
#define PCR_INST_RST_EN_4_CNT_TMER3_RST_EN_Pos (5UL)                    /*!< PCR_INST RST_EN_4: CNT_TMER3_RST_EN (Bit 5)                 */
#define PCR_INST_RST_EN_4_CNT_TMER3_RST_EN_Msk (0x20UL)                 /*!< PCR_INST RST_EN_4: CNT_TMER3_RST_EN (Bitfield-Mask: 0x01)   */
#define PCR_INST_RST_EN_4_RTOS_RST_EN_Pos     (6UL)                     /*!< PCR_INST RST_EN_4: RTOS_RST_EN (Bit 6)                      */
#define PCR_INST_RST_EN_4_RTOS_RST_EN_Msk     (0x40UL)                  /*!< PCR_INST RST_EN_4: RTOS_RST_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_RST_EN_4_RPMPWM1_RST_EN_Pos  (7UL)                     /*!< PCR_INST RST_EN_4: RPMPWM1_RST_EN (Bit 7)                   */
#define PCR_INST_RST_EN_4_RPMPWM1_RST_EN_Msk  (0x80UL)                  /*!< PCR_INST RST_EN_4: RPMPWM1_RST_EN (Bitfield-Mask: 0x01)     */
#define PCR_INST_RST_EN_4_QSPI_RST_EN_Pos     (8UL)                     /*!< PCR_INST RST_EN_4: QSPI_RST_EN (Bit 8)                      */
#define PCR_INST_RST_EN_4_QSPI_RST_EN_Msk     (0x100UL)                 /*!< PCR_INST RST_EN_4: QSPI_RST_EN (Bitfield-Mask: 0x01)        */
#define PCR_INST_RST_EN_4_RC_ID0_RST_EN_Pos   (10UL)                    /*!< PCR_INST RST_EN_4: RC_ID0_RST_EN (Bit 10)                   */
#define PCR_INST_RST_EN_4_RC_ID0_RST_EN_Msk   (0x400UL)                 /*!< PCR_INST RST_EN_4: RC_ID0_RST_EN (Bitfield-Mask: 0x01)      */
#define PCR_INST_RST_EN_4_RC_ID1_RST_EN_Pos   (11UL)                    /*!< PCR_INST RST_EN_4: RC_ID1_RST_EN (Bit 11)                   */
#define PCR_INST_RST_EN_4_RC_ID1_RST_EN_Msk   (0x800UL)                 /*!< PCR_INST RST_EN_4: RC_ID1_RST_EN (Bitfield-Mask: 0x01)      */
#define PCR_INST_RST_EN_4_RC_ID2_RST_EN_Pos   (12UL)                    /*!< PCR_INST RST_EN_4: RC_ID2_RST_EN (Bit 12)                   */
#define PCR_INST_RST_EN_4_RC_ID2_RST_EN_Msk   (0x1000UL)                /*!< PCR_INST RST_EN_4: RC_ID2_RST_EN (Bitfield-Mask: 0x01)      */


/* ================================================================================ */
/* ================     struct 'DMA_MAIN_INST' Position & Mask     ================ */
/* ================================================================================ */


/* -----------------------  DMA_MAIN_INST_DMA_MAIN_CONTROL  ----------------------- */
#define DMA_MAIN_INST_DMA_MAIN_CONTROL_ACTIVATE_Pos (0UL)               /*!< DMA_MAIN_INST DMA_MAIN_CONTROL: ACTIVATE (Bit 0)            */
#define DMA_MAIN_INST_DMA_MAIN_CONTROL_ACTIVATE_Msk (0x1UL)             /*!< DMA_MAIN_INST DMA_MAIN_CONTROL: ACTIVATE (Bitfield-Mask: 0x01) */
#define DMA_MAIN_INST_DMA_MAIN_CONTROL_SOFT_RESET_Pos (1UL)             /*!< DMA_MAIN_INST DMA_MAIN_CONTROL: SOFT_RESET (Bit 1)          */
#define DMA_MAIN_INST_DMA_MAIN_CONTROL_SOFT_RESET_Msk (0x2UL)           /*!< DMA_MAIN_INST DMA_MAIN_CONTROL: SOFT_RESET (Bitfield-Mask: 0x01) */


/* ================================================================================ */
/* ================    struct 'DMA_CHAN00_INST' Position & Mask    ================ */
/* ================================================================================ */


/* --------------------  DMA_CHAN00_INST_DMA_CHANNEL_ACTIVATE  -------------------- */
#define DMA_CHAN00_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Pos (0UL) /*!< DMA_CHAN00_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bit 0) */
#define DMA_CHAN00_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Msk (0x1UL) /*!< DMA_CHAN00_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bitfield-Mask: 0x01) */

/* ---------------------------  DMA_CHAN00_INST_CONTROL  -------------------------- */
#define DMA_CHAN00_INST_CONTROL_RUN_Pos       (0UL)                     /*!< DMA_CHAN00_INST CONTROL: RUN (Bit 0)                        */
#define DMA_CHAN00_INST_CONTROL_RUN_Msk       (0x1UL)                   /*!< DMA_CHAN00_INST CONTROL: RUN (Bitfield-Mask: 0x01)          */
#define DMA_CHAN00_INST_CONTROL_REQUEST_Pos   (1UL)                     /*!< DMA_CHAN00_INST CONTROL: REQUEST (Bit 1)                    */
#define DMA_CHAN00_INST_CONTROL_REQUEST_Msk   (0x2UL)                   /*!< DMA_CHAN00_INST CONTROL: REQUEST (Bitfield-Mask: 0x01)      */
#define DMA_CHAN00_INST_CONTROL_DONE_Pos      (2UL)                     /*!< DMA_CHAN00_INST CONTROL: DONE (Bit 2)                       */
#define DMA_CHAN00_INST_CONTROL_DONE_Msk      (0x4UL)                   /*!< DMA_CHAN00_INST CONTROL: DONE (Bitfield-Mask: 0x01)         */
#define DMA_CHAN00_INST_CONTROL_STATUS_Pos    (3UL)                     /*!< DMA_CHAN00_INST CONTROL: STATUS (Bit 3)                     */
#define DMA_CHAN00_INST_CONTROL_STATUS_Msk    (0x18UL)                  /*!< DMA_CHAN00_INST CONTROL: STATUS (Bitfield-Mask: 0x03)       */
#define DMA_CHAN00_INST_CONTROL_BUSY_Pos      (5UL)                     /*!< DMA_CHAN00_INST CONTROL: BUSY (Bit 5)                       */
#define DMA_CHAN00_INST_CONTROL_BUSY_Msk      (0x20UL)                  /*!< DMA_CHAN00_INST CONTROL: BUSY (Bitfield-Mask: 0x01)         */
#define DMA_CHAN00_INST_CONTROL_TX_DIRECTION_Pos (8UL)                  /*!< DMA_CHAN00_INST CONTROL: TX_DIRECTION (Bit 8)               */
#define DMA_CHAN00_INST_CONTROL_TX_DIRECTION_Msk (0x100UL)              /*!< DMA_CHAN00_INST CONTROL: TX_DIRECTION (Bitfield-Mask: 0x01) */
#define DMA_CHAN00_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Pos (9UL)  /*!< DMA_CHAN00_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bit 9) */
#define DMA_CHAN00_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Msk (0xfe00UL) /*!< DMA_CHAN00_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bitfield-Mask: 0x7f) */
#define DMA_CHAN00_INST_CONTROL_INCREMENT_MEM_ADDR_Pos (16UL)           /*!< DMA_CHAN00_INST CONTROL: INCREMENT_MEM_ADDR (Bit 16)        */
#define DMA_CHAN00_INST_CONTROL_INCREMENT_MEM_ADDR_Msk (0x10000UL)      /*!< DMA_CHAN00_INST CONTROL: INCREMENT_MEM_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN00_INST_CONTROL_INCREMENT_DEVICE_ADDR_Pos (17UL)        /*!< DMA_CHAN00_INST CONTROL: INCREMENT_DEVICE_ADDR (Bit 17)     */
#define DMA_CHAN00_INST_CONTROL_INCREMENT_DEVICE_ADDR_Msk (0x20000UL)   /*!< DMA_CHAN00_INST CONTROL: INCREMENT_DEVICE_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN00_INST_CONTROL_LOCK_Pos      (18UL)                    /*!< DMA_CHAN00_INST CONTROL: LOCK (Bit 18)                      */
#define DMA_CHAN00_INST_CONTROL_LOCK_Msk      (0x40000UL)               /*!< DMA_CHAN00_INST CONTROL: LOCK (Bitfield-Mask: 0x01)         */
#define DMA_CHAN00_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Pos (19UL)      /*!< DMA_CHAN00_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bit 19)   */
#define DMA_CHAN00_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Msk (0x80000UL) /*!< DMA_CHAN00_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN00_INST_CONTROL_TRANSFER_SIZE_Pos (20UL)                /*!< DMA_CHAN00_INST CONTROL: TRANSFER_SIZE (Bit 20)             */
#define DMA_CHAN00_INST_CONTROL_TRANSFER_SIZE_Msk (0x700000UL)          /*!< DMA_CHAN00_INST CONTROL: TRANSFER_SIZE (Bitfield-Mask: 0x07) */
#define DMA_CHAN00_INST_CONTROL_TRANSFER_GO_Pos (24UL)                  /*!< DMA_CHAN00_INST CONTROL: TRANSFER_GO (Bit 24)               */
#define DMA_CHAN00_INST_CONTROL_TRANSFER_GO_Msk (0x1000000UL)           /*!< DMA_CHAN00_INST CONTROL: TRANSFER_GO (Bitfield-Mask: 0x01)  */
#define DMA_CHAN00_INST_CONTROL_TRANSFER_ABORT_Pos (25UL)               /*!< DMA_CHAN00_INST CONTROL: TRANSFER_ABORT (Bit 25)            */
#define DMA_CHAN00_INST_CONTROL_TRANSFER_ABORT_Msk (0x2000000UL)        /*!< DMA_CHAN00_INST CONTROL: TRANSFER_ABORT (Bitfield-Mask: 0x01) */

/* -------------------------  DMA_CHAN00_INST_INT_STATUS  ------------------------- */
#define DMA_CHAN00_INST_INT_STATUS_BUS_ERROR_Pos (0UL)                  /*!< DMA_CHAN00_INST INT_STATUS: BUS_ERROR (Bit 0)               */
#define DMA_CHAN00_INST_INT_STATUS_BUS_ERROR_Msk (0x1UL)                /*!< DMA_CHAN00_INST INT_STATUS: BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN00_INST_INT_STATUS_FLOW_CONTROL_Pos (1UL)               /*!< DMA_CHAN00_INST INT_STATUS: FLOW_CONTROL (Bit 1)            */
#define DMA_CHAN00_INST_INT_STATUS_FLOW_CONTROL_Msk (0x2UL)             /*!< DMA_CHAN00_INST INT_STATUS: FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN00_INST_INT_STATUS_DONE_Pos   (2UL)                     /*!< DMA_CHAN00_INST INT_STATUS: DONE (Bit 2)                    */
#define DMA_CHAN00_INST_INT_STATUS_DONE_Msk   (0x4UL)                   /*!< DMA_CHAN00_INST INT_STATUS: DONE (Bitfield-Mask: 0x01)      */

/* ---------------------------  DMA_CHAN00_INST_INT_EN  --------------------------- */
#define DMA_CHAN00_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Pos (0UL)        /*!< DMA_CHAN00_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bit 0)     */
#define DMA_CHAN00_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Msk (0x1UL)      /*!< DMA_CHAN00_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN00_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Pos (1UL)     /*!< DMA_CHAN00_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bit 1)  */
#define DMA_CHAN00_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Msk (0x2UL)   /*!< DMA_CHAN00_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN00_INST_INT_EN_STATUS_ENABLE_DONE_Pos (2UL)             /*!< DMA_CHAN00_INST INT_EN: STATUS_ENABLE_DONE (Bit 2)          */
#define DMA_CHAN00_INST_INT_EN_STATUS_ENABLE_DONE_Msk (0x4UL)           /*!< DMA_CHAN00_INST INT_EN: STATUS_ENABLE_DONE (Bitfield-Mask: 0x01) */

/* -------------------------  DMA_CHAN00_INST_CRC_ENABLE  ------------------------- */
#define DMA_CHAN00_INST_CRC_ENABLE_CRC_MODE_ENABLE_Pos (0UL)            /*!< DMA_CHAN00_INST CRC_ENABLE: CRC_MODE_ENABLE (Bit 0)         */
#define DMA_CHAN00_INST_CRC_ENABLE_CRC_MODE_ENABLE_Msk (0x1UL)          /*!< DMA_CHAN00_INST CRC_ENABLE: CRC_MODE_ENABLE (Bitfield-Mask: 0x01) */
#define DMA_CHAN00_INST_CRC_ENABLE_CRC_POST_TRANSFER_ENABLE_Pos (1UL)   /*!< DMA_CHAN00_INST CRC_ENABLE: CRC_POST_TRANSFER_ENABLE (Bit 1) */
#define DMA_CHAN00_INST_CRC_ENABLE_CRC_POST_TRANSFER_ENABLE_Msk (0x2UL) /*!< DMA_CHAN00_INST CRC_ENABLE: CRC_POST_TRANSFER_ENABLE (Bitfield-Mask: 0x01) */

/* --------------------------  DMA_CHAN00_INST_CRC_DATA  -------------------------- */
#define DMA_CHAN00_INST_CRC_DATA_CRC_Pos      (0UL)                     /*!< DMA_CHAN00_INST CRC_DATA: CRC (Bit 0)                       */
#define DMA_CHAN00_INST_CRC_DATA_CRC_Msk      (0xffffffffUL)            /*!< DMA_CHAN00_INST CRC_DATA: CRC (Bitfield-Mask: 0xffffffff)   */

/* -----------------------  DMA_CHAN00_INST_CRC_POST_STATUS  ---------------------- */
#define DMA_CHAN00_INST_CRC_POST_STATUS_CRC_DONE_Pos (0UL)              /*!< DMA_CHAN00_INST CRC_POST_STATUS: CRC_DONE (Bit 0)           */
#define DMA_CHAN00_INST_CRC_POST_STATUS_CRC_DONE_Msk (0x1UL)            /*!< DMA_CHAN00_INST CRC_POST_STATUS: CRC_DONE (Bitfield-Mask: 0x01) */
#define DMA_CHAN00_INST_CRC_POST_STATUS_CRC_RUNNING_Pos (1UL)           /*!< DMA_CHAN00_INST CRC_POST_STATUS: CRC_RUNNING (Bit 1)        */
#define DMA_CHAN00_INST_CRC_POST_STATUS_CRC_RUNNING_Msk (0x2UL)         /*!< DMA_CHAN00_INST CRC_POST_STATUS: CRC_RUNNING (Bitfield-Mask: 0x01) */
#define DMA_CHAN00_INST_CRC_POST_STATUS_CRC_DATA_DONE_Pos (2UL)         /*!< DMA_CHAN00_INST CRC_POST_STATUS: CRC_DATA_DONE (Bit 2)      */
#define DMA_CHAN00_INST_CRC_POST_STATUS_CRC_DATA_DONE_Msk (0x4UL)       /*!< DMA_CHAN00_INST CRC_POST_STATUS: CRC_DATA_DONE (Bitfield-Mask: 0x01) */
#define DMA_CHAN00_INST_CRC_POST_STATUS_CRC_DATA_READY_Pos (3UL)        /*!< DMA_CHAN00_INST CRC_POST_STATUS: CRC_DATA_READY (Bit 3)     */
#define DMA_CHAN00_INST_CRC_POST_STATUS_CRC_DATA_READY_Msk (0x8UL)      /*!< DMA_CHAN00_INST CRC_POST_STATUS: CRC_DATA_READY (Bitfield-Mask: 0x01) */


/* ================================================================================ */
/* ================    struct 'DMA_CHAN01_INST' Position & Mask    ================ */
/* ================================================================================ */


/* --------------------  DMA_CHAN01_INST_DMA_CHANNEL_ACTIVATE  -------------------- */
#define DMA_CHAN01_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Pos (0UL) /*!< DMA_CHAN01_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bit 0) */
#define DMA_CHAN01_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Msk (0x1UL) /*!< DMA_CHAN01_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bitfield-Mask: 0x01) */

/* ---------------------------  DMA_CHAN01_INST_CONTROL  -------------------------- */
#define DMA_CHAN01_INST_CONTROL_RUN_Pos       (0UL)                     /*!< DMA_CHAN01_INST CONTROL: RUN (Bit 0)                        */
#define DMA_CHAN01_INST_CONTROL_RUN_Msk       (0x1UL)                   /*!< DMA_CHAN01_INST CONTROL: RUN (Bitfield-Mask: 0x01)          */
#define DMA_CHAN01_INST_CONTROL_REQUEST_Pos   (1UL)                     /*!< DMA_CHAN01_INST CONTROL: REQUEST (Bit 1)                    */
#define DMA_CHAN01_INST_CONTROL_REQUEST_Msk   (0x2UL)                   /*!< DMA_CHAN01_INST CONTROL: REQUEST (Bitfield-Mask: 0x01)      */
#define DMA_CHAN01_INST_CONTROL_DONE_Pos      (2UL)                     /*!< DMA_CHAN01_INST CONTROL: DONE (Bit 2)                       */
#define DMA_CHAN01_INST_CONTROL_DONE_Msk      (0x4UL)                   /*!< DMA_CHAN01_INST CONTROL: DONE (Bitfield-Mask: 0x01)         */
#define DMA_CHAN01_INST_CONTROL_STATUS_Pos    (3UL)                     /*!< DMA_CHAN01_INST CONTROL: STATUS (Bit 3)                     */
#define DMA_CHAN01_INST_CONTROL_STATUS_Msk    (0x18UL)                  /*!< DMA_CHAN01_INST CONTROL: STATUS (Bitfield-Mask: 0x03)       */
#define DMA_CHAN01_INST_CONTROL_BUSY_Pos      (5UL)                     /*!< DMA_CHAN01_INST CONTROL: BUSY (Bit 5)                       */
#define DMA_CHAN01_INST_CONTROL_BUSY_Msk      (0x20UL)                  /*!< DMA_CHAN01_INST CONTROL: BUSY (Bitfield-Mask: 0x01)         */
#define DMA_CHAN01_INST_CONTROL_TX_DIRECTION_Pos (8UL)                  /*!< DMA_CHAN01_INST CONTROL: TX_DIRECTION (Bit 8)               */
#define DMA_CHAN01_INST_CONTROL_TX_DIRECTION_Msk (0x100UL)              /*!< DMA_CHAN01_INST CONTROL: TX_DIRECTION (Bitfield-Mask: 0x01) */
#define DMA_CHAN01_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Pos (9UL)  /*!< DMA_CHAN01_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bit 9) */
#define DMA_CHAN01_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Msk (0xfe00UL) /*!< DMA_CHAN01_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bitfield-Mask: 0x7f) */
#define DMA_CHAN01_INST_CONTROL_INCREMENT_MEM_ADDR_Pos (16UL)           /*!< DMA_CHAN01_INST CONTROL: INCREMENT_MEM_ADDR (Bit 16)        */
#define DMA_CHAN01_INST_CONTROL_INCREMENT_MEM_ADDR_Msk (0x10000UL)      /*!< DMA_CHAN01_INST CONTROL: INCREMENT_MEM_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN01_INST_CONTROL_INCREMENT_DEVICE_ADDR_Pos (17UL)        /*!< DMA_CHAN01_INST CONTROL: INCREMENT_DEVICE_ADDR (Bit 17)     */
#define DMA_CHAN01_INST_CONTROL_INCREMENT_DEVICE_ADDR_Msk (0x20000UL)   /*!< DMA_CHAN01_INST CONTROL: INCREMENT_DEVICE_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN01_INST_CONTROL_LOCK_Pos      (18UL)                    /*!< DMA_CHAN01_INST CONTROL: LOCK (Bit 18)                      */
#define DMA_CHAN01_INST_CONTROL_LOCK_Msk      (0x40000UL)               /*!< DMA_CHAN01_INST CONTROL: LOCK (Bitfield-Mask: 0x01)         */
#define DMA_CHAN01_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Pos (19UL)      /*!< DMA_CHAN01_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bit 19)   */
#define DMA_CHAN01_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Msk (0x80000UL) /*!< DMA_CHAN01_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN01_INST_CONTROL_TRANSFER_SIZE_Pos (20UL)                /*!< DMA_CHAN01_INST CONTROL: TRANSFER_SIZE (Bit 20)             */
#define DMA_CHAN01_INST_CONTROL_TRANSFER_SIZE_Msk (0x700000UL)          /*!< DMA_CHAN01_INST CONTROL: TRANSFER_SIZE (Bitfield-Mask: 0x07) */
#define DMA_CHAN01_INST_CONTROL_TRANSFER_GO_Pos (24UL)                  /*!< DMA_CHAN01_INST CONTROL: TRANSFER_GO (Bit 24)               */
#define DMA_CHAN01_INST_CONTROL_TRANSFER_GO_Msk (0x1000000UL)           /*!< DMA_CHAN01_INST CONTROL: TRANSFER_GO (Bitfield-Mask: 0x01)  */
#define DMA_CHAN01_INST_CONTROL_TRANSFER_ABORT_Pos (25UL)               /*!< DMA_CHAN01_INST CONTROL: TRANSFER_ABORT (Bit 25)            */
#define DMA_CHAN01_INST_CONTROL_TRANSFER_ABORT_Msk (0x2000000UL)        /*!< DMA_CHAN01_INST CONTROL: TRANSFER_ABORT (Bitfield-Mask: 0x01) */

/* -------------------------  DMA_CHAN01_INST_INT_STATUS  ------------------------- */
#define DMA_CHAN01_INST_INT_STATUS_BUS_ERROR_Pos (0UL)                  /*!< DMA_CHAN01_INST INT_STATUS: BUS_ERROR (Bit 0)               */
#define DMA_CHAN01_INST_INT_STATUS_BUS_ERROR_Msk (0x1UL)                /*!< DMA_CHAN01_INST INT_STATUS: BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN01_INST_INT_STATUS_FLOW_CONTROL_Pos (1UL)               /*!< DMA_CHAN01_INST INT_STATUS: FLOW_CONTROL (Bit 1)            */
#define DMA_CHAN01_INST_INT_STATUS_FLOW_CONTROL_Msk (0x2UL)             /*!< DMA_CHAN01_INST INT_STATUS: FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN01_INST_INT_STATUS_DONE_Pos   (2UL)                     /*!< DMA_CHAN01_INST INT_STATUS: DONE (Bit 2)                    */
#define DMA_CHAN01_INST_INT_STATUS_DONE_Msk   (0x4UL)                   /*!< DMA_CHAN01_INST INT_STATUS: DONE (Bitfield-Mask: 0x01)      */

/* ---------------------------  DMA_CHAN01_INST_INT_EN  --------------------------- */
#define DMA_CHAN01_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Pos (0UL)        /*!< DMA_CHAN01_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bit 0)     */
#define DMA_CHAN01_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Msk (0x1UL)      /*!< DMA_CHAN01_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN01_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Pos (1UL)     /*!< DMA_CHAN01_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bit 1)  */
#define DMA_CHAN01_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Msk (0x2UL)   /*!< DMA_CHAN01_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN01_INST_INT_EN_STATUS_ENABLE_DONE_Pos (2UL)             /*!< DMA_CHAN01_INST INT_EN: STATUS_ENABLE_DONE (Bit 2)          */
#define DMA_CHAN01_INST_INT_EN_STATUS_ENABLE_DONE_Msk (0x4UL)           /*!< DMA_CHAN01_INST INT_EN: STATUS_ENABLE_DONE (Bitfield-Mask: 0x01) */

/* -------------------------  DMA_CHAN01_INST_FILL_ENABLE  ------------------------ */
#define DMA_CHAN01_INST_FILL_ENABLE_FILL_MODE_ENABLE_Pos (0UL)          /*!< DMA_CHAN01_INST FILL_ENABLE: FILL_MODE_ENABLE (Bit 0)       */
#define DMA_CHAN01_INST_FILL_ENABLE_FILL_MODE_ENABLE_Msk (0x1UL)        /*!< DMA_CHAN01_INST FILL_ENABLE: FILL_MODE_ENABLE (Bitfield-Mask: 0x01) */

/* --------------------------  DMA_CHAN01_INST_FILL_DATA  ------------------------- */
#define DMA_CHAN01_INST_FILL_DATA_FILL_DATA_Pos (0UL)                   /*!< DMA_CHAN01_INST FILL_DATA: FILL_DATA (Bit 0)                */
#define DMA_CHAN01_INST_FILL_DATA_FILL_DATA_Msk (0xffffffffUL)          /*!< DMA_CHAN01_INST FILL_DATA: FILL_DATA (Bitfield-Mask: 0xffffffff) */

/* -------------------------  DMA_CHAN01_INST_FILL_STATUS  ------------------------ */
#define DMA_CHAN01_INST_FILL_STATUS_FILL_DONE_Pos (0UL)                 /*!< DMA_CHAN01_INST FILL_STATUS: FILL_DONE (Bit 0)              */
#define DMA_CHAN01_INST_FILL_STATUS_FILL_DONE_Msk (0x1UL)               /*!< DMA_CHAN01_INST FILL_STATUS: FILL_DONE (Bitfield-Mask: 0x01) */
#define DMA_CHAN01_INST_FILL_STATUS_FILL_RUNNING_Pos (1UL)              /*!< DMA_CHAN01_INST FILL_STATUS: FILL_RUNNING (Bit 1)           */
#define DMA_CHAN01_INST_FILL_STATUS_FILL_RUNNING_Msk (0x2UL)            /*!< DMA_CHAN01_INST FILL_STATUS: FILL_RUNNING (Bitfield-Mask: 0x01) */


/* ================================================================================ */
/* ================    struct 'DMA_CHAN02_INST' Position & Mask    ================ */
/* ================================================================================ */


/* --------------------  DMA_CHAN02_INST_DMA_CHANNEL_ACTIVATE  -------------------- */
#define DMA_CHAN02_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Pos (0UL) /*!< DMA_CHAN02_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bit 0) */
#define DMA_CHAN02_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Msk (0x1UL) /*!< DMA_CHAN02_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bitfield-Mask: 0x01) */

/* ---------------------------  DMA_CHAN02_INST_CONTROL  -------------------------- */
#define DMA_CHAN02_INST_CONTROL_RUN_Pos       (0UL)                     /*!< DMA_CHAN02_INST CONTROL: RUN (Bit 0)                        */
#define DMA_CHAN02_INST_CONTROL_RUN_Msk       (0x1UL)                   /*!< DMA_CHAN02_INST CONTROL: RUN (Bitfield-Mask: 0x01)          */
#define DMA_CHAN02_INST_CONTROL_REQUEST_Pos   (1UL)                     /*!< DMA_CHAN02_INST CONTROL: REQUEST (Bit 1)                    */
#define DMA_CHAN02_INST_CONTROL_REQUEST_Msk   (0x2UL)                   /*!< DMA_CHAN02_INST CONTROL: REQUEST (Bitfield-Mask: 0x01)      */
#define DMA_CHAN02_INST_CONTROL_DONE_Pos      (2UL)                     /*!< DMA_CHAN02_INST CONTROL: DONE (Bit 2)                       */
#define DMA_CHAN02_INST_CONTROL_DONE_Msk      (0x4UL)                   /*!< DMA_CHAN02_INST CONTROL: DONE (Bitfield-Mask: 0x01)         */
#define DMA_CHAN02_INST_CONTROL_STATUS_Pos    (3UL)                     /*!< DMA_CHAN02_INST CONTROL: STATUS (Bit 3)                     */
#define DMA_CHAN02_INST_CONTROL_STATUS_Msk    (0x18UL)                  /*!< DMA_CHAN02_INST CONTROL: STATUS (Bitfield-Mask: 0x03)       */
#define DMA_CHAN02_INST_CONTROL_BUSY_Pos      (5UL)                     /*!< DMA_CHAN02_INST CONTROL: BUSY (Bit 5)                       */
#define DMA_CHAN02_INST_CONTROL_BUSY_Msk      (0x20UL)                  /*!< DMA_CHAN02_INST CONTROL: BUSY (Bitfield-Mask: 0x01)         */
#define DMA_CHAN02_INST_CONTROL_TX_DIRECTION_Pos (8UL)                  /*!< DMA_CHAN02_INST CONTROL: TX_DIRECTION (Bit 8)               */
#define DMA_CHAN02_INST_CONTROL_TX_DIRECTION_Msk (0x100UL)              /*!< DMA_CHAN02_INST CONTROL: TX_DIRECTION (Bitfield-Mask: 0x01) */
#define DMA_CHAN02_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Pos (9UL)  /*!< DMA_CHAN02_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bit 9) */
#define DMA_CHAN02_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Msk (0xfe00UL) /*!< DMA_CHAN02_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bitfield-Mask: 0x7f) */
#define DMA_CHAN02_INST_CONTROL_INCREMENT_MEM_ADDR_Pos (16UL)           /*!< DMA_CHAN02_INST CONTROL: INCREMENT_MEM_ADDR (Bit 16)        */
#define DMA_CHAN02_INST_CONTROL_INCREMENT_MEM_ADDR_Msk (0x10000UL)      /*!< DMA_CHAN02_INST CONTROL: INCREMENT_MEM_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN02_INST_CONTROL_INCREMENT_DEVICE_ADDR_Pos (17UL)        /*!< DMA_CHAN02_INST CONTROL: INCREMENT_DEVICE_ADDR (Bit 17)     */
#define DMA_CHAN02_INST_CONTROL_INCREMENT_DEVICE_ADDR_Msk (0x20000UL)   /*!< DMA_CHAN02_INST CONTROL: INCREMENT_DEVICE_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN02_INST_CONTROL_LOCK_Pos      (18UL)                    /*!< DMA_CHAN02_INST CONTROL: LOCK (Bit 18)                      */
#define DMA_CHAN02_INST_CONTROL_LOCK_Msk      (0x40000UL)               /*!< DMA_CHAN02_INST CONTROL: LOCK (Bitfield-Mask: 0x01)         */
#define DMA_CHAN02_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Pos (19UL)      /*!< DMA_CHAN02_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bit 19)   */
#define DMA_CHAN02_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Msk (0x80000UL) /*!< DMA_CHAN02_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN02_INST_CONTROL_TRANSFER_SIZE_Pos (20UL)                /*!< DMA_CHAN02_INST CONTROL: TRANSFER_SIZE (Bit 20)             */
#define DMA_CHAN02_INST_CONTROL_TRANSFER_SIZE_Msk (0x700000UL)          /*!< DMA_CHAN02_INST CONTROL: TRANSFER_SIZE (Bitfield-Mask: 0x07) */
#define DMA_CHAN02_INST_CONTROL_TRANSFER_GO_Pos (24UL)                  /*!< DMA_CHAN02_INST CONTROL: TRANSFER_GO (Bit 24)               */
#define DMA_CHAN02_INST_CONTROL_TRANSFER_GO_Msk (0x1000000UL)           /*!< DMA_CHAN02_INST CONTROL: TRANSFER_GO (Bitfield-Mask: 0x01)  */
#define DMA_CHAN02_INST_CONTROL_TRANSFER_ABORT_Pos (25UL)               /*!< DMA_CHAN02_INST CONTROL: TRANSFER_ABORT (Bit 25)            */
#define DMA_CHAN02_INST_CONTROL_TRANSFER_ABORT_Msk (0x2000000UL)        /*!< DMA_CHAN02_INST CONTROL: TRANSFER_ABORT (Bitfield-Mask: 0x01) */

/* -------------------------  DMA_CHAN02_INST_INT_STATUS  ------------------------- */
#define DMA_CHAN02_INST_INT_STATUS_BUS_ERROR_Pos (0UL)                  /*!< DMA_CHAN02_INST INT_STATUS: BUS_ERROR (Bit 0)               */
#define DMA_CHAN02_INST_INT_STATUS_BUS_ERROR_Msk (0x1UL)                /*!< DMA_CHAN02_INST INT_STATUS: BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN02_INST_INT_STATUS_FLOW_CONTROL_Pos (1UL)               /*!< DMA_CHAN02_INST INT_STATUS: FLOW_CONTROL (Bit 1)            */
#define DMA_CHAN02_INST_INT_STATUS_FLOW_CONTROL_Msk (0x2UL)             /*!< DMA_CHAN02_INST INT_STATUS: FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN02_INST_INT_STATUS_DONE_Pos   (2UL)                     /*!< DMA_CHAN02_INST INT_STATUS: DONE (Bit 2)                    */
#define DMA_CHAN02_INST_INT_STATUS_DONE_Msk   (0x4UL)                   /*!< DMA_CHAN02_INST INT_STATUS: DONE (Bitfield-Mask: 0x01)      */

/* ---------------------------  DMA_CHAN02_INST_INT_EN  --------------------------- */
#define DMA_CHAN02_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Pos (0UL)        /*!< DMA_CHAN02_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bit 0)     */
#define DMA_CHAN02_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Msk (0x1UL)      /*!< DMA_CHAN02_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN02_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Pos (1UL)     /*!< DMA_CHAN02_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bit 1)  */
#define DMA_CHAN02_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Msk (0x2UL)   /*!< DMA_CHAN02_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN02_INST_INT_EN_STATUS_ENABLE_DONE_Pos (2UL)             /*!< DMA_CHAN02_INST INT_EN: STATUS_ENABLE_DONE (Bit 2)          */
#define DMA_CHAN02_INST_INT_EN_STATUS_ENABLE_DONE_Msk (0x4UL)           /*!< DMA_CHAN02_INST INT_EN: STATUS_ENABLE_DONE (Bitfield-Mask: 0x01) */


/* ================================================================================ */
/* ================    struct 'DMA_CHAN03_INST' Position & Mask    ================ */
/* ================================================================================ */


/* --------------------  DMA_CHAN03_INST_DMA_CHANNEL_ACTIVATE  -------------------- */
#define DMA_CHAN03_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Pos (0UL) /*!< DMA_CHAN03_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bit 0) */
#define DMA_CHAN03_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Msk (0x1UL) /*!< DMA_CHAN03_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bitfield-Mask: 0x01) */

/* ---------------------------  DMA_CHAN03_INST_CONTROL  -------------------------- */
#define DMA_CHAN03_INST_CONTROL_RUN_Pos       (0UL)                     /*!< DMA_CHAN03_INST CONTROL: RUN (Bit 0)                        */
#define DMA_CHAN03_INST_CONTROL_RUN_Msk       (0x1UL)                   /*!< DMA_CHAN03_INST CONTROL: RUN (Bitfield-Mask: 0x01)          */
#define DMA_CHAN03_INST_CONTROL_REQUEST_Pos   (1UL)                     /*!< DMA_CHAN03_INST CONTROL: REQUEST (Bit 1)                    */
#define DMA_CHAN03_INST_CONTROL_REQUEST_Msk   (0x2UL)                   /*!< DMA_CHAN03_INST CONTROL: REQUEST (Bitfield-Mask: 0x01)      */
#define DMA_CHAN03_INST_CONTROL_DONE_Pos      (2UL)                     /*!< DMA_CHAN03_INST CONTROL: DONE (Bit 2)                       */
#define DMA_CHAN03_INST_CONTROL_DONE_Msk      (0x4UL)                   /*!< DMA_CHAN03_INST CONTROL: DONE (Bitfield-Mask: 0x01)         */
#define DMA_CHAN03_INST_CONTROL_STATUS_Pos    (3UL)                     /*!< DMA_CHAN03_INST CONTROL: STATUS (Bit 3)                     */
#define DMA_CHAN03_INST_CONTROL_STATUS_Msk    (0x18UL)                  /*!< DMA_CHAN03_INST CONTROL: STATUS (Bitfield-Mask: 0x03)       */
#define DMA_CHAN03_INST_CONTROL_BUSY_Pos      (5UL)                     /*!< DMA_CHAN03_INST CONTROL: BUSY (Bit 5)                       */
#define DMA_CHAN03_INST_CONTROL_BUSY_Msk      (0x20UL)                  /*!< DMA_CHAN03_INST CONTROL: BUSY (Bitfield-Mask: 0x01)         */
#define DMA_CHAN03_INST_CONTROL_TX_DIRECTION_Pos (8UL)                  /*!< DMA_CHAN03_INST CONTROL: TX_DIRECTION (Bit 8)               */
#define DMA_CHAN03_INST_CONTROL_TX_DIRECTION_Msk (0x100UL)              /*!< DMA_CHAN03_INST CONTROL: TX_DIRECTION (Bitfield-Mask: 0x01) */
#define DMA_CHAN03_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Pos (9UL)  /*!< DMA_CHAN03_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bit 9) */
#define DMA_CHAN03_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Msk (0xfe00UL) /*!< DMA_CHAN03_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bitfield-Mask: 0x7f) */
#define DMA_CHAN03_INST_CONTROL_INCREMENT_MEM_ADDR_Pos (16UL)           /*!< DMA_CHAN03_INST CONTROL: INCREMENT_MEM_ADDR (Bit 16)        */
#define DMA_CHAN03_INST_CONTROL_INCREMENT_MEM_ADDR_Msk (0x10000UL)      /*!< DMA_CHAN03_INST CONTROL: INCREMENT_MEM_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN03_INST_CONTROL_INCREMENT_DEVICE_ADDR_Pos (17UL)        /*!< DMA_CHAN03_INST CONTROL: INCREMENT_DEVICE_ADDR (Bit 17)     */
#define DMA_CHAN03_INST_CONTROL_INCREMENT_DEVICE_ADDR_Msk (0x20000UL)   /*!< DMA_CHAN03_INST CONTROL: INCREMENT_DEVICE_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN03_INST_CONTROL_LOCK_Pos      (18UL)                    /*!< DMA_CHAN03_INST CONTROL: LOCK (Bit 18)                      */
#define DMA_CHAN03_INST_CONTROL_LOCK_Msk      (0x40000UL)               /*!< DMA_CHAN03_INST CONTROL: LOCK (Bitfield-Mask: 0x01)         */
#define DMA_CHAN03_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Pos (19UL)      /*!< DMA_CHAN03_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bit 19)   */
#define DMA_CHAN03_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Msk (0x80000UL) /*!< DMA_CHAN03_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN03_INST_CONTROL_TRANSFER_SIZE_Pos (20UL)                /*!< DMA_CHAN03_INST CONTROL: TRANSFER_SIZE (Bit 20)             */
#define DMA_CHAN03_INST_CONTROL_TRANSFER_SIZE_Msk (0x700000UL)          /*!< DMA_CHAN03_INST CONTROL: TRANSFER_SIZE (Bitfield-Mask: 0x07) */
#define DMA_CHAN03_INST_CONTROL_TRANSFER_GO_Pos (24UL)                  /*!< DMA_CHAN03_INST CONTROL: TRANSFER_GO (Bit 24)               */
#define DMA_CHAN03_INST_CONTROL_TRANSFER_GO_Msk (0x1000000UL)           /*!< DMA_CHAN03_INST CONTROL: TRANSFER_GO (Bitfield-Mask: 0x01)  */
#define DMA_CHAN03_INST_CONTROL_TRANSFER_ABORT_Pos (25UL)               /*!< DMA_CHAN03_INST CONTROL: TRANSFER_ABORT (Bit 25)            */
#define DMA_CHAN03_INST_CONTROL_TRANSFER_ABORT_Msk (0x2000000UL)        /*!< DMA_CHAN03_INST CONTROL: TRANSFER_ABORT (Bitfield-Mask: 0x01) */

/* -------------------------  DMA_CHAN03_INST_INT_STATUS  ------------------------- */
#define DMA_CHAN03_INST_INT_STATUS_BUS_ERROR_Pos (0UL)                  /*!< DMA_CHAN03_INST INT_STATUS: BUS_ERROR (Bit 0)               */
#define DMA_CHAN03_INST_INT_STATUS_BUS_ERROR_Msk (0x1UL)                /*!< DMA_CHAN03_INST INT_STATUS: BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN03_INST_INT_STATUS_FLOW_CONTROL_Pos (1UL)               /*!< DMA_CHAN03_INST INT_STATUS: FLOW_CONTROL (Bit 1)            */
#define DMA_CHAN03_INST_INT_STATUS_FLOW_CONTROL_Msk (0x2UL)             /*!< DMA_CHAN03_INST INT_STATUS: FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN03_INST_INT_STATUS_DONE_Pos   (2UL)                     /*!< DMA_CHAN03_INST INT_STATUS: DONE (Bit 2)                    */
#define DMA_CHAN03_INST_INT_STATUS_DONE_Msk   (0x4UL)                   /*!< DMA_CHAN03_INST INT_STATUS: DONE (Bitfield-Mask: 0x01)      */

/* ---------------------------  DMA_CHAN03_INST_INT_EN  --------------------------- */
#define DMA_CHAN03_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Pos (0UL)        /*!< DMA_CHAN03_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bit 0)     */
#define DMA_CHAN03_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Msk (0x1UL)      /*!< DMA_CHAN03_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN03_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Pos (1UL)     /*!< DMA_CHAN03_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bit 1)  */
#define DMA_CHAN03_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Msk (0x2UL)   /*!< DMA_CHAN03_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN03_INST_INT_EN_STATUS_ENABLE_DONE_Pos (2UL)             /*!< DMA_CHAN03_INST INT_EN: STATUS_ENABLE_DONE (Bit 2)          */
#define DMA_CHAN03_INST_INT_EN_STATUS_ENABLE_DONE_Msk (0x4UL)           /*!< DMA_CHAN03_INST INT_EN: STATUS_ENABLE_DONE (Bitfield-Mask: 0x01) */


/* ================================================================================ */
/* ================    struct 'DMA_CHAN04_INST' Position & Mask    ================ */
/* ================================================================================ */


/* --------------------  DMA_CHAN04_INST_DMA_CHANNEL_ACTIVATE  -------------------- */
#define DMA_CHAN04_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Pos (0UL) /*!< DMA_CHAN04_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bit 0) */
#define DMA_CHAN04_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Msk (0x1UL) /*!< DMA_CHAN04_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bitfield-Mask: 0x01) */

/* ---------------------------  DMA_CHAN04_INST_CONTROL  -------------------------- */
#define DMA_CHAN04_INST_CONTROL_RUN_Pos       (0UL)                     /*!< DMA_CHAN04_INST CONTROL: RUN (Bit 0)                        */
#define DMA_CHAN04_INST_CONTROL_RUN_Msk       (0x1UL)                   /*!< DMA_CHAN04_INST CONTROL: RUN (Bitfield-Mask: 0x01)          */
#define DMA_CHAN04_INST_CONTROL_REQUEST_Pos   (1UL)                     /*!< DMA_CHAN04_INST CONTROL: REQUEST (Bit 1)                    */
#define DMA_CHAN04_INST_CONTROL_REQUEST_Msk   (0x2UL)                   /*!< DMA_CHAN04_INST CONTROL: REQUEST (Bitfield-Mask: 0x01)      */
#define DMA_CHAN04_INST_CONTROL_DONE_Pos      (2UL)                     /*!< DMA_CHAN04_INST CONTROL: DONE (Bit 2)                       */
#define DMA_CHAN04_INST_CONTROL_DONE_Msk      (0x4UL)                   /*!< DMA_CHAN04_INST CONTROL: DONE (Bitfield-Mask: 0x01)         */
#define DMA_CHAN04_INST_CONTROL_STATUS_Pos    (3UL)                     /*!< DMA_CHAN04_INST CONTROL: STATUS (Bit 3)                     */
#define DMA_CHAN04_INST_CONTROL_STATUS_Msk    (0x18UL)                  /*!< DMA_CHAN04_INST CONTROL: STATUS (Bitfield-Mask: 0x03)       */
#define DMA_CHAN04_INST_CONTROL_BUSY_Pos      (5UL)                     /*!< DMA_CHAN04_INST CONTROL: BUSY (Bit 5)                       */
#define DMA_CHAN04_INST_CONTROL_BUSY_Msk      (0x20UL)                  /*!< DMA_CHAN04_INST CONTROL: BUSY (Bitfield-Mask: 0x01)         */
#define DMA_CHAN04_INST_CONTROL_TX_DIRECTION_Pos (8UL)                  /*!< DMA_CHAN04_INST CONTROL: TX_DIRECTION (Bit 8)               */
#define DMA_CHAN04_INST_CONTROL_TX_DIRECTION_Msk (0x100UL)              /*!< DMA_CHAN04_INST CONTROL: TX_DIRECTION (Bitfield-Mask: 0x01) */
#define DMA_CHAN04_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Pos (9UL)  /*!< DMA_CHAN04_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bit 9) */
#define DMA_CHAN04_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Msk (0xfe00UL) /*!< DMA_CHAN04_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bitfield-Mask: 0x7f) */
#define DMA_CHAN04_INST_CONTROL_INCREMENT_MEM_ADDR_Pos (16UL)           /*!< DMA_CHAN04_INST CONTROL: INCREMENT_MEM_ADDR (Bit 16)        */
#define DMA_CHAN04_INST_CONTROL_INCREMENT_MEM_ADDR_Msk (0x10000UL)      /*!< DMA_CHAN04_INST CONTROL: INCREMENT_MEM_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN04_INST_CONTROL_INCREMENT_DEVICE_ADDR_Pos (17UL)        /*!< DMA_CHAN04_INST CONTROL: INCREMENT_DEVICE_ADDR (Bit 17)     */
#define DMA_CHAN04_INST_CONTROL_INCREMENT_DEVICE_ADDR_Msk (0x20000UL)   /*!< DMA_CHAN04_INST CONTROL: INCREMENT_DEVICE_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN04_INST_CONTROL_LOCK_Pos      (18UL)                    /*!< DMA_CHAN04_INST CONTROL: LOCK (Bit 18)                      */
#define DMA_CHAN04_INST_CONTROL_LOCK_Msk      (0x40000UL)               /*!< DMA_CHAN04_INST CONTROL: LOCK (Bitfield-Mask: 0x01)         */
#define DMA_CHAN04_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Pos (19UL)      /*!< DMA_CHAN04_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bit 19)   */
#define DMA_CHAN04_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Msk (0x80000UL) /*!< DMA_CHAN04_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN04_INST_CONTROL_TRANSFER_SIZE_Pos (20UL)                /*!< DMA_CHAN04_INST CONTROL: TRANSFER_SIZE (Bit 20)             */
#define DMA_CHAN04_INST_CONTROL_TRANSFER_SIZE_Msk (0x700000UL)          /*!< DMA_CHAN04_INST CONTROL: TRANSFER_SIZE (Bitfield-Mask: 0x07) */
#define DMA_CHAN04_INST_CONTROL_TRANSFER_GO_Pos (24UL)                  /*!< DMA_CHAN04_INST CONTROL: TRANSFER_GO (Bit 24)               */
#define DMA_CHAN04_INST_CONTROL_TRANSFER_GO_Msk (0x1000000UL)           /*!< DMA_CHAN04_INST CONTROL: TRANSFER_GO (Bitfield-Mask: 0x01)  */
#define DMA_CHAN04_INST_CONTROL_TRANSFER_ABORT_Pos (25UL)               /*!< DMA_CHAN04_INST CONTROL: TRANSFER_ABORT (Bit 25)            */
#define DMA_CHAN04_INST_CONTROL_TRANSFER_ABORT_Msk (0x2000000UL)        /*!< DMA_CHAN04_INST CONTROL: TRANSFER_ABORT (Bitfield-Mask: 0x01) */

/* -------------------------  DMA_CHAN04_INST_INT_STATUS  ------------------------- */
#define DMA_CHAN04_INST_INT_STATUS_BUS_ERROR_Pos (0UL)                  /*!< DMA_CHAN04_INST INT_STATUS: BUS_ERROR (Bit 0)               */
#define DMA_CHAN04_INST_INT_STATUS_BUS_ERROR_Msk (0x1UL)                /*!< DMA_CHAN04_INST INT_STATUS: BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN04_INST_INT_STATUS_FLOW_CONTROL_Pos (1UL)               /*!< DMA_CHAN04_INST INT_STATUS: FLOW_CONTROL (Bit 1)            */
#define DMA_CHAN04_INST_INT_STATUS_FLOW_CONTROL_Msk (0x2UL)             /*!< DMA_CHAN04_INST INT_STATUS: FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN04_INST_INT_STATUS_DONE_Pos   (2UL)                     /*!< DMA_CHAN04_INST INT_STATUS: DONE (Bit 2)                    */
#define DMA_CHAN04_INST_INT_STATUS_DONE_Msk   (0x4UL)                   /*!< DMA_CHAN04_INST INT_STATUS: DONE (Bitfield-Mask: 0x01)      */

/* ---------------------------  DMA_CHAN04_INST_INT_EN  --------------------------- */
#define DMA_CHAN04_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Pos (0UL)        /*!< DMA_CHAN04_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bit 0)     */
#define DMA_CHAN04_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Msk (0x1UL)      /*!< DMA_CHAN04_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN04_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Pos (1UL)     /*!< DMA_CHAN04_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bit 1)  */
#define DMA_CHAN04_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Msk (0x2UL)   /*!< DMA_CHAN04_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN04_INST_INT_EN_STATUS_ENABLE_DONE_Pos (2UL)             /*!< DMA_CHAN04_INST INT_EN: STATUS_ENABLE_DONE (Bit 2)          */
#define DMA_CHAN04_INST_INT_EN_STATUS_ENABLE_DONE_Msk (0x4UL)           /*!< DMA_CHAN04_INST INT_EN: STATUS_ENABLE_DONE (Bitfield-Mask: 0x01) */


/* ================================================================================ */
/* ================    struct 'DMA_CHAN05_INST' Position & Mask    ================ */
/* ================================================================================ */


/* --------------------  DMA_CHAN05_INST_DMA_CHANNEL_ACTIVATE  -------------------- */
#define DMA_CHAN05_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Pos (0UL) /*!< DMA_CHAN05_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bit 0) */
#define DMA_CHAN05_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Msk (0x1UL) /*!< DMA_CHAN05_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bitfield-Mask: 0x01) */

/* ---------------------------  DMA_CHAN05_INST_CONTROL  -------------------------- */
#define DMA_CHAN05_INST_CONTROL_RUN_Pos       (0UL)                     /*!< DMA_CHAN05_INST CONTROL: RUN (Bit 0)                        */
#define DMA_CHAN05_INST_CONTROL_RUN_Msk       (0x1UL)                   /*!< DMA_CHAN05_INST CONTROL: RUN (Bitfield-Mask: 0x01)          */
#define DMA_CHAN05_INST_CONTROL_REQUEST_Pos   (1UL)                     /*!< DMA_CHAN05_INST CONTROL: REQUEST (Bit 1)                    */
#define DMA_CHAN05_INST_CONTROL_REQUEST_Msk   (0x2UL)                   /*!< DMA_CHAN05_INST CONTROL: REQUEST (Bitfield-Mask: 0x01)      */
#define DMA_CHAN05_INST_CONTROL_DONE_Pos      (2UL)                     /*!< DMA_CHAN05_INST CONTROL: DONE (Bit 2)                       */
#define DMA_CHAN05_INST_CONTROL_DONE_Msk      (0x4UL)                   /*!< DMA_CHAN05_INST CONTROL: DONE (Bitfield-Mask: 0x01)         */
#define DMA_CHAN05_INST_CONTROL_STATUS_Pos    (3UL)                     /*!< DMA_CHAN05_INST CONTROL: STATUS (Bit 3)                     */
#define DMA_CHAN05_INST_CONTROL_STATUS_Msk    (0x18UL)                  /*!< DMA_CHAN05_INST CONTROL: STATUS (Bitfield-Mask: 0x03)       */
#define DMA_CHAN05_INST_CONTROL_BUSY_Pos      (5UL)                     /*!< DMA_CHAN05_INST CONTROL: BUSY (Bit 5)                       */
#define DMA_CHAN05_INST_CONTROL_BUSY_Msk      (0x20UL)                  /*!< DMA_CHAN05_INST CONTROL: BUSY (Bitfield-Mask: 0x01)         */
#define DMA_CHAN05_INST_CONTROL_TX_DIRECTION_Pos (8UL)                  /*!< DMA_CHAN05_INST CONTROL: TX_DIRECTION (Bit 8)               */
#define DMA_CHAN05_INST_CONTROL_TX_DIRECTION_Msk (0x100UL)              /*!< DMA_CHAN05_INST CONTROL: TX_DIRECTION (Bitfield-Mask: 0x01) */
#define DMA_CHAN05_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Pos (9UL)  /*!< DMA_CHAN05_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bit 9) */
#define DMA_CHAN05_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Msk (0xfe00UL) /*!< DMA_CHAN05_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bitfield-Mask: 0x7f) */
#define DMA_CHAN05_INST_CONTROL_INCREMENT_MEM_ADDR_Pos (16UL)           /*!< DMA_CHAN05_INST CONTROL: INCREMENT_MEM_ADDR (Bit 16)        */
#define DMA_CHAN05_INST_CONTROL_INCREMENT_MEM_ADDR_Msk (0x10000UL)      /*!< DMA_CHAN05_INST CONTROL: INCREMENT_MEM_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN05_INST_CONTROL_INCREMENT_DEVICE_ADDR_Pos (17UL)        /*!< DMA_CHAN05_INST CONTROL: INCREMENT_DEVICE_ADDR (Bit 17)     */
#define DMA_CHAN05_INST_CONTROL_INCREMENT_DEVICE_ADDR_Msk (0x20000UL)   /*!< DMA_CHAN05_INST CONTROL: INCREMENT_DEVICE_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN05_INST_CONTROL_LOCK_Pos      (18UL)                    /*!< DMA_CHAN05_INST CONTROL: LOCK (Bit 18)                      */
#define DMA_CHAN05_INST_CONTROL_LOCK_Msk      (0x40000UL)               /*!< DMA_CHAN05_INST CONTROL: LOCK (Bitfield-Mask: 0x01)         */
#define DMA_CHAN05_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Pos (19UL)      /*!< DMA_CHAN05_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bit 19)   */
#define DMA_CHAN05_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Msk (0x80000UL) /*!< DMA_CHAN05_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN05_INST_CONTROL_TRANSFER_SIZE_Pos (20UL)                /*!< DMA_CHAN05_INST CONTROL: TRANSFER_SIZE (Bit 20)             */
#define DMA_CHAN05_INST_CONTROL_TRANSFER_SIZE_Msk (0x700000UL)          /*!< DMA_CHAN05_INST CONTROL: TRANSFER_SIZE (Bitfield-Mask: 0x07) */
#define DMA_CHAN05_INST_CONTROL_TRANSFER_GO_Pos (24UL)                  /*!< DMA_CHAN05_INST CONTROL: TRANSFER_GO (Bit 24)               */
#define DMA_CHAN05_INST_CONTROL_TRANSFER_GO_Msk (0x1000000UL)           /*!< DMA_CHAN05_INST CONTROL: TRANSFER_GO (Bitfield-Mask: 0x01)  */
#define DMA_CHAN05_INST_CONTROL_TRANSFER_ABORT_Pos (25UL)               /*!< DMA_CHAN05_INST CONTROL: TRANSFER_ABORT (Bit 25)            */
#define DMA_CHAN05_INST_CONTROL_TRANSFER_ABORT_Msk (0x2000000UL)        /*!< DMA_CHAN05_INST CONTROL: TRANSFER_ABORT (Bitfield-Mask: 0x01) */

/* -------------------------  DMA_CHAN05_INST_INT_STATUS  ------------------------- */
#define DMA_CHAN05_INST_INT_STATUS_BUS_ERROR_Pos (0UL)                  /*!< DMA_CHAN05_INST INT_STATUS: BUS_ERROR (Bit 0)               */
#define DMA_CHAN05_INST_INT_STATUS_BUS_ERROR_Msk (0x1UL)                /*!< DMA_CHAN05_INST INT_STATUS: BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN05_INST_INT_STATUS_FLOW_CONTROL_Pos (1UL)               /*!< DMA_CHAN05_INST INT_STATUS: FLOW_CONTROL (Bit 1)            */
#define DMA_CHAN05_INST_INT_STATUS_FLOW_CONTROL_Msk (0x2UL)             /*!< DMA_CHAN05_INST INT_STATUS: FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN05_INST_INT_STATUS_DONE_Pos   (2UL)                     /*!< DMA_CHAN05_INST INT_STATUS: DONE (Bit 2)                    */
#define DMA_CHAN05_INST_INT_STATUS_DONE_Msk   (0x4UL)                   /*!< DMA_CHAN05_INST INT_STATUS: DONE (Bitfield-Mask: 0x01)      */

/* ---------------------------  DMA_CHAN05_INST_INT_EN  --------------------------- */
#define DMA_CHAN05_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Pos (0UL)        /*!< DMA_CHAN05_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bit 0)     */
#define DMA_CHAN05_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Msk (0x1UL)      /*!< DMA_CHAN05_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN05_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Pos (1UL)     /*!< DMA_CHAN05_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bit 1)  */
#define DMA_CHAN05_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Msk (0x2UL)   /*!< DMA_CHAN05_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN05_INST_INT_EN_STATUS_ENABLE_DONE_Pos (2UL)             /*!< DMA_CHAN05_INST INT_EN: STATUS_ENABLE_DONE (Bit 2)          */
#define DMA_CHAN05_INST_INT_EN_STATUS_ENABLE_DONE_Msk (0x4UL)           /*!< DMA_CHAN05_INST INT_EN: STATUS_ENABLE_DONE (Bitfield-Mask: 0x01) */


/* ================================================================================ */
/* ================    struct 'DMA_CHAN06_INST' Position & Mask    ================ */
/* ================================================================================ */


/* --------------------  DMA_CHAN06_INST_DMA_CHANNEL_ACTIVATE  -------------------- */
#define DMA_CHAN06_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Pos (0UL) /*!< DMA_CHAN06_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bit 0) */
#define DMA_CHAN06_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Msk (0x1UL) /*!< DMA_CHAN06_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bitfield-Mask: 0x01) */

/* ---------------------------  DMA_CHAN06_INST_CONTROL  -------------------------- */
#define DMA_CHAN06_INST_CONTROL_RUN_Pos       (0UL)                     /*!< DMA_CHAN06_INST CONTROL: RUN (Bit 0)                        */
#define DMA_CHAN06_INST_CONTROL_RUN_Msk       (0x1UL)                   /*!< DMA_CHAN06_INST CONTROL: RUN (Bitfield-Mask: 0x01)          */
#define DMA_CHAN06_INST_CONTROL_REQUEST_Pos   (1UL)                     /*!< DMA_CHAN06_INST CONTROL: REQUEST (Bit 1)                    */
#define DMA_CHAN06_INST_CONTROL_REQUEST_Msk   (0x2UL)                   /*!< DMA_CHAN06_INST CONTROL: REQUEST (Bitfield-Mask: 0x01)      */
#define DMA_CHAN06_INST_CONTROL_DONE_Pos      (2UL)                     /*!< DMA_CHAN06_INST CONTROL: DONE (Bit 2)                       */
#define DMA_CHAN06_INST_CONTROL_DONE_Msk      (0x4UL)                   /*!< DMA_CHAN06_INST CONTROL: DONE (Bitfield-Mask: 0x01)         */
#define DMA_CHAN06_INST_CONTROL_STATUS_Pos    (3UL)                     /*!< DMA_CHAN06_INST CONTROL: STATUS (Bit 3)                     */
#define DMA_CHAN06_INST_CONTROL_STATUS_Msk    (0x18UL)                  /*!< DMA_CHAN06_INST CONTROL: STATUS (Bitfield-Mask: 0x03)       */
#define DMA_CHAN06_INST_CONTROL_BUSY_Pos      (5UL)                     /*!< DMA_CHAN06_INST CONTROL: BUSY (Bit 5)                       */
#define DMA_CHAN06_INST_CONTROL_BUSY_Msk      (0x20UL)                  /*!< DMA_CHAN06_INST CONTROL: BUSY (Bitfield-Mask: 0x01)         */
#define DMA_CHAN06_INST_CONTROL_TX_DIRECTION_Pos (8UL)                  /*!< DMA_CHAN06_INST CONTROL: TX_DIRECTION (Bit 8)               */
#define DMA_CHAN06_INST_CONTROL_TX_DIRECTION_Msk (0x100UL)              /*!< DMA_CHAN06_INST CONTROL: TX_DIRECTION (Bitfield-Mask: 0x01) */
#define DMA_CHAN06_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Pos (9UL)  /*!< DMA_CHAN06_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bit 9) */
#define DMA_CHAN06_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Msk (0xfe00UL) /*!< DMA_CHAN06_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bitfield-Mask: 0x7f) */
#define DMA_CHAN06_INST_CONTROL_INCREMENT_MEM_ADDR_Pos (16UL)           /*!< DMA_CHAN06_INST CONTROL: INCREMENT_MEM_ADDR (Bit 16)        */
#define DMA_CHAN06_INST_CONTROL_INCREMENT_MEM_ADDR_Msk (0x10000UL)      /*!< DMA_CHAN06_INST CONTROL: INCREMENT_MEM_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN06_INST_CONTROL_INCREMENT_DEVICE_ADDR_Pos (17UL)        /*!< DMA_CHAN06_INST CONTROL: INCREMENT_DEVICE_ADDR (Bit 17)     */
#define DMA_CHAN06_INST_CONTROL_INCREMENT_DEVICE_ADDR_Msk (0x20000UL)   /*!< DMA_CHAN06_INST CONTROL: INCREMENT_DEVICE_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN06_INST_CONTROL_LOCK_Pos      (18UL)                    /*!< DMA_CHAN06_INST CONTROL: LOCK (Bit 18)                      */
#define DMA_CHAN06_INST_CONTROL_LOCK_Msk      (0x40000UL)               /*!< DMA_CHAN06_INST CONTROL: LOCK (Bitfield-Mask: 0x01)         */
#define DMA_CHAN06_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Pos (19UL)      /*!< DMA_CHAN06_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bit 19)   */
#define DMA_CHAN06_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Msk (0x80000UL) /*!< DMA_CHAN06_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN06_INST_CONTROL_TRANSFER_SIZE_Pos (20UL)                /*!< DMA_CHAN06_INST CONTROL: TRANSFER_SIZE (Bit 20)             */
#define DMA_CHAN06_INST_CONTROL_TRANSFER_SIZE_Msk (0x700000UL)          /*!< DMA_CHAN06_INST CONTROL: TRANSFER_SIZE (Bitfield-Mask: 0x07) */
#define DMA_CHAN06_INST_CONTROL_TRANSFER_GO_Pos (24UL)                  /*!< DMA_CHAN06_INST CONTROL: TRANSFER_GO (Bit 24)               */
#define DMA_CHAN06_INST_CONTROL_TRANSFER_GO_Msk (0x1000000UL)           /*!< DMA_CHAN06_INST CONTROL: TRANSFER_GO (Bitfield-Mask: 0x01)  */
#define DMA_CHAN06_INST_CONTROL_TRANSFER_ABORT_Pos (25UL)               /*!< DMA_CHAN06_INST CONTROL: TRANSFER_ABORT (Bit 25)            */
#define DMA_CHAN06_INST_CONTROL_TRANSFER_ABORT_Msk (0x2000000UL)        /*!< DMA_CHAN06_INST CONTROL: TRANSFER_ABORT (Bitfield-Mask: 0x01) */

/* -------------------------  DMA_CHAN06_INST_INT_STATUS  ------------------------- */
#define DMA_CHAN06_INST_INT_STATUS_BUS_ERROR_Pos (0UL)                  /*!< DMA_CHAN06_INST INT_STATUS: BUS_ERROR (Bit 0)               */
#define DMA_CHAN06_INST_INT_STATUS_BUS_ERROR_Msk (0x1UL)                /*!< DMA_CHAN06_INST INT_STATUS: BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN06_INST_INT_STATUS_FLOW_CONTROL_Pos (1UL)               /*!< DMA_CHAN06_INST INT_STATUS: FLOW_CONTROL (Bit 1)            */
#define DMA_CHAN06_INST_INT_STATUS_FLOW_CONTROL_Msk (0x2UL)             /*!< DMA_CHAN06_INST INT_STATUS: FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN06_INST_INT_STATUS_DONE_Pos   (2UL)                     /*!< DMA_CHAN06_INST INT_STATUS: DONE (Bit 2)                    */
#define DMA_CHAN06_INST_INT_STATUS_DONE_Msk   (0x4UL)                   /*!< DMA_CHAN06_INST INT_STATUS: DONE (Bitfield-Mask: 0x01)      */

/* ---------------------------  DMA_CHAN06_INST_INT_EN  --------------------------- */
#define DMA_CHAN06_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Pos (0UL)        /*!< DMA_CHAN06_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bit 0)     */
#define DMA_CHAN06_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Msk (0x1UL)      /*!< DMA_CHAN06_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN06_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Pos (1UL)     /*!< DMA_CHAN06_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bit 1)  */
#define DMA_CHAN06_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Msk (0x2UL)   /*!< DMA_CHAN06_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN06_INST_INT_EN_STATUS_ENABLE_DONE_Pos (2UL)             /*!< DMA_CHAN06_INST INT_EN: STATUS_ENABLE_DONE (Bit 2)          */
#define DMA_CHAN06_INST_INT_EN_STATUS_ENABLE_DONE_Msk (0x4UL)           /*!< DMA_CHAN06_INST INT_EN: STATUS_ENABLE_DONE (Bitfield-Mask: 0x01) */


/* ================================================================================ */
/* ================    struct 'DMA_CHAN07_INST' Position & Mask    ================ */
/* ================================================================================ */


/* --------------------  DMA_CHAN07_INST_DMA_CHANNEL_ACTIVATE  -------------------- */
#define DMA_CHAN07_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Pos (0UL) /*!< DMA_CHAN07_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bit 0) */
#define DMA_CHAN07_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Msk (0x1UL) /*!< DMA_CHAN07_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bitfield-Mask: 0x01) */

/* ---------------------------  DMA_CHAN07_INST_CONTROL  -------------------------- */
#define DMA_CHAN07_INST_CONTROL_RUN_Pos       (0UL)                     /*!< DMA_CHAN07_INST CONTROL: RUN (Bit 0)                        */
#define DMA_CHAN07_INST_CONTROL_RUN_Msk       (0x1UL)                   /*!< DMA_CHAN07_INST CONTROL: RUN (Bitfield-Mask: 0x01)          */
#define DMA_CHAN07_INST_CONTROL_REQUEST_Pos   (1UL)                     /*!< DMA_CHAN07_INST CONTROL: REQUEST (Bit 1)                    */
#define DMA_CHAN07_INST_CONTROL_REQUEST_Msk   (0x2UL)                   /*!< DMA_CHAN07_INST CONTROL: REQUEST (Bitfield-Mask: 0x01)      */
#define DMA_CHAN07_INST_CONTROL_DONE_Pos      (2UL)                     /*!< DMA_CHAN07_INST CONTROL: DONE (Bit 2)                       */
#define DMA_CHAN07_INST_CONTROL_DONE_Msk      (0x4UL)                   /*!< DMA_CHAN07_INST CONTROL: DONE (Bitfield-Mask: 0x01)         */
#define DMA_CHAN07_INST_CONTROL_STATUS_Pos    (3UL)                     /*!< DMA_CHAN07_INST CONTROL: STATUS (Bit 3)                     */
#define DMA_CHAN07_INST_CONTROL_STATUS_Msk    (0x18UL)                  /*!< DMA_CHAN07_INST CONTROL: STATUS (Bitfield-Mask: 0x03)       */
#define DMA_CHAN07_INST_CONTROL_BUSY_Pos      (5UL)                     /*!< DMA_CHAN07_INST CONTROL: BUSY (Bit 5)                       */
#define DMA_CHAN07_INST_CONTROL_BUSY_Msk      (0x20UL)                  /*!< DMA_CHAN07_INST CONTROL: BUSY (Bitfield-Mask: 0x01)         */
#define DMA_CHAN07_INST_CONTROL_TX_DIRECTION_Pos (8UL)                  /*!< DMA_CHAN07_INST CONTROL: TX_DIRECTION (Bit 8)               */
#define DMA_CHAN07_INST_CONTROL_TX_DIRECTION_Msk (0x100UL)              /*!< DMA_CHAN07_INST CONTROL: TX_DIRECTION (Bitfield-Mask: 0x01) */
#define DMA_CHAN07_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Pos (9UL)  /*!< DMA_CHAN07_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bit 9) */
#define DMA_CHAN07_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Msk (0xfe00UL) /*!< DMA_CHAN07_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bitfield-Mask: 0x7f) */
#define DMA_CHAN07_INST_CONTROL_INCREMENT_MEM_ADDR_Pos (16UL)           /*!< DMA_CHAN07_INST CONTROL: INCREMENT_MEM_ADDR (Bit 16)        */
#define DMA_CHAN07_INST_CONTROL_INCREMENT_MEM_ADDR_Msk (0x10000UL)      /*!< DMA_CHAN07_INST CONTROL: INCREMENT_MEM_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN07_INST_CONTROL_INCREMENT_DEVICE_ADDR_Pos (17UL)        /*!< DMA_CHAN07_INST CONTROL: INCREMENT_DEVICE_ADDR (Bit 17)     */
#define DMA_CHAN07_INST_CONTROL_INCREMENT_DEVICE_ADDR_Msk (0x20000UL)   /*!< DMA_CHAN07_INST CONTROL: INCREMENT_DEVICE_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN07_INST_CONTROL_LOCK_Pos      (18UL)                    /*!< DMA_CHAN07_INST CONTROL: LOCK (Bit 18)                      */
#define DMA_CHAN07_INST_CONTROL_LOCK_Msk      (0x40000UL)               /*!< DMA_CHAN07_INST CONTROL: LOCK (Bitfield-Mask: 0x01)         */
#define DMA_CHAN07_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Pos (19UL)      /*!< DMA_CHAN07_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bit 19)   */
#define DMA_CHAN07_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Msk (0x80000UL) /*!< DMA_CHAN07_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN07_INST_CONTROL_TRANSFER_SIZE_Pos (20UL)                /*!< DMA_CHAN07_INST CONTROL: TRANSFER_SIZE (Bit 20)             */
#define DMA_CHAN07_INST_CONTROL_TRANSFER_SIZE_Msk (0x700000UL)          /*!< DMA_CHAN07_INST CONTROL: TRANSFER_SIZE (Bitfield-Mask: 0x07) */
#define DMA_CHAN07_INST_CONTROL_TRANSFER_GO_Pos (24UL)                  /*!< DMA_CHAN07_INST CONTROL: TRANSFER_GO (Bit 24)               */
#define DMA_CHAN07_INST_CONTROL_TRANSFER_GO_Msk (0x1000000UL)           /*!< DMA_CHAN07_INST CONTROL: TRANSFER_GO (Bitfield-Mask: 0x01)  */
#define DMA_CHAN07_INST_CONTROL_TRANSFER_ABORT_Pos (25UL)               /*!< DMA_CHAN07_INST CONTROL: TRANSFER_ABORT (Bit 25)            */
#define DMA_CHAN07_INST_CONTROL_TRANSFER_ABORT_Msk (0x2000000UL)        /*!< DMA_CHAN07_INST CONTROL: TRANSFER_ABORT (Bitfield-Mask: 0x01) */

/* -------------------------  DMA_CHAN07_INST_INT_STATUS  ------------------------- */
#define DMA_CHAN07_INST_INT_STATUS_BUS_ERROR_Pos (0UL)                  /*!< DMA_CHAN07_INST INT_STATUS: BUS_ERROR (Bit 0)               */
#define DMA_CHAN07_INST_INT_STATUS_BUS_ERROR_Msk (0x1UL)                /*!< DMA_CHAN07_INST INT_STATUS: BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN07_INST_INT_STATUS_FLOW_CONTROL_Pos (1UL)               /*!< DMA_CHAN07_INST INT_STATUS: FLOW_CONTROL (Bit 1)            */
#define DMA_CHAN07_INST_INT_STATUS_FLOW_CONTROL_Msk (0x2UL)             /*!< DMA_CHAN07_INST INT_STATUS: FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN07_INST_INT_STATUS_DONE_Pos   (2UL)                     /*!< DMA_CHAN07_INST INT_STATUS: DONE (Bit 2)                    */
#define DMA_CHAN07_INST_INT_STATUS_DONE_Msk   (0x4UL)                   /*!< DMA_CHAN07_INST INT_STATUS: DONE (Bitfield-Mask: 0x01)      */

/* ---------------------------  DMA_CHAN07_INST_INT_EN  --------------------------- */
#define DMA_CHAN07_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Pos (0UL)        /*!< DMA_CHAN07_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bit 0)     */
#define DMA_CHAN07_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Msk (0x1UL)      /*!< DMA_CHAN07_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN07_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Pos (1UL)     /*!< DMA_CHAN07_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bit 1)  */
#define DMA_CHAN07_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Msk (0x2UL)   /*!< DMA_CHAN07_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN07_INST_INT_EN_STATUS_ENABLE_DONE_Pos (2UL)             /*!< DMA_CHAN07_INST INT_EN: STATUS_ENABLE_DONE (Bit 2)          */
#define DMA_CHAN07_INST_INT_EN_STATUS_ENABLE_DONE_Msk (0x4UL)           /*!< DMA_CHAN07_INST INT_EN: STATUS_ENABLE_DONE (Bitfield-Mask: 0x01) */


/* ================================================================================ */
/* ================    struct 'DMA_CHAN08_INST' Position & Mask    ================ */
/* ================================================================================ */


/* --------------------  DMA_CHAN08_INST_DMA_CHANNEL_ACTIVATE  -------------------- */
#define DMA_CHAN08_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Pos (0UL) /*!< DMA_CHAN08_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bit 0) */
#define DMA_CHAN08_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Msk (0x1UL) /*!< DMA_CHAN08_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bitfield-Mask: 0x01) */

/* ---------------------------  DMA_CHAN08_INST_CONTROL  -------------------------- */
#define DMA_CHAN08_INST_CONTROL_RUN_Pos       (0UL)                     /*!< DMA_CHAN08_INST CONTROL: RUN (Bit 0)                        */
#define DMA_CHAN08_INST_CONTROL_RUN_Msk       (0x1UL)                   /*!< DMA_CHAN08_INST CONTROL: RUN (Bitfield-Mask: 0x01)          */
#define DMA_CHAN08_INST_CONTROL_REQUEST_Pos   (1UL)                     /*!< DMA_CHAN08_INST CONTROL: REQUEST (Bit 1)                    */
#define DMA_CHAN08_INST_CONTROL_REQUEST_Msk   (0x2UL)                   /*!< DMA_CHAN08_INST CONTROL: REQUEST (Bitfield-Mask: 0x01)      */
#define DMA_CHAN08_INST_CONTROL_DONE_Pos      (2UL)                     /*!< DMA_CHAN08_INST CONTROL: DONE (Bit 2)                       */
#define DMA_CHAN08_INST_CONTROL_DONE_Msk      (0x4UL)                   /*!< DMA_CHAN08_INST CONTROL: DONE (Bitfield-Mask: 0x01)         */
#define DMA_CHAN08_INST_CONTROL_STATUS_Pos    (3UL)                     /*!< DMA_CHAN08_INST CONTROL: STATUS (Bit 3)                     */
#define DMA_CHAN08_INST_CONTROL_STATUS_Msk    (0x18UL)                  /*!< DMA_CHAN08_INST CONTROL: STATUS (Bitfield-Mask: 0x03)       */
#define DMA_CHAN08_INST_CONTROL_BUSY_Pos      (5UL)                     /*!< DMA_CHAN08_INST CONTROL: BUSY (Bit 5)                       */
#define DMA_CHAN08_INST_CONTROL_BUSY_Msk      (0x20UL)                  /*!< DMA_CHAN08_INST CONTROL: BUSY (Bitfield-Mask: 0x01)         */
#define DMA_CHAN08_INST_CONTROL_TX_DIRECTION_Pos (8UL)                  /*!< DMA_CHAN08_INST CONTROL: TX_DIRECTION (Bit 8)               */
#define DMA_CHAN08_INST_CONTROL_TX_DIRECTION_Msk (0x100UL)              /*!< DMA_CHAN08_INST CONTROL: TX_DIRECTION (Bitfield-Mask: 0x01) */
#define DMA_CHAN08_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Pos (9UL)  /*!< DMA_CHAN08_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bit 9) */
#define DMA_CHAN08_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Msk (0xfe00UL) /*!< DMA_CHAN08_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bitfield-Mask: 0x7f) */
#define DMA_CHAN08_INST_CONTROL_INCREMENT_MEM_ADDR_Pos (16UL)           /*!< DMA_CHAN08_INST CONTROL: INCREMENT_MEM_ADDR (Bit 16)        */
#define DMA_CHAN08_INST_CONTROL_INCREMENT_MEM_ADDR_Msk (0x10000UL)      /*!< DMA_CHAN08_INST CONTROL: INCREMENT_MEM_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN08_INST_CONTROL_INCREMENT_DEVICE_ADDR_Pos (17UL)        /*!< DMA_CHAN08_INST CONTROL: INCREMENT_DEVICE_ADDR (Bit 17)     */
#define DMA_CHAN08_INST_CONTROL_INCREMENT_DEVICE_ADDR_Msk (0x20000UL)   /*!< DMA_CHAN08_INST CONTROL: INCREMENT_DEVICE_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN08_INST_CONTROL_LOCK_Pos      (18UL)                    /*!< DMA_CHAN08_INST CONTROL: LOCK (Bit 18)                      */
#define DMA_CHAN08_INST_CONTROL_LOCK_Msk      (0x40000UL)               /*!< DMA_CHAN08_INST CONTROL: LOCK (Bitfield-Mask: 0x01)         */
#define DMA_CHAN08_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Pos (19UL)      /*!< DMA_CHAN08_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bit 19)   */
#define DMA_CHAN08_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Msk (0x80000UL) /*!< DMA_CHAN08_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN08_INST_CONTROL_TRANSFER_SIZE_Pos (20UL)                /*!< DMA_CHAN08_INST CONTROL: TRANSFER_SIZE (Bit 20)             */
#define DMA_CHAN08_INST_CONTROL_TRANSFER_SIZE_Msk (0x700000UL)          /*!< DMA_CHAN08_INST CONTROL: TRANSFER_SIZE (Bitfield-Mask: 0x07) */
#define DMA_CHAN08_INST_CONTROL_TRANSFER_GO_Pos (24UL)                  /*!< DMA_CHAN08_INST CONTROL: TRANSFER_GO (Bit 24)               */
#define DMA_CHAN08_INST_CONTROL_TRANSFER_GO_Msk (0x1000000UL)           /*!< DMA_CHAN08_INST CONTROL: TRANSFER_GO (Bitfield-Mask: 0x01)  */
#define DMA_CHAN08_INST_CONTROL_TRANSFER_ABORT_Pos (25UL)               /*!< DMA_CHAN08_INST CONTROL: TRANSFER_ABORT (Bit 25)            */
#define DMA_CHAN08_INST_CONTROL_TRANSFER_ABORT_Msk (0x2000000UL)        /*!< DMA_CHAN08_INST CONTROL: TRANSFER_ABORT (Bitfield-Mask: 0x01) */

/* -------------------------  DMA_CHAN08_INST_INT_STATUS  ------------------------- */
#define DMA_CHAN08_INST_INT_STATUS_BUS_ERROR_Pos (0UL)                  /*!< DMA_CHAN08_INST INT_STATUS: BUS_ERROR (Bit 0)               */
#define DMA_CHAN08_INST_INT_STATUS_BUS_ERROR_Msk (0x1UL)                /*!< DMA_CHAN08_INST INT_STATUS: BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN08_INST_INT_STATUS_FLOW_CONTROL_Pos (1UL)               /*!< DMA_CHAN08_INST INT_STATUS: FLOW_CONTROL (Bit 1)            */
#define DMA_CHAN08_INST_INT_STATUS_FLOW_CONTROL_Msk (0x2UL)             /*!< DMA_CHAN08_INST INT_STATUS: FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN08_INST_INT_STATUS_DONE_Pos   (2UL)                     /*!< DMA_CHAN08_INST INT_STATUS: DONE (Bit 2)                    */
#define DMA_CHAN08_INST_INT_STATUS_DONE_Msk   (0x4UL)                   /*!< DMA_CHAN08_INST INT_STATUS: DONE (Bitfield-Mask: 0x01)      */

/* ---------------------------  DMA_CHAN08_INST_INT_EN  --------------------------- */
#define DMA_CHAN08_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Pos (0UL)        /*!< DMA_CHAN08_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bit 0)     */
#define DMA_CHAN08_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Msk (0x1UL)      /*!< DMA_CHAN08_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN08_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Pos (1UL)     /*!< DMA_CHAN08_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bit 1)  */
#define DMA_CHAN08_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Msk (0x2UL)   /*!< DMA_CHAN08_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN08_INST_INT_EN_STATUS_ENABLE_DONE_Pos (2UL)             /*!< DMA_CHAN08_INST INT_EN: STATUS_ENABLE_DONE (Bit 2)          */
#define DMA_CHAN08_INST_INT_EN_STATUS_ENABLE_DONE_Msk (0x4UL)           /*!< DMA_CHAN08_INST INT_EN: STATUS_ENABLE_DONE (Bitfield-Mask: 0x01) */


/* ================================================================================ */
/* ================    struct 'DMA_CHAN09_INST' Position & Mask    ================ */
/* ================================================================================ */


/* --------------------  DMA_CHAN09_INST_DMA_CHANNEL_ACTIVATE  -------------------- */
#define DMA_CHAN09_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Pos (0UL) /*!< DMA_CHAN09_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bit 0) */
#define DMA_CHAN09_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Msk (0x1UL) /*!< DMA_CHAN09_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bitfield-Mask: 0x01) */

/* ---------------------------  DMA_CHAN09_INST_CONTROL  -------------------------- */
#define DMA_CHAN09_INST_CONTROL_RUN_Pos       (0UL)                     /*!< DMA_CHAN09_INST CONTROL: RUN (Bit 0)                        */
#define DMA_CHAN09_INST_CONTROL_RUN_Msk       (0x1UL)                   /*!< DMA_CHAN09_INST CONTROL: RUN (Bitfield-Mask: 0x01)          */
#define DMA_CHAN09_INST_CONTROL_REQUEST_Pos   (1UL)                     /*!< DMA_CHAN09_INST CONTROL: REQUEST (Bit 1)                    */
#define DMA_CHAN09_INST_CONTROL_REQUEST_Msk   (0x2UL)                   /*!< DMA_CHAN09_INST CONTROL: REQUEST (Bitfield-Mask: 0x01)      */
#define DMA_CHAN09_INST_CONTROL_DONE_Pos      (2UL)                     /*!< DMA_CHAN09_INST CONTROL: DONE (Bit 2)                       */
#define DMA_CHAN09_INST_CONTROL_DONE_Msk      (0x4UL)                   /*!< DMA_CHAN09_INST CONTROL: DONE (Bitfield-Mask: 0x01)         */
#define DMA_CHAN09_INST_CONTROL_STATUS_Pos    (3UL)                     /*!< DMA_CHAN09_INST CONTROL: STATUS (Bit 3)                     */
#define DMA_CHAN09_INST_CONTROL_STATUS_Msk    (0x18UL)                  /*!< DMA_CHAN09_INST CONTROL: STATUS (Bitfield-Mask: 0x03)       */
#define DMA_CHAN09_INST_CONTROL_BUSY_Pos      (5UL)                     /*!< DMA_CHAN09_INST CONTROL: BUSY (Bit 5)                       */
#define DMA_CHAN09_INST_CONTROL_BUSY_Msk      (0x20UL)                  /*!< DMA_CHAN09_INST CONTROL: BUSY (Bitfield-Mask: 0x01)         */
#define DMA_CHAN09_INST_CONTROL_TX_DIRECTION_Pos (8UL)                  /*!< DMA_CHAN09_INST CONTROL: TX_DIRECTION (Bit 8)               */
#define DMA_CHAN09_INST_CONTROL_TX_DIRECTION_Msk (0x100UL)              /*!< DMA_CHAN09_INST CONTROL: TX_DIRECTION (Bitfield-Mask: 0x01) */
#define DMA_CHAN09_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Pos (9UL)  /*!< DMA_CHAN09_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bit 9) */
#define DMA_CHAN09_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Msk (0xfe00UL) /*!< DMA_CHAN09_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bitfield-Mask: 0x7f) */
#define DMA_CHAN09_INST_CONTROL_INCREMENT_MEM_ADDR_Pos (16UL)           /*!< DMA_CHAN09_INST CONTROL: INCREMENT_MEM_ADDR (Bit 16)        */
#define DMA_CHAN09_INST_CONTROL_INCREMENT_MEM_ADDR_Msk (0x10000UL)      /*!< DMA_CHAN09_INST CONTROL: INCREMENT_MEM_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN09_INST_CONTROL_INCREMENT_DEVICE_ADDR_Pos (17UL)        /*!< DMA_CHAN09_INST CONTROL: INCREMENT_DEVICE_ADDR (Bit 17)     */
#define DMA_CHAN09_INST_CONTROL_INCREMENT_DEVICE_ADDR_Msk (0x20000UL)   /*!< DMA_CHAN09_INST CONTROL: INCREMENT_DEVICE_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN09_INST_CONTROL_LOCK_Pos      (18UL)                    /*!< DMA_CHAN09_INST CONTROL: LOCK (Bit 18)                      */
#define DMA_CHAN09_INST_CONTROL_LOCK_Msk      (0x40000UL)               /*!< DMA_CHAN09_INST CONTROL: LOCK (Bitfield-Mask: 0x01)         */
#define DMA_CHAN09_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Pos (19UL)      /*!< DMA_CHAN09_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bit 19)   */
#define DMA_CHAN09_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Msk (0x80000UL) /*!< DMA_CHAN09_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN09_INST_CONTROL_TRANSFER_SIZE_Pos (20UL)                /*!< DMA_CHAN09_INST CONTROL: TRANSFER_SIZE (Bit 20)             */
#define DMA_CHAN09_INST_CONTROL_TRANSFER_SIZE_Msk (0x700000UL)          /*!< DMA_CHAN09_INST CONTROL: TRANSFER_SIZE (Bitfield-Mask: 0x07) */
#define DMA_CHAN09_INST_CONTROL_TRANSFER_GO_Pos (24UL)                  /*!< DMA_CHAN09_INST CONTROL: TRANSFER_GO (Bit 24)               */
#define DMA_CHAN09_INST_CONTROL_TRANSFER_GO_Msk (0x1000000UL)           /*!< DMA_CHAN09_INST CONTROL: TRANSFER_GO (Bitfield-Mask: 0x01)  */
#define DMA_CHAN09_INST_CONTROL_TRANSFER_ABORT_Pos (25UL)               /*!< DMA_CHAN09_INST CONTROL: TRANSFER_ABORT (Bit 25)            */
#define DMA_CHAN09_INST_CONTROL_TRANSFER_ABORT_Msk (0x2000000UL)        /*!< DMA_CHAN09_INST CONTROL: TRANSFER_ABORT (Bitfield-Mask: 0x01) */

/* -------------------------  DMA_CHAN09_INST_INT_STATUS  ------------------------- */
#define DMA_CHAN09_INST_INT_STATUS_BUS_ERROR_Pos (0UL)                  /*!< DMA_CHAN09_INST INT_STATUS: BUS_ERROR (Bit 0)               */
#define DMA_CHAN09_INST_INT_STATUS_BUS_ERROR_Msk (0x1UL)                /*!< DMA_CHAN09_INST INT_STATUS: BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN09_INST_INT_STATUS_FLOW_CONTROL_Pos (1UL)               /*!< DMA_CHAN09_INST INT_STATUS: FLOW_CONTROL (Bit 1)            */
#define DMA_CHAN09_INST_INT_STATUS_FLOW_CONTROL_Msk (0x2UL)             /*!< DMA_CHAN09_INST INT_STATUS: FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN09_INST_INT_STATUS_DONE_Pos   (2UL)                     /*!< DMA_CHAN09_INST INT_STATUS: DONE (Bit 2)                    */
#define DMA_CHAN09_INST_INT_STATUS_DONE_Msk   (0x4UL)                   /*!< DMA_CHAN09_INST INT_STATUS: DONE (Bitfield-Mask: 0x01)      */

/* ---------------------------  DMA_CHAN09_INST_INT_EN  --------------------------- */
#define DMA_CHAN09_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Pos (0UL)        /*!< DMA_CHAN09_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bit 0)     */
#define DMA_CHAN09_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Msk (0x1UL)      /*!< DMA_CHAN09_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN09_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Pos (1UL)     /*!< DMA_CHAN09_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bit 1)  */
#define DMA_CHAN09_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Msk (0x2UL)   /*!< DMA_CHAN09_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN09_INST_INT_EN_STATUS_ENABLE_DONE_Pos (2UL)             /*!< DMA_CHAN09_INST INT_EN: STATUS_ENABLE_DONE (Bit 2)          */
#define DMA_CHAN09_INST_INT_EN_STATUS_ENABLE_DONE_Msk (0x4UL)           /*!< DMA_CHAN09_INST INT_EN: STATUS_ENABLE_DONE (Bitfield-Mask: 0x01) */


/* ================================================================================ */
/* ================    struct 'DMA_CHAN10_INST' Position & Mask    ================ */
/* ================================================================================ */


/* --------------------  DMA_CHAN10_INST_DMA_CHANNEL_ACTIVATE  -------------------- */
#define DMA_CHAN10_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Pos (0UL) /*!< DMA_CHAN10_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bit 0) */
#define DMA_CHAN10_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Msk (0x1UL) /*!< DMA_CHAN10_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bitfield-Mask: 0x01) */

/* ---------------------------  DMA_CHAN10_INST_CONTROL  -------------------------- */
#define DMA_CHAN10_INST_CONTROL_RUN_Pos       (0UL)                     /*!< DMA_CHAN10_INST CONTROL: RUN (Bit 0)                        */
#define DMA_CHAN10_INST_CONTROL_RUN_Msk       (0x1UL)                   /*!< DMA_CHAN10_INST CONTROL: RUN (Bitfield-Mask: 0x01)          */
#define DMA_CHAN10_INST_CONTROL_REQUEST_Pos   (1UL)                     /*!< DMA_CHAN10_INST CONTROL: REQUEST (Bit 1)                    */
#define DMA_CHAN10_INST_CONTROL_REQUEST_Msk   (0x2UL)                   /*!< DMA_CHAN10_INST CONTROL: REQUEST (Bitfield-Mask: 0x01)      */
#define DMA_CHAN10_INST_CONTROL_DONE_Pos      (2UL)                     /*!< DMA_CHAN10_INST CONTROL: DONE (Bit 2)                       */
#define DMA_CHAN10_INST_CONTROL_DONE_Msk      (0x4UL)                   /*!< DMA_CHAN10_INST CONTROL: DONE (Bitfield-Mask: 0x01)         */
#define DMA_CHAN10_INST_CONTROL_STATUS_Pos    (3UL)                     /*!< DMA_CHAN10_INST CONTROL: STATUS (Bit 3)                     */
#define DMA_CHAN10_INST_CONTROL_STATUS_Msk    (0x18UL)                  /*!< DMA_CHAN10_INST CONTROL: STATUS (Bitfield-Mask: 0x03)       */
#define DMA_CHAN10_INST_CONTROL_BUSY_Pos      (5UL)                     /*!< DMA_CHAN10_INST CONTROL: BUSY (Bit 5)                       */
#define DMA_CHAN10_INST_CONTROL_BUSY_Msk      (0x20UL)                  /*!< DMA_CHAN10_INST CONTROL: BUSY (Bitfield-Mask: 0x01)         */
#define DMA_CHAN10_INST_CONTROL_TX_DIRECTION_Pos (8UL)                  /*!< DMA_CHAN10_INST CONTROL: TX_DIRECTION (Bit 8)               */
#define DMA_CHAN10_INST_CONTROL_TX_DIRECTION_Msk (0x100UL)              /*!< DMA_CHAN10_INST CONTROL: TX_DIRECTION (Bitfield-Mask: 0x01) */
#define DMA_CHAN10_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Pos (9UL)  /*!< DMA_CHAN10_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bit 9) */
#define DMA_CHAN10_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Msk (0xfe00UL) /*!< DMA_CHAN10_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bitfield-Mask: 0x7f) */
#define DMA_CHAN10_INST_CONTROL_INCREMENT_MEM_ADDR_Pos (16UL)           /*!< DMA_CHAN10_INST CONTROL: INCREMENT_MEM_ADDR (Bit 16)        */
#define DMA_CHAN10_INST_CONTROL_INCREMENT_MEM_ADDR_Msk (0x10000UL)      /*!< DMA_CHAN10_INST CONTROL: INCREMENT_MEM_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN10_INST_CONTROL_INCREMENT_DEVICE_ADDR_Pos (17UL)        /*!< DMA_CHAN10_INST CONTROL: INCREMENT_DEVICE_ADDR (Bit 17)     */
#define DMA_CHAN10_INST_CONTROL_INCREMENT_DEVICE_ADDR_Msk (0x20000UL)   /*!< DMA_CHAN10_INST CONTROL: INCREMENT_DEVICE_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN10_INST_CONTROL_LOCK_Pos      (18UL)                    /*!< DMA_CHAN10_INST CONTROL: LOCK (Bit 18)                      */
#define DMA_CHAN10_INST_CONTROL_LOCK_Msk      (0x40000UL)               /*!< DMA_CHAN10_INST CONTROL: LOCK (Bitfield-Mask: 0x01)         */
#define DMA_CHAN10_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Pos (19UL)      /*!< DMA_CHAN10_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bit 19)   */
#define DMA_CHAN10_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Msk (0x80000UL) /*!< DMA_CHAN10_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN10_INST_CONTROL_TRANSFER_SIZE_Pos (20UL)                /*!< DMA_CHAN10_INST CONTROL: TRANSFER_SIZE (Bit 20)             */
#define DMA_CHAN10_INST_CONTROL_TRANSFER_SIZE_Msk (0x700000UL)          /*!< DMA_CHAN10_INST CONTROL: TRANSFER_SIZE (Bitfield-Mask: 0x07) */
#define DMA_CHAN10_INST_CONTROL_TRANSFER_GO_Pos (24UL)                  /*!< DMA_CHAN10_INST CONTROL: TRANSFER_GO (Bit 24)               */
#define DMA_CHAN10_INST_CONTROL_TRANSFER_GO_Msk (0x1000000UL)           /*!< DMA_CHAN10_INST CONTROL: TRANSFER_GO (Bitfield-Mask: 0x01)  */
#define DMA_CHAN10_INST_CONTROL_TRANSFER_ABORT_Pos (25UL)               /*!< DMA_CHAN10_INST CONTROL: TRANSFER_ABORT (Bit 25)            */
#define DMA_CHAN10_INST_CONTROL_TRANSFER_ABORT_Msk (0x2000000UL)        /*!< DMA_CHAN10_INST CONTROL: TRANSFER_ABORT (Bitfield-Mask: 0x01) */

/* -------------------------  DMA_CHAN10_INST_INT_STATUS  ------------------------- */
#define DMA_CHAN10_INST_INT_STATUS_BUS_ERROR_Pos (0UL)                  /*!< DMA_CHAN10_INST INT_STATUS: BUS_ERROR (Bit 0)               */
#define DMA_CHAN10_INST_INT_STATUS_BUS_ERROR_Msk (0x1UL)                /*!< DMA_CHAN10_INST INT_STATUS: BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN10_INST_INT_STATUS_FLOW_CONTROL_Pos (1UL)               /*!< DMA_CHAN10_INST INT_STATUS: FLOW_CONTROL (Bit 1)            */
#define DMA_CHAN10_INST_INT_STATUS_FLOW_CONTROL_Msk (0x2UL)             /*!< DMA_CHAN10_INST INT_STATUS: FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN10_INST_INT_STATUS_DONE_Pos   (2UL)                     /*!< DMA_CHAN10_INST INT_STATUS: DONE (Bit 2)                    */
#define DMA_CHAN10_INST_INT_STATUS_DONE_Msk   (0x4UL)                   /*!< DMA_CHAN10_INST INT_STATUS: DONE (Bitfield-Mask: 0x01)      */

/* ---------------------------  DMA_CHAN10_INST_INT_EN  --------------------------- */
#define DMA_CHAN10_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Pos (0UL)        /*!< DMA_CHAN10_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bit 0)     */
#define DMA_CHAN10_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Msk (0x1UL)      /*!< DMA_CHAN10_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN10_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Pos (1UL)     /*!< DMA_CHAN10_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bit 1)  */
#define DMA_CHAN10_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Msk (0x2UL)   /*!< DMA_CHAN10_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN10_INST_INT_EN_STATUS_ENABLE_DONE_Pos (2UL)             /*!< DMA_CHAN10_INST INT_EN: STATUS_ENABLE_DONE (Bit 2)          */
#define DMA_CHAN10_INST_INT_EN_STATUS_ENABLE_DONE_Msk (0x4UL)           /*!< DMA_CHAN10_INST INT_EN: STATUS_ENABLE_DONE (Bitfield-Mask: 0x01) */


/* ================================================================================ */
/* ================    struct 'DMA_CHAN11_INST' Position & Mask    ================ */
/* ================================================================================ */


/* --------------------  DMA_CHAN11_INST_DMA_CHANNEL_ACTIVATE  -------------------- */
#define DMA_CHAN11_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Pos (0UL) /*!< DMA_CHAN11_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bit 0) */
#define DMA_CHAN11_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Msk (0x1UL) /*!< DMA_CHAN11_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bitfield-Mask: 0x01) */

/* ---------------------------  DMA_CHAN11_INST_CONTROL  -------------------------- */
#define DMA_CHAN11_INST_CONTROL_RUN_Pos       (0UL)                     /*!< DMA_CHAN11_INST CONTROL: RUN (Bit 0)                        */
#define DMA_CHAN11_INST_CONTROL_RUN_Msk       (0x1UL)                   /*!< DMA_CHAN11_INST CONTROL: RUN (Bitfield-Mask: 0x01)          */
#define DMA_CHAN11_INST_CONTROL_REQUEST_Pos   (1UL)                     /*!< DMA_CHAN11_INST CONTROL: REQUEST (Bit 1)                    */
#define DMA_CHAN11_INST_CONTROL_REQUEST_Msk   (0x2UL)                   /*!< DMA_CHAN11_INST CONTROL: REQUEST (Bitfield-Mask: 0x01)      */
#define DMA_CHAN11_INST_CONTROL_DONE_Pos      (2UL)                     /*!< DMA_CHAN11_INST CONTROL: DONE (Bit 2)                       */
#define DMA_CHAN11_INST_CONTROL_DONE_Msk      (0x4UL)                   /*!< DMA_CHAN11_INST CONTROL: DONE (Bitfield-Mask: 0x01)         */
#define DMA_CHAN11_INST_CONTROL_STATUS_Pos    (3UL)                     /*!< DMA_CHAN11_INST CONTROL: STATUS (Bit 3)                     */
#define DMA_CHAN11_INST_CONTROL_STATUS_Msk    (0x18UL)                  /*!< DMA_CHAN11_INST CONTROL: STATUS (Bitfield-Mask: 0x03)       */
#define DMA_CHAN11_INST_CONTROL_BUSY_Pos      (5UL)                     /*!< DMA_CHAN11_INST CONTROL: BUSY (Bit 5)                       */
#define DMA_CHAN11_INST_CONTROL_BUSY_Msk      (0x20UL)                  /*!< DMA_CHAN11_INST CONTROL: BUSY (Bitfield-Mask: 0x01)         */
#define DMA_CHAN11_INST_CONTROL_TX_DIRECTION_Pos (8UL)                  /*!< DMA_CHAN11_INST CONTROL: TX_DIRECTION (Bit 8)               */
#define DMA_CHAN11_INST_CONTROL_TX_DIRECTION_Msk (0x100UL)              /*!< DMA_CHAN11_INST CONTROL: TX_DIRECTION (Bitfield-Mask: 0x01) */
#define DMA_CHAN11_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Pos (9UL)  /*!< DMA_CHAN11_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bit 9) */
#define DMA_CHAN11_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Msk (0xfe00UL) /*!< DMA_CHAN11_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bitfield-Mask: 0x7f) */
#define DMA_CHAN11_INST_CONTROL_INCREMENT_MEM_ADDR_Pos (16UL)           /*!< DMA_CHAN11_INST CONTROL: INCREMENT_MEM_ADDR (Bit 16)        */
#define DMA_CHAN11_INST_CONTROL_INCREMENT_MEM_ADDR_Msk (0x10000UL)      /*!< DMA_CHAN11_INST CONTROL: INCREMENT_MEM_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN11_INST_CONTROL_INCREMENT_DEVICE_ADDR_Pos (17UL)        /*!< DMA_CHAN11_INST CONTROL: INCREMENT_DEVICE_ADDR (Bit 17)     */
#define DMA_CHAN11_INST_CONTROL_INCREMENT_DEVICE_ADDR_Msk (0x20000UL)   /*!< DMA_CHAN11_INST CONTROL: INCREMENT_DEVICE_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN11_INST_CONTROL_LOCK_Pos      (18UL)                    /*!< DMA_CHAN11_INST CONTROL: LOCK (Bit 18)                      */
#define DMA_CHAN11_INST_CONTROL_LOCK_Msk      (0x40000UL)               /*!< DMA_CHAN11_INST CONTROL: LOCK (Bitfield-Mask: 0x01)         */
#define DMA_CHAN11_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Pos (19UL)      /*!< DMA_CHAN11_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bit 19)   */
#define DMA_CHAN11_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Msk (0x80000UL) /*!< DMA_CHAN11_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN11_INST_CONTROL_TRANSFER_SIZE_Pos (20UL)                /*!< DMA_CHAN11_INST CONTROL: TRANSFER_SIZE (Bit 20)             */
#define DMA_CHAN11_INST_CONTROL_TRANSFER_SIZE_Msk (0x700000UL)          /*!< DMA_CHAN11_INST CONTROL: TRANSFER_SIZE (Bitfield-Mask: 0x07) */
#define DMA_CHAN11_INST_CONTROL_TRANSFER_GO_Pos (24UL)                  /*!< DMA_CHAN11_INST CONTROL: TRANSFER_GO (Bit 24)               */
#define DMA_CHAN11_INST_CONTROL_TRANSFER_GO_Msk (0x1000000UL)           /*!< DMA_CHAN11_INST CONTROL: TRANSFER_GO (Bitfield-Mask: 0x01)  */
#define DMA_CHAN11_INST_CONTROL_TRANSFER_ABORT_Pos (25UL)               /*!< DMA_CHAN11_INST CONTROL: TRANSFER_ABORT (Bit 25)            */
#define DMA_CHAN11_INST_CONTROL_TRANSFER_ABORT_Msk (0x2000000UL)        /*!< DMA_CHAN11_INST CONTROL: TRANSFER_ABORT (Bitfield-Mask: 0x01) */

/* -------------------------  DMA_CHAN11_INST_INT_STATUS  ------------------------- */
#define DMA_CHAN11_INST_INT_STATUS_BUS_ERROR_Pos (0UL)                  /*!< DMA_CHAN11_INST INT_STATUS: BUS_ERROR (Bit 0)               */
#define DMA_CHAN11_INST_INT_STATUS_BUS_ERROR_Msk (0x1UL)                /*!< DMA_CHAN11_INST INT_STATUS: BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN11_INST_INT_STATUS_FLOW_CONTROL_Pos (1UL)               /*!< DMA_CHAN11_INST INT_STATUS: FLOW_CONTROL (Bit 1)            */
#define DMA_CHAN11_INST_INT_STATUS_FLOW_CONTROL_Msk (0x2UL)             /*!< DMA_CHAN11_INST INT_STATUS: FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN11_INST_INT_STATUS_DONE_Pos   (2UL)                     /*!< DMA_CHAN11_INST INT_STATUS: DONE (Bit 2)                    */
#define DMA_CHAN11_INST_INT_STATUS_DONE_Msk   (0x4UL)                   /*!< DMA_CHAN11_INST INT_STATUS: DONE (Bitfield-Mask: 0x01)      */

/* ---------------------------  DMA_CHAN11_INST_INT_EN  --------------------------- */
#define DMA_CHAN11_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Pos (0UL)        /*!< DMA_CHAN11_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bit 0)     */
#define DMA_CHAN11_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Msk (0x1UL)      /*!< DMA_CHAN11_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN11_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Pos (1UL)     /*!< DMA_CHAN11_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bit 1)  */
#define DMA_CHAN11_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Msk (0x2UL)   /*!< DMA_CHAN11_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN11_INST_INT_EN_STATUS_ENABLE_DONE_Pos (2UL)             /*!< DMA_CHAN11_INST INT_EN: STATUS_ENABLE_DONE (Bit 2)          */
#define DMA_CHAN11_INST_INT_EN_STATUS_ENABLE_DONE_Msk (0x4UL)           /*!< DMA_CHAN11_INST INT_EN: STATUS_ENABLE_DONE (Bitfield-Mask: 0x01) */


/* ================================================================================ */
/* ================    struct 'DMA_CHAN12_INST' Position & Mask    ================ */
/* ================================================================================ */


/* --------------------  DMA_CHAN12_INST_DMA_CHANNEL_ACTIVATE  -------------------- */
#define DMA_CHAN12_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Pos (0UL) /*!< DMA_CHAN12_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bit 0) */
#define DMA_CHAN12_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Msk (0x1UL) /*!< DMA_CHAN12_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bitfield-Mask: 0x01) */

/* ---------------------------  DMA_CHAN12_INST_CONTROL  -------------------------- */
#define DMA_CHAN12_INST_CONTROL_RUN_Pos       (0UL)                     /*!< DMA_CHAN12_INST CONTROL: RUN (Bit 0)                        */
#define DMA_CHAN12_INST_CONTROL_RUN_Msk       (0x1UL)                   /*!< DMA_CHAN12_INST CONTROL: RUN (Bitfield-Mask: 0x01)          */
#define DMA_CHAN12_INST_CONTROL_REQUEST_Pos   (1UL)                     /*!< DMA_CHAN12_INST CONTROL: REQUEST (Bit 1)                    */
#define DMA_CHAN12_INST_CONTROL_REQUEST_Msk   (0x2UL)                   /*!< DMA_CHAN12_INST CONTROL: REQUEST (Bitfield-Mask: 0x01)      */
#define DMA_CHAN12_INST_CONTROL_DONE_Pos      (2UL)                     /*!< DMA_CHAN12_INST CONTROL: DONE (Bit 2)                       */
#define DMA_CHAN12_INST_CONTROL_DONE_Msk      (0x4UL)                   /*!< DMA_CHAN12_INST CONTROL: DONE (Bitfield-Mask: 0x01)         */
#define DMA_CHAN12_INST_CONTROL_STATUS_Pos    (3UL)                     /*!< DMA_CHAN12_INST CONTROL: STATUS (Bit 3)                     */
#define DMA_CHAN12_INST_CONTROL_STATUS_Msk    (0x18UL)                  /*!< DMA_CHAN12_INST CONTROL: STATUS (Bitfield-Mask: 0x03)       */
#define DMA_CHAN12_INST_CONTROL_BUSY_Pos      (5UL)                     /*!< DMA_CHAN12_INST CONTROL: BUSY (Bit 5)                       */
#define DMA_CHAN12_INST_CONTROL_BUSY_Msk      (0x20UL)                  /*!< DMA_CHAN12_INST CONTROL: BUSY (Bitfield-Mask: 0x01)         */
#define DMA_CHAN12_INST_CONTROL_TX_DIRECTION_Pos (8UL)                  /*!< DMA_CHAN12_INST CONTROL: TX_DIRECTION (Bit 8)               */
#define DMA_CHAN12_INST_CONTROL_TX_DIRECTION_Msk (0x100UL)              /*!< DMA_CHAN12_INST CONTROL: TX_DIRECTION (Bitfield-Mask: 0x01) */
#define DMA_CHAN12_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Pos (9UL)  /*!< DMA_CHAN12_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bit 9) */
#define DMA_CHAN12_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Msk (0xfe00UL) /*!< DMA_CHAN12_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bitfield-Mask: 0x7f) */
#define DMA_CHAN12_INST_CONTROL_INCREMENT_MEM_ADDR_Pos (16UL)           /*!< DMA_CHAN12_INST CONTROL: INCREMENT_MEM_ADDR (Bit 16)        */
#define DMA_CHAN12_INST_CONTROL_INCREMENT_MEM_ADDR_Msk (0x10000UL)      /*!< DMA_CHAN12_INST CONTROL: INCREMENT_MEM_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN12_INST_CONTROL_INCREMENT_DEVICE_ADDR_Pos (17UL)        /*!< DMA_CHAN12_INST CONTROL: INCREMENT_DEVICE_ADDR (Bit 17)     */
#define DMA_CHAN12_INST_CONTROL_INCREMENT_DEVICE_ADDR_Msk (0x20000UL)   /*!< DMA_CHAN12_INST CONTROL: INCREMENT_DEVICE_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN12_INST_CONTROL_LOCK_Pos      (18UL)                    /*!< DMA_CHAN12_INST CONTROL: LOCK (Bit 18)                      */
#define DMA_CHAN12_INST_CONTROL_LOCK_Msk      (0x40000UL)               /*!< DMA_CHAN12_INST CONTROL: LOCK (Bitfield-Mask: 0x01)         */
#define DMA_CHAN12_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Pos (19UL)      /*!< DMA_CHAN12_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bit 19)   */
#define DMA_CHAN12_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Msk (0x80000UL) /*!< DMA_CHAN12_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN12_INST_CONTROL_TRANSFER_SIZE_Pos (20UL)                /*!< DMA_CHAN12_INST CONTROL: TRANSFER_SIZE (Bit 20)             */
#define DMA_CHAN12_INST_CONTROL_TRANSFER_SIZE_Msk (0x700000UL)          /*!< DMA_CHAN12_INST CONTROL: TRANSFER_SIZE (Bitfield-Mask: 0x07) */
#define DMA_CHAN12_INST_CONTROL_TRANSFER_GO_Pos (24UL)                  /*!< DMA_CHAN12_INST CONTROL: TRANSFER_GO (Bit 24)               */
#define DMA_CHAN12_INST_CONTROL_TRANSFER_GO_Msk (0x1000000UL)           /*!< DMA_CHAN12_INST CONTROL: TRANSFER_GO (Bitfield-Mask: 0x01)  */
#define DMA_CHAN12_INST_CONTROL_TRANSFER_ABORT_Pos (25UL)               /*!< DMA_CHAN12_INST CONTROL: TRANSFER_ABORT (Bit 25)            */
#define DMA_CHAN12_INST_CONTROL_TRANSFER_ABORT_Msk (0x2000000UL)        /*!< DMA_CHAN12_INST CONTROL: TRANSFER_ABORT (Bitfield-Mask: 0x01) */

/* -------------------------  DMA_CHAN12_INST_INT_STATUS  ------------------------- */
#define DMA_CHAN12_INST_INT_STATUS_BUS_ERROR_Pos (0UL)                  /*!< DMA_CHAN12_INST INT_STATUS: BUS_ERROR (Bit 0)               */
#define DMA_CHAN12_INST_INT_STATUS_BUS_ERROR_Msk (0x1UL)                /*!< DMA_CHAN12_INST INT_STATUS: BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN12_INST_INT_STATUS_FLOW_CONTROL_Pos (1UL)               /*!< DMA_CHAN12_INST INT_STATUS: FLOW_CONTROL (Bit 1)            */
#define DMA_CHAN12_INST_INT_STATUS_FLOW_CONTROL_Msk (0x2UL)             /*!< DMA_CHAN12_INST INT_STATUS: FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN12_INST_INT_STATUS_DONE_Pos   (2UL)                     /*!< DMA_CHAN12_INST INT_STATUS: DONE (Bit 2)                    */
#define DMA_CHAN12_INST_INT_STATUS_DONE_Msk   (0x4UL)                   /*!< DMA_CHAN12_INST INT_STATUS: DONE (Bitfield-Mask: 0x01)      */

/* ---------------------------  DMA_CHAN12_INST_INT_EN  --------------------------- */
#define DMA_CHAN12_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Pos (0UL)        /*!< DMA_CHAN12_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bit 0)     */
#define DMA_CHAN12_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Msk (0x1UL)      /*!< DMA_CHAN12_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN12_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Pos (1UL)     /*!< DMA_CHAN12_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bit 1)  */
#define DMA_CHAN12_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Msk (0x2UL)   /*!< DMA_CHAN12_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN12_INST_INT_EN_STATUS_ENABLE_DONE_Pos (2UL)             /*!< DMA_CHAN12_INST INT_EN: STATUS_ENABLE_DONE (Bit 2)          */
#define DMA_CHAN12_INST_INT_EN_STATUS_ENABLE_DONE_Msk (0x4UL)           /*!< DMA_CHAN12_INST INT_EN: STATUS_ENABLE_DONE (Bitfield-Mask: 0x01) */


/* ================================================================================ */
/* ================    struct 'DMA_CHAN13_INST' Position & Mask    ================ */
/* ================================================================================ */


/* --------------------  DMA_CHAN13_INST_DMA_CHANNEL_ACTIVATE  -------------------- */
#define DMA_CHAN13_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Pos (0UL) /*!< DMA_CHAN13_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bit 0) */
#define DMA_CHAN13_INST_DMA_CHANNEL_ACTIVATE_CHANNEL_ACTIVATE_Msk (0x1UL) /*!< DMA_CHAN13_INST DMA_CHANNEL_ACTIVATE: CHANNEL_ACTIVATE (Bitfield-Mask: 0x01) */

/* ---------------------------  DMA_CHAN13_INST_CONTROL  -------------------------- */
#define DMA_CHAN13_INST_CONTROL_RUN_Pos       (0UL)                     /*!< DMA_CHAN13_INST CONTROL: RUN (Bit 0)                        */
#define DMA_CHAN13_INST_CONTROL_RUN_Msk       (0x1UL)                   /*!< DMA_CHAN13_INST CONTROL: RUN (Bitfield-Mask: 0x01)          */
#define DMA_CHAN13_INST_CONTROL_REQUEST_Pos   (1UL)                     /*!< DMA_CHAN13_INST CONTROL: REQUEST (Bit 1)                    */
#define DMA_CHAN13_INST_CONTROL_REQUEST_Msk   (0x2UL)                   /*!< DMA_CHAN13_INST CONTROL: REQUEST (Bitfield-Mask: 0x01)      */
#define DMA_CHAN13_INST_CONTROL_DONE_Pos      (2UL)                     /*!< DMA_CHAN13_INST CONTROL: DONE (Bit 2)                       */
#define DMA_CHAN13_INST_CONTROL_DONE_Msk      (0x4UL)                   /*!< DMA_CHAN13_INST CONTROL: DONE (Bitfield-Mask: 0x01)         */
#define DMA_CHAN13_INST_CONTROL_STATUS_Pos    (3UL)                     /*!< DMA_CHAN13_INST CONTROL: STATUS (Bit 3)                     */
#define DMA_CHAN13_INST_CONTROL_STATUS_Msk    (0x18UL)                  /*!< DMA_CHAN13_INST CONTROL: STATUS (Bitfield-Mask: 0x03)       */
#define DMA_CHAN13_INST_CONTROL_BUSY_Pos      (5UL)                     /*!< DMA_CHAN13_INST CONTROL: BUSY (Bit 5)                       */
#define DMA_CHAN13_INST_CONTROL_BUSY_Msk      (0x20UL)                  /*!< DMA_CHAN13_INST CONTROL: BUSY (Bitfield-Mask: 0x01)         */
#define DMA_CHAN13_INST_CONTROL_TX_DIRECTION_Pos (8UL)                  /*!< DMA_CHAN13_INST CONTROL: TX_DIRECTION (Bit 8)               */
#define DMA_CHAN13_INST_CONTROL_TX_DIRECTION_Msk (0x100UL)              /*!< DMA_CHAN13_INST CONTROL: TX_DIRECTION (Bitfield-Mask: 0x01) */
#define DMA_CHAN13_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Pos (9UL)  /*!< DMA_CHAN13_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bit 9) */
#define DMA_CHAN13_INST_CONTROL_HARDWARE_FLOW_CONTROL_DEVICE_Msk (0xfe00UL) /*!< DMA_CHAN13_INST CONTROL: HARDWARE_FLOW_CONTROL_DEVICE (Bitfield-Mask: 0x7f) */
#define DMA_CHAN13_INST_CONTROL_INCREMENT_MEM_ADDR_Pos (16UL)           /*!< DMA_CHAN13_INST CONTROL: INCREMENT_MEM_ADDR (Bit 16)        */
#define DMA_CHAN13_INST_CONTROL_INCREMENT_MEM_ADDR_Msk (0x10000UL)      /*!< DMA_CHAN13_INST CONTROL: INCREMENT_MEM_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN13_INST_CONTROL_INCREMENT_DEVICE_ADDR_Pos (17UL)        /*!< DMA_CHAN13_INST CONTROL: INCREMENT_DEVICE_ADDR (Bit 17)     */
#define DMA_CHAN13_INST_CONTROL_INCREMENT_DEVICE_ADDR_Msk (0x20000UL)   /*!< DMA_CHAN13_INST CONTROL: INCREMENT_DEVICE_ADDR (Bitfield-Mask: 0x01) */
#define DMA_CHAN13_INST_CONTROL_LOCK_Pos      (18UL)                    /*!< DMA_CHAN13_INST CONTROL: LOCK (Bit 18)                      */
#define DMA_CHAN13_INST_CONTROL_LOCK_Msk      (0x40000UL)               /*!< DMA_CHAN13_INST CONTROL: LOCK (Bitfield-Mask: 0x01)         */
#define DMA_CHAN13_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Pos (19UL)      /*!< DMA_CHAN13_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bit 19)   */
#define DMA_CHAN13_INST_CONTROL_DISABLE_HW_FLOW_CONTROL_Msk (0x80000UL) /*!< DMA_CHAN13_INST CONTROL: DISABLE_HW_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN13_INST_CONTROL_TRANSFER_SIZE_Pos (20UL)                /*!< DMA_CHAN13_INST CONTROL: TRANSFER_SIZE (Bit 20)             */
#define DMA_CHAN13_INST_CONTROL_TRANSFER_SIZE_Msk (0x700000UL)          /*!< DMA_CHAN13_INST CONTROL: TRANSFER_SIZE (Bitfield-Mask: 0x07) */
#define DMA_CHAN13_INST_CONTROL_TRANSFER_GO_Pos (24UL)                  /*!< DMA_CHAN13_INST CONTROL: TRANSFER_GO (Bit 24)               */
#define DMA_CHAN13_INST_CONTROL_TRANSFER_GO_Msk (0x1000000UL)           /*!< DMA_CHAN13_INST CONTROL: TRANSFER_GO (Bitfield-Mask: 0x01)  */
#define DMA_CHAN13_INST_CONTROL_TRANSFER_ABORT_Pos (25UL)               /*!< DMA_CHAN13_INST CONTROL: TRANSFER_ABORT (Bit 25)            */
#define DMA_CHAN13_INST_CONTROL_TRANSFER_ABORT_Msk (0x2000000UL)        /*!< DMA_CHAN13_INST CONTROL: TRANSFER_ABORT (Bitfield-Mask: 0x01) */

/* -------------------------  DMA_CHAN13_INST_INT_STATUS  ------------------------- */
#define DMA_CHAN13_INST_INT_STATUS_BUS_ERROR_Pos (0UL)                  /*!< DMA_CHAN13_INST INT_STATUS: BUS_ERROR (Bit 0)               */
#define DMA_CHAN13_INST_INT_STATUS_BUS_ERROR_Msk (0x1UL)                /*!< DMA_CHAN13_INST INT_STATUS: BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN13_INST_INT_STATUS_FLOW_CONTROL_Pos (1UL)               /*!< DMA_CHAN13_INST INT_STATUS: FLOW_CONTROL (Bit 1)            */
#define DMA_CHAN13_INST_INT_STATUS_FLOW_CONTROL_Msk (0x2UL)             /*!< DMA_CHAN13_INST INT_STATUS: FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN13_INST_INT_STATUS_DONE_Pos   (2UL)                     /*!< DMA_CHAN13_INST INT_STATUS: DONE (Bit 2)                    */
#define DMA_CHAN13_INST_INT_STATUS_DONE_Msk   (0x4UL)                   /*!< DMA_CHAN13_INST INT_STATUS: DONE (Bitfield-Mask: 0x01)      */

/* ---------------------------  DMA_CHAN13_INST_INT_EN  --------------------------- */
#define DMA_CHAN13_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Pos (0UL)        /*!< DMA_CHAN13_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bit 0)     */
#define DMA_CHAN13_INST_INT_EN_STATUS_ENABLE_BUS_ERROR_Msk (0x1UL)      /*!< DMA_CHAN13_INST INT_EN: STATUS_ENABLE_BUS_ERROR (Bitfield-Mask: 0x01) */
#define DMA_CHAN13_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Pos (1UL)     /*!< DMA_CHAN13_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bit 1)  */
#define DMA_CHAN13_INST_INT_EN_STATUS_ENABLE_FLOW_CONTROL_Msk (0x2UL)   /*!< DMA_CHAN13_INST INT_EN: STATUS_ENABLE_FLOW_CONTROL (Bitfield-Mask: 0x01) */
#define DMA_CHAN13_INST_INT_EN_STATUS_ENABLE_DONE_Pos (2UL)             /*!< DMA_CHAN13_INST INT_EN: STATUS_ENABLE_DONE (Bit 2)          */
#define DMA_CHAN13_INST_INT_EN_STATUS_ENABLE_DONE_Msk (0x4UL)           /*!< DMA_CHAN13_INST INT_EN: STATUS_ENABLE_DONE (Bitfield-Mask: 0x01) */


/* ================================================================================ */
/* ================       struct 'INTS_INST' Position & Mask       ================ */
/* ================================================================================ */


/* -------------------------  INTS_INST_BLOCK_ENABLE_SET  ------------------------- */
#define INTS_INST_BLOCK_ENABLE_SET_IRQ_VECTOR_ENABLE_SET_Pos (0UL)      /*!< INTS_INST BLOCK_ENABLE_SET: IRQ_VECTOR_ENABLE_SET (Bit 0)   */
#define INTS_INST_BLOCK_ENABLE_SET_IRQ_VECTOR_ENABLE_SET_Msk (0x7fffffffUL) /*!< INTS_INST BLOCK_ENABLE_SET: IRQ_VECTOR_ENABLE_SET (Bitfield-Mask: 0x7fffffff) */

/* ------------------------  INTS_INST_BLOCK_ENABLE_CLEAR  ------------------------ */
#define INTS_INST_BLOCK_ENABLE_CLEAR_IRQ_VECTOR_ENABLE_CLEAR_Pos (0UL)  /*!< INTS_INST BLOCK_ENABLE_CLEAR: IRQ_VECTOR_ENABLE_CLEAR (Bit 0) */
#define INTS_INST_BLOCK_ENABLE_CLEAR_IRQ_VECTOR_ENABLE_CLEAR_Msk (0x7fffffffUL) /*!< INTS_INST BLOCK_ENABLE_CLEAR: IRQ_VECTOR_ENABLE_CLEAR (Bitfield-Mask: 0x7fffffff) */

/* -------------------------  INTS_INST_BLOCK_IRQ_VECTOR  ------------------------- */
#define INTS_INST_BLOCK_IRQ_VECTOR_IRQ_VECTOR_Pos (0UL)                 /*!< INTS_INST BLOCK_IRQ_VECTOR: IRQ_VECTOR (Bit 0)              */
#define INTS_INST_BLOCK_IRQ_VECTOR_IRQ_VECTOR_Msk (0x1ffffffUL)         /*!< INTS_INST BLOCK_IRQ_VECTOR: IRQ_VECTOR (Bitfield-Mask: 0x1ffffff) */


/* ================================================================================ */
/* ================       struct 'UART0_INST' Position & Mask      ================ */
/* ================================================================================ */


/* ------------------------------  UART0_INST_INT_EN  ----------------------------- */
#define UART0_INST_INT_EN_ERDAI_Pos           (0UL)                     /*!< UART0_INST INT_EN: ERDAI (Bit 0)                            */
#define UART0_INST_INT_EN_ERDAI_Msk           (0x1UL)                   /*!< UART0_INST INT_EN: ERDAI (Bitfield-Mask: 0x01)              */
#define UART0_INST_INT_EN_ETHREI_Pos          (1UL)                     /*!< UART0_INST INT_EN: ETHREI (Bit 1)                           */
#define UART0_INST_INT_EN_ETHREI_Msk          (0x2UL)                   /*!< UART0_INST INT_EN: ETHREI (Bitfield-Mask: 0x01)             */
#define UART0_INST_INT_EN_ELSI_Pos            (2UL)                     /*!< UART0_INST INT_EN: ELSI (Bit 2)                             */
#define UART0_INST_INT_EN_ELSI_Msk            (0x4UL)                   /*!< UART0_INST INT_EN: ELSI (Bitfield-Mask: 0x01)               */
#define UART0_INST_INT_EN_EMSI_Pos            (3UL)                     /*!< UART0_INST INT_EN: EMSI (Bit 3)                             */
#define UART0_INST_INT_EN_EMSI_Msk            (0x8UL)                   /*!< UART0_INST INT_EN: EMSI (Bitfield-Mask: 0x01)               */

/* -----------------------------  UART0_INST_FIFO_CR  ----------------------------- */
#define UART0_INST_FIFO_CR_EXRF_Pos           (0UL)                     /*!< UART0_INST FIFO_CR: EXRF (Bit 0)                            */
#define UART0_INST_FIFO_CR_EXRF_Msk           (0x1UL)                   /*!< UART0_INST FIFO_CR: EXRF (Bitfield-Mask: 0x01)              */
#define UART0_INST_FIFO_CR_CLEAR_RECV_FIFO_Pos (1UL)                    /*!< UART0_INST FIFO_CR: CLEAR_RECV_FIFO (Bit 1)                 */
#define UART0_INST_FIFO_CR_CLEAR_RECV_FIFO_Msk (0x2UL)                  /*!< UART0_INST FIFO_CR: CLEAR_RECV_FIFO (Bitfield-Mask: 0x01)   */
#define UART0_INST_FIFO_CR_CLEAR_XMIT_FIFO_Pos (2UL)                    /*!< UART0_INST FIFO_CR: CLEAR_XMIT_FIFO (Bit 2)                 */
#define UART0_INST_FIFO_CR_CLEAR_XMIT_FIFO_Msk (0x4UL)                  /*!< UART0_INST FIFO_CR: CLEAR_XMIT_FIFO (Bitfield-Mask: 0x01)   */
#define UART0_INST_FIFO_CR_DMA_MODE_SELECT_Pos (3UL)                    /*!< UART0_INST FIFO_CR: DMA_MODE_SELECT (Bit 3)                 */
#define UART0_INST_FIFO_CR_DMA_MODE_SELECT_Msk (0x8UL)                  /*!< UART0_INST FIFO_CR: DMA_MODE_SELECT (Bitfield-Mask: 0x01)   */
#define UART0_INST_FIFO_CR_RECV_FIFO_TRIGGER_LEVEL_Pos (6UL)            /*!< UART0_INST FIFO_CR: RECV_FIFO_TRIGGER_LEVEL (Bit 6)         */
#define UART0_INST_FIFO_CR_RECV_FIFO_TRIGGER_LEVEL_Msk (0xc0UL)         /*!< UART0_INST FIFO_CR: RECV_FIFO_TRIGGER_LEVEL (Bitfield-Mask: 0x03) */

/* ------------------------------  UART0_INST_INT_ID  ----------------------------- */
#define UART0_INST_INT_ID_IPEND_Pos           (0UL)                     /*!< UART0_INST INT_ID: IPEND (Bit 0)                            */
#define UART0_INST_INT_ID_IPEND_Msk           (0x1UL)                   /*!< UART0_INST INT_ID: IPEND (Bitfield-Mask: 0x01)              */
#define UART0_INST_INT_ID_INTID_Pos           (1UL)                     /*!< UART0_INST INT_ID: INTID (Bit 1)                            */
#define UART0_INST_INT_ID_INTID_Msk           (0xeUL)                   /*!< UART0_INST INT_ID: INTID (Bitfield-Mask: 0x07)              */
#define UART0_INST_INT_ID_FIFO_EN_Pos         (6UL)                     /*!< UART0_INST INT_ID: FIFO_EN (Bit 6)                          */
#define UART0_INST_INT_ID_FIFO_EN_Msk         (0xc0UL)                  /*!< UART0_INST INT_ID: FIFO_EN (Bitfield-Mask: 0x03)            */

/* -----------------------------  UART0_INST_LINE_CR  ----------------------------- */
#define UART0_INST_LINE_CR_WORD_LENGTH_Pos    (0UL)                     /*!< UART0_INST LINE_CR: WORD_LENGTH (Bit 0)                     */
#define UART0_INST_LINE_CR_WORD_LENGTH_Msk    (0x3UL)                   /*!< UART0_INST LINE_CR: WORD_LENGTH (Bitfield-Mask: 0x03)       */
#define UART0_INST_LINE_CR_STOP_BITS_Pos      (2UL)                     /*!< UART0_INST LINE_CR: STOP_BITS (Bit 2)                       */
#define UART0_INST_LINE_CR_STOP_BITS_Msk      (0x4UL)                   /*!< UART0_INST LINE_CR: STOP_BITS (Bitfield-Mask: 0x01)         */
#define UART0_INST_LINE_CR_ENABLE_PARITY_Pos  (3UL)                     /*!< UART0_INST LINE_CR: ENABLE_PARITY (Bit 3)                   */
#define UART0_INST_LINE_CR_ENABLE_PARITY_Msk  (0x8UL)                   /*!< UART0_INST LINE_CR: ENABLE_PARITY (Bitfield-Mask: 0x01)     */
#define UART0_INST_LINE_CR_PARITY_SELECT_Pos  (4UL)                     /*!< UART0_INST LINE_CR: PARITY_SELECT (Bit 4)                   */
#define UART0_INST_LINE_CR_PARITY_SELECT_Msk  (0x10UL)                  /*!< UART0_INST LINE_CR: PARITY_SELECT (Bitfield-Mask: 0x01)     */
#define UART0_INST_LINE_CR_STICK_PARITY_Pos   (5UL)                     /*!< UART0_INST LINE_CR: STICK_PARITY (Bit 5)                    */
#define UART0_INST_LINE_CR_STICK_PARITY_Msk   (0x20UL)                  /*!< UART0_INST LINE_CR: STICK_PARITY (Bitfield-Mask: 0x01)      */
#define UART0_INST_LINE_CR_BREAK_CONTROL_Pos  (6UL)                     /*!< UART0_INST LINE_CR: BREAK_CONTROL (Bit 6)                   */
#define UART0_INST_LINE_CR_BREAK_CONTROL_Msk  (0x40UL)                  /*!< UART0_INST LINE_CR: BREAK_CONTROL (Bitfield-Mask: 0x01)     */
#define UART0_INST_LINE_CR_DLAB_Pos           (7UL)                     /*!< UART0_INST LINE_CR: DLAB (Bit 7)                            */
#define UART0_INST_LINE_CR_DLAB_Msk           (0x80UL)                  /*!< UART0_INST LINE_CR: DLAB (Bitfield-Mask: 0x01)              */

/* -----------------------------  UART0_INST_MODEM_CR  ---------------------------- */
#define UART0_INST_MODEM_CR_DTR_Pos           (0UL)                     /*!< UART0_INST MODEM_CR: DTR (Bit 0)                            */
#define UART0_INST_MODEM_CR_DTR_Msk           (0x1UL)                   /*!< UART0_INST MODEM_CR: DTR (Bitfield-Mask: 0x01)              */
#define UART0_INST_MODEM_CR_RTS_Pos           (1UL)                     /*!< UART0_INST MODEM_CR: RTS (Bit 1)                            */
#define UART0_INST_MODEM_CR_RTS_Msk           (0x2UL)                   /*!< UART0_INST MODEM_CR: RTS (Bitfield-Mask: 0x01)              */
#define UART0_INST_MODEM_CR_OUT1_Pos          (2UL)                     /*!< UART0_INST MODEM_CR: OUT1 (Bit 2)                           */
#define UART0_INST_MODEM_CR_OUT1_Msk          (0x4UL)                   /*!< UART0_INST MODEM_CR: OUT1 (Bitfield-Mask: 0x01)             */
#define UART0_INST_MODEM_CR_OUT2_Pos          (3UL)                     /*!< UART0_INST MODEM_CR: OUT2 (Bit 3)                           */
#define UART0_INST_MODEM_CR_OUT2_Msk          (0x8UL)                   /*!< UART0_INST MODEM_CR: OUT2 (Bitfield-Mask: 0x01)             */
#define UART0_INST_MODEM_CR_LOOPBACK_Pos      (4UL)                     /*!< UART0_INST MODEM_CR: LOOPBACK (Bit 4)                       */
#define UART0_INST_MODEM_CR_LOOPBACK_Msk      (0x10UL)                  /*!< UART0_INST MODEM_CR: LOOPBACK (Bitfield-Mask: 0x01)         */

/* -----------------------------  UART0_INST_LINE_STS  ---------------------------- */
#define UART0_INST_LINE_STS_DATA_READY_Pos    (0UL)                     /*!< UART0_INST LINE_STS: DATA_READY (Bit 0)                     */
#define UART0_INST_LINE_STS_DATA_READY_Msk    (0x1UL)                   /*!< UART0_INST LINE_STS: DATA_READY (Bitfield-Mask: 0x01)       */
#define UART0_INST_LINE_STS_OVERRUN_Pos       (1UL)                     /*!< UART0_INST LINE_STS: OVERRUN (Bit 1)                        */
#define UART0_INST_LINE_STS_OVERRUN_Msk       (0x2UL)                   /*!< UART0_INST LINE_STS: OVERRUN (Bitfield-Mask: 0x01)          */
#define UART0_INST_LINE_STS_PE_Pos            (2UL)                     /*!< UART0_INST LINE_STS: PE (Bit 2)                             */
#define UART0_INST_LINE_STS_PE_Msk            (0x4UL)                   /*!< UART0_INST LINE_STS: PE (Bitfield-Mask: 0x01)               */
#define UART0_INST_LINE_STS_FRAME_ERROR_Pos   (3UL)                     /*!< UART0_INST LINE_STS: FRAME_ERROR (Bit 3)                    */
#define UART0_INST_LINE_STS_FRAME_ERROR_Msk   (0x8UL)                   /*!< UART0_INST LINE_STS: FRAME_ERROR (Bitfield-Mask: 0x01)      */
#define UART0_INST_LINE_STS_BREAK_INTERRUPT_Pos (4UL)                   /*!< UART0_INST LINE_STS: BREAK_INTERRUPT (Bit 4)                */
#define UART0_INST_LINE_STS_BREAK_INTERRUPT_Msk (0x10UL)                /*!< UART0_INST LINE_STS: BREAK_INTERRUPT (Bitfield-Mask: 0x01)  */
#define UART0_INST_LINE_STS_TRANSMIT_EMPTY_Pos (5UL)                    /*!< UART0_INST LINE_STS: TRANSMIT_EMPTY (Bit 5)                 */
#define UART0_INST_LINE_STS_TRANSMIT_EMPTY_Msk (0x20UL)                 /*!< UART0_INST LINE_STS: TRANSMIT_EMPTY (Bitfield-Mask: 0x01)   */
#define UART0_INST_LINE_STS_TRANSMIT_ERROR_Pos (6UL)                    /*!< UART0_INST LINE_STS: TRANSMIT_ERROR (Bit 6)                 */
#define UART0_INST_LINE_STS_TRANSMIT_ERROR_Msk (0x40UL)                 /*!< UART0_INST LINE_STS: TRANSMIT_ERROR (Bitfield-Mask: 0x01)   */
#define UART0_INST_LINE_STS_FIFO_ERROR_Pos    (7UL)                     /*!< UART0_INST LINE_STS: FIFO_ERROR (Bit 7)                     */
#define UART0_INST_LINE_STS_FIFO_ERROR_Msk    (0x80UL)                  /*!< UART0_INST LINE_STS: FIFO_ERROR (Bitfield-Mask: 0x01)       */

/* ----------------------------  UART0_INST_MODEM_STS  ---------------------------- */
#define UART0_INST_MODEM_STS_CTS_Pos          (0UL)                     /*!< UART0_INST MODEM_STS: CTS (Bit 0)                           */
#define UART0_INST_MODEM_STS_CTS_Msk          (0x1UL)                   /*!< UART0_INST MODEM_STS: CTS (Bitfield-Mask: 0x01)             */
#define UART0_INST_MODEM_STS_DSR_Pos          (1UL)                     /*!< UART0_INST MODEM_STS: DSR (Bit 1)                           */
#define UART0_INST_MODEM_STS_DSR_Msk          (0x2UL)                   /*!< UART0_INST MODEM_STS: DSR (Bitfield-Mask: 0x01)             */
#define UART0_INST_MODEM_STS_RI_Pos           (2UL)                     /*!< UART0_INST MODEM_STS: RI (Bit 2)                            */
#define UART0_INST_MODEM_STS_RI_Msk           (0x4UL)                   /*!< UART0_INST MODEM_STS: RI (Bitfield-Mask: 0x01)              */
#define UART0_INST_MODEM_STS_DCD_Pos          (3UL)                     /*!< UART0_INST MODEM_STS: DCD (Bit 3)                           */
#define UART0_INST_MODEM_STS_DCD_Msk          (0x8UL)                   /*!< UART0_INST MODEM_STS: DCD (Bitfield-Mask: 0x01)             */
#define UART0_INST_MODEM_STS_nCTS_Pos         (4UL)                     /*!< UART0_INST MODEM_STS: nCTS (Bit 4)                          */
#define UART0_INST_MODEM_STS_nCTS_Msk         (0x10UL)                  /*!< UART0_INST MODEM_STS: nCTS (Bitfield-Mask: 0x01)            */
#define UART0_INST_MODEM_STS_nDSR_Pos         (5UL)                     /*!< UART0_INST MODEM_STS: nDSR (Bit 5)                          */
#define UART0_INST_MODEM_STS_nDSR_Msk         (0x20UL)                  /*!< UART0_INST MODEM_STS: nDSR (Bitfield-Mask: 0x01)            */
#define UART0_INST_MODEM_STS_nRI_Pos          (6UL)                     /*!< UART0_INST MODEM_STS: nRI (Bit 6)                           */
#define UART0_INST_MODEM_STS_nRI_Msk          (0x40UL)                  /*!< UART0_INST MODEM_STS: nRI (Bitfield-Mask: 0x01)             */
#define UART0_INST_MODEM_STS_nDCD_Pos         (7UL)                     /*!< UART0_INST MODEM_STS: nDCD (Bit 7)                          */
#define UART0_INST_MODEM_STS_nDCD_Msk         (0x80UL)                  /*!< UART0_INST MODEM_STS: nDCD (Bitfield-Mask: 0x01)            */

/* ------------------------------  UART0_INST_CONFIG  ----------------------------- */
#define UART0_INST_CONFIG_CLK_SRC_Pos         (0UL)                     /*!< UART0_INST CONFIG: CLK_SRC (Bit 0)                          */
#define UART0_INST_CONFIG_CLK_SRC_Msk         (0x1UL)                   /*!< UART0_INST CONFIG: CLK_SRC (Bitfield-Mask: 0x01)            */
#define UART0_INST_CONFIG_POWER_Pos           (1UL)                     /*!< UART0_INST CONFIG: POWER (Bit 1)                            */
#define UART0_INST_CONFIG_POWER_Msk           (0x2UL)                   /*!< UART0_INST CONFIG: POWER (Bitfield-Mask: 0x01)              */
#define UART0_INST_CONFIG_POLARITY_Pos        (2UL)                     /*!< UART0_INST CONFIG: POLARITY (Bit 2)                         */
#define UART0_INST_CONFIG_POLARITY_Msk        (0x4UL)                   /*!< UART0_INST CONFIG: POLARITY (Bitfield-Mask: 0x01)           */


/* ================================================================================ */
/* ================       struct 'UART1_INST' Position & Mask      ================ */
/* ================================================================================ */


/* ------------------------------  UART1_INST_INT_EN  ----------------------------- */
#define UART1_INST_INT_EN_ERDAI_Pos           (0UL)                     /*!< UART1_INST INT_EN: ERDAI (Bit 0)                            */
#define UART1_INST_INT_EN_ERDAI_Msk           (0x1UL)                   /*!< UART1_INST INT_EN: ERDAI (Bitfield-Mask: 0x01)              */
#define UART1_INST_INT_EN_ETHREI_Pos          (1UL)                     /*!< UART1_INST INT_EN: ETHREI (Bit 1)                           */
#define UART1_INST_INT_EN_ETHREI_Msk          (0x2UL)                   /*!< UART1_INST INT_EN: ETHREI (Bitfield-Mask: 0x01)             */
#define UART1_INST_INT_EN_ELSI_Pos            (2UL)                     /*!< UART1_INST INT_EN: ELSI (Bit 2)                             */
#define UART1_INST_INT_EN_ELSI_Msk            (0x4UL)                   /*!< UART1_INST INT_EN: ELSI (Bitfield-Mask: 0x01)               */
#define UART1_INST_INT_EN_EMSI_Pos            (3UL)                     /*!< UART1_INST INT_EN: EMSI (Bit 3)                             */
#define UART1_INST_INT_EN_EMSI_Msk            (0x8UL)                   /*!< UART1_INST INT_EN: EMSI (Bitfield-Mask: 0x01)               */

/* ------------------------------  UART1_INST_INT_ID  ----------------------------- */
#define UART1_INST_INT_ID_IPEND_Pos           (0UL)                     /*!< UART1_INST INT_ID: IPEND (Bit 0)                            */
#define UART1_INST_INT_ID_IPEND_Msk           (0x1UL)                   /*!< UART1_INST INT_ID: IPEND (Bitfield-Mask: 0x01)              */
#define UART1_INST_INT_ID_INTID_Pos           (1UL)                     /*!< UART1_INST INT_ID: INTID (Bit 1)                            */
#define UART1_INST_INT_ID_INTID_Msk           (0xeUL)                   /*!< UART1_INST INT_ID: INTID (Bitfield-Mask: 0x07)              */
#define UART1_INST_INT_ID_FIFO_EN_Pos         (6UL)                     /*!< UART1_INST INT_ID: FIFO_EN (Bit 6)                          */
#define UART1_INST_INT_ID_FIFO_EN_Msk         (0xc0UL)                  /*!< UART1_INST INT_ID: FIFO_EN (Bitfield-Mask: 0x03)            */

/* -----------------------------  UART1_INST_FIFO_CR  ----------------------------- */
#define UART1_INST_FIFO_CR_EXRF_Pos           (0UL)                     /*!< UART1_INST FIFO_CR: EXRF (Bit 0)                            */
#define UART1_INST_FIFO_CR_EXRF_Msk           (0x1UL)                   /*!< UART1_INST FIFO_CR: EXRF (Bitfield-Mask: 0x01)              */
#define UART1_INST_FIFO_CR_CLEAR_RECV_FIFO_Pos (1UL)                    /*!< UART1_INST FIFO_CR: CLEAR_RECV_FIFO (Bit 1)                 */
#define UART1_INST_FIFO_CR_CLEAR_RECV_FIFO_Msk (0x2UL)                  /*!< UART1_INST FIFO_CR: CLEAR_RECV_FIFO (Bitfield-Mask: 0x01)   */
#define UART1_INST_FIFO_CR_CLEAR_XMIT_FIFO_Pos (2UL)                    /*!< UART1_INST FIFO_CR: CLEAR_XMIT_FIFO (Bit 2)                 */
#define UART1_INST_FIFO_CR_CLEAR_XMIT_FIFO_Msk (0x4UL)                  /*!< UART1_INST FIFO_CR: CLEAR_XMIT_FIFO (Bitfield-Mask: 0x01)   */
#define UART1_INST_FIFO_CR_DMA_MODE_SELECT_Pos (3UL)                    /*!< UART1_INST FIFO_CR: DMA_MODE_SELECT (Bit 3)                 */
#define UART1_INST_FIFO_CR_DMA_MODE_SELECT_Msk (0x8UL)                  /*!< UART1_INST FIFO_CR: DMA_MODE_SELECT (Bitfield-Mask: 0x01)   */
#define UART1_INST_FIFO_CR_RECV_FIFO_TRIGGER_LEVEL_Pos (6UL)            /*!< UART1_INST FIFO_CR: RECV_FIFO_TRIGGER_LEVEL (Bit 6)         */
#define UART1_INST_FIFO_CR_RECV_FIFO_TRIGGER_LEVEL_Msk (0xc0UL)         /*!< UART1_INST FIFO_CR: RECV_FIFO_TRIGGER_LEVEL (Bitfield-Mask: 0x03) */

/* -----------------------------  UART1_INST_LINE_CR  ----------------------------- */
#define UART1_INST_LINE_CR_WORD_LENGTH_Pos    (0UL)                     /*!< UART1_INST LINE_CR: WORD_LENGTH (Bit 0)                     */
#define UART1_INST_LINE_CR_WORD_LENGTH_Msk    (0x3UL)                   /*!< UART1_INST LINE_CR: WORD_LENGTH (Bitfield-Mask: 0x03)       */
#define UART1_INST_LINE_CR_STOP_BITS_Pos      (2UL)                     /*!< UART1_INST LINE_CR: STOP_BITS (Bit 2)                       */
#define UART1_INST_LINE_CR_STOP_BITS_Msk      (0x4UL)                   /*!< UART1_INST LINE_CR: STOP_BITS (Bitfield-Mask: 0x01)         */
#define UART1_INST_LINE_CR_ENABLE_PARITY_Pos  (3UL)                     /*!< UART1_INST LINE_CR: ENABLE_PARITY (Bit 3)                   */
#define UART1_INST_LINE_CR_ENABLE_PARITY_Msk  (0x8UL)                   /*!< UART1_INST LINE_CR: ENABLE_PARITY (Bitfield-Mask: 0x01)     */
#define UART1_INST_LINE_CR_PARITY_SELECT_Pos  (4UL)                     /*!< UART1_INST LINE_CR: PARITY_SELECT (Bit 4)                   */
#define UART1_INST_LINE_CR_PARITY_SELECT_Msk  (0x10UL)                  /*!< UART1_INST LINE_CR: PARITY_SELECT (Bitfield-Mask: 0x01)     */
#define UART1_INST_LINE_CR_STICK_PARITY_Pos   (5UL)                     /*!< UART1_INST LINE_CR: STICK_PARITY (Bit 5)                    */
#define UART1_INST_LINE_CR_STICK_PARITY_Msk   (0x20UL)                  /*!< UART1_INST LINE_CR: STICK_PARITY (Bitfield-Mask: 0x01)      */
#define UART1_INST_LINE_CR_BREAK_CONTROL_Pos  (6UL)                     /*!< UART1_INST LINE_CR: BREAK_CONTROL (Bit 6)                   */
#define UART1_INST_LINE_CR_BREAK_CONTROL_Msk  (0x40UL)                  /*!< UART1_INST LINE_CR: BREAK_CONTROL (Bitfield-Mask: 0x01)     */
#define UART1_INST_LINE_CR_DLAB_Pos           (7UL)                     /*!< UART1_INST LINE_CR: DLAB (Bit 7)                            */
#define UART1_INST_LINE_CR_DLAB_Msk           (0x80UL)                  /*!< UART1_INST LINE_CR: DLAB (Bitfield-Mask: 0x01)              */

/* -----------------------------  UART1_INST_MODEM_CR  ---------------------------- */
#define UART1_INST_MODEM_CR_DTR_Pos           (0UL)                     /*!< UART1_INST MODEM_CR: DTR (Bit 0)                            */
#define UART1_INST_MODEM_CR_DTR_Msk           (0x1UL)                   /*!< UART1_INST MODEM_CR: DTR (Bitfield-Mask: 0x01)              */
#define UART1_INST_MODEM_CR_RTS_Pos           (1UL)                     /*!< UART1_INST MODEM_CR: RTS (Bit 1)                            */
#define UART1_INST_MODEM_CR_RTS_Msk           (0x2UL)                   /*!< UART1_INST MODEM_CR: RTS (Bitfield-Mask: 0x01)              */
#define UART1_INST_MODEM_CR_OUT1_Pos          (2UL)                     /*!< UART1_INST MODEM_CR: OUT1 (Bit 2)                           */
#define UART1_INST_MODEM_CR_OUT1_Msk          (0x4UL)                   /*!< UART1_INST MODEM_CR: OUT1 (Bitfield-Mask: 0x01)             */
#define UART1_INST_MODEM_CR_OUT2_Pos          (3UL)                     /*!< UART1_INST MODEM_CR: OUT2 (Bit 3)                           */
#define UART1_INST_MODEM_CR_OUT2_Msk          (0x8UL)                   /*!< UART1_INST MODEM_CR: OUT2 (Bitfield-Mask: 0x01)             */
#define UART1_INST_MODEM_CR_LOOPBACK_Pos      (4UL)                     /*!< UART1_INST MODEM_CR: LOOPBACK (Bit 4)                       */
#define UART1_INST_MODEM_CR_LOOPBACK_Msk      (0x10UL)                  /*!< UART1_INST MODEM_CR: LOOPBACK (Bitfield-Mask: 0x01)         */

/* -----------------------------  UART1_INST_LINE_STS  ---------------------------- */
#define UART1_INST_LINE_STS_DATA_READY_Pos    (0UL)                     /*!< UART1_INST LINE_STS: DATA_READY (Bit 0)                     */
#define UART1_INST_LINE_STS_DATA_READY_Msk    (0x1UL)                   /*!< UART1_INST LINE_STS: DATA_READY (Bitfield-Mask: 0x01)       */
#define UART1_INST_LINE_STS_OVERRUN_Pos       (1UL)                     /*!< UART1_INST LINE_STS: OVERRUN (Bit 1)                        */
#define UART1_INST_LINE_STS_OVERRUN_Msk       (0x2UL)                   /*!< UART1_INST LINE_STS: OVERRUN (Bitfield-Mask: 0x01)          */
#define UART1_INST_LINE_STS_PE_Pos            (2UL)                     /*!< UART1_INST LINE_STS: PE (Bit 2)                             */
#define UART1_INST_LINE_STS_PE_Msk            (0x4UL)                   /*!< UART1_INST LINE_STS: PE (Bitfield-Mask: 0x01)               */
#define UART1_INST_LINE_STS_FRAME_ERROR_Pos   (3UL)                     /*!< UART1_INST LINE_STS: FRAME_ERROR (Bit 3)                    */
#define UART1_INST_LINE_STS_FRAME_ERROR_Msk   (0x8UL)                   /*!< UART1_INST LINE_STS: FRAME_ERROR (Bitfield-Mask: 0x01)      */
#define UART1_INST_LINE_STS_BREAK_INTERRUPT_Pos (4UL)                   /*!< UART1_INST LINE_STS: BREAK_INTERRUPT (Bit 4)                */
#define UART1_INST_LINE_STS_BREAK_INTERRUPT_Msk (0x10UL)                /*!< UART1_INST LINE_STS: BREAK_INTERRUPT (Bitfield-Mask: 0x01)  */
#define UART1_INST_LINE_STS_TRANSMIT_EMPTY_Pos (5UL)                    /*!< UART1_INST LINE_STS: TRANSMIT_EMPTY (Bit 5)                 */
#define UART1_INST_LINE_STS_TRANSMIT_EMPTY_Msk (0x20UL)                 /*!< UART1_INST LINE_STS: TRANSMIT_EMPTY (Bitfield-Mask: 0x01)   */
#define UART1_INST_LINE_STS_TRANSMIT_ERROR_Pos (6UL)                    /*!< UART1_INST LINE_STS: TRANSMIT_ERROR (Bit 6)                 */
#define UART1_INST_LINE_STS_TRANSMIT_ERROR_Msk (0x40UL)                 /*!< UART1_INST LINE_STS: TRANSMIT_ERROR (Bitfield-Mask: 0x01)   */
#define UART1_INST_LINE_STS_FIFO_ERROR_Pos    (7UL)                     /*!< UART1_INST LINE_STS: FIFO_ERROR (Bit 7)                     */
#define UART1_INST_LINE_STS_FIFO_ERROR_Msk    (0x80UL)                  /*!< UART1_INST LINE_STS: FIFO_ERROR (Bitfield-Mask: 0x01)       */

/* ----------------------------  UART1_INST_MODEM_STS  ---------------------------- */
#define UART1_INST_MODEM_STS_CTS_Pos          (0UL)                     /*!< UART1_INST MODEM_STS: CTS (Bit 0)                           */
#define UART1_INST_MODEM_STS_CTS_Msk          (0x1UL)                   /*!< UART1_INST MODEM_STS: CTS (Bitfield-Mask: 0x01)             */
#define UART1_INST_MODEM_STS_DSR_Pos          (1UL)                     /*!< UART1_INST MODEM_STS: DSR (Bit 1)                           */
#define UART1_INST_MODEM_STS_DSR_Msk          (0x2UL)                   /*!< UART1_INST MODEM_STS: DSR (Bitfield-Mask: 0x01)             */
#define UART1_INST_MODEM_STS_RI_Pos           (2UL)                     /*!< UART1_INST MODEM_STS: RI (Bit 2)                            */
#define UART1_INST_MODEM_STS_RI_Msk           (0x4UL)                   /*!< UART1_INST MODEM_STS: RI (Bitfield-Mask: 0x01)              */
#define UART1_INST_MODEM_STS_DCD_Pos          (3UL)                     /*!< UART1_INST MODEM_STS: DCD (Bit 3)                           */
#define UART1_INST_MODEM_STS_DCD_Msk          (0x8UL)                   /*!< UART1_INST MODEM_STS: DCD (Bitfield-Mask: 0x01)             */
#define UART1_INST_MODEM_STS_nCTS_Pos         (4UL)                     /*!< UART1_INST MODEM_STS: nCTS (Bit 4)                          */
#define UART1_INST_MODEM_STS_nCTS_Msk         (0x10UL)                  /*!< UART1_INST MODEM_STS: nCTS (Bitfield-Mask: 0x01)            */
#define UART1_INST_MODEM_STS_nDSR_Pos         (5UL)                     /*!< UART1_INST MODEM_STS: nDSR (Bit 5)                          */
#define UART1_INST_MODEM_STS_nDSR_Msk         (0x20UL)                  /*!< UART1_INST MODEM_STS: nDSR (Bitfield-Mask: 0x01)            */
#define UART1_INST_MODEM_STS_nRI_Pos          (6UL)                     /*!< UART1_INST MODEM_STS: nRI (Bit 6)                           */
#define UART1_INST_MODEM_STS_nRI_Msk          (0x40UL)                  /*!< UART1_INST MODEM_STS: nRI (Bitfield-Mask: 0x01)             */
#define UART1_INST_MODEM_STS_nDCD_Pos         (7UL)                     /*!< UART1_INST MODEM_STS: nDCD (Bit 7)                          */
#define UART1_INST_MODEM_STS_nDCD_Msk         (0x80UL)                  /*!< UART1_INST MODEM_STS: nDCD (Bitfield-Mask: 0x01)            */

/* ------------------------------  UART1_INST_CONFIG  ----------------------------- */
#define UART1_INST_CONFIG_CLK_SRC_Pos         (0UL)                     /*!< UART1_INST CONFIG: CLK_SRC (Bit 0)                          */
#define UART1_INST_CONFIG_CLK_SRC_Msk         (0x1UL)                   /*!< UART1_INST CONFIG: CLK_SRC (Bitfield-Mask: 0x01)            */
#define UART1_INST_CONFIG_POWER_Pos           (1UL)                     /*!< UART1_INST CONFIG: POWER (Bit 1)                            */
#define UART1_INST_CONFIG_POWER_Msk           (0x2UL)                   /*!< UART1_INST CONFIG: POWER (Bitfield-Mask: 0x01)              */
#define UART1_INST_CONFIG_POLARITY_Pos        (2UL)                     /*!< UART1_INST CONFIG: POLARITY (Bit 2)                         */
#define UART1_INST_CONFIG_POLARITY_Msk        (0x4UL)                   /*!< UART1_INST CONFIG: POLARITY (Bitfield-Mask: 0x01)           */


/* ================================================================================ */
/* ================   struct 'GPIO_000_036_INST' Position & Mask   ================ */
/* ================================================================================ */


/* -------------------  GPIO_000_036_INST_GPIO_000_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_000_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_000_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_000_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_000_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_000_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_000_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_000_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_000_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_000_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_000_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_000_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_000_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_000_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_000_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_000_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_000_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_000_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_000_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_000_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_000_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_000_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_000_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_000_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_000_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_000_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_000_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_000_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_000_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_000_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_000_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_000_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_000_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_000_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_000_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_000_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_000_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_000_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_000_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_000_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_000_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_000_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_000_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_000_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_000_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_001_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_001_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_001_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_001_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_001_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_001_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_001_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_001_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_001_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_001_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_001_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_001_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_001_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_001_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_001_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_001_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_001_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_001_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_001_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_001_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_001_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_001_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_001_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_001_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_001_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_001_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_001_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_001_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_001_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_001_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_001_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_001_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_001_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_001_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_001_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_001_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_001_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_001_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_001_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_001_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_001_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_001_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_001_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_001_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_001_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_002_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_002_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_002_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_002_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_002_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_002_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_002_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_002_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_002_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_002_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_002_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_002_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_002_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_002_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_002_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_002_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_002_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_002_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_002_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_002_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_002_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_002_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_002_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_002_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_002_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_002_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_002_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_002_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_002_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_002_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_002_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_002_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_002_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_002_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_002_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_002_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_002_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_002_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_002_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_002_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_002_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_002_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_002_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_002_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_002_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_003_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_003_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_003_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_003_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_003_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_003_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_003_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_003_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_003_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_003_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_003_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_003_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_003_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_003_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_003_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_003_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_003_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_003_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_003_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_003_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_003_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_003_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_003_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_003_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_003_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_003_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_003_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_003_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_003_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_003_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_003_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_003_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_003_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_003_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_003_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_003_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_003_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_003_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_003_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_003_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_003_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_003_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_003_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_003_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_003_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_004_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_004_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_004_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_004_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_004_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_004_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_004_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_004_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_004_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_004_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_004_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_004_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_004_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_004_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_004_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_004_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_004_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_004_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_004_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_004_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_004_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_004_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_004_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_004_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_004_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_004_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_004_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_004_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_004_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_004_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_004_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_004_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_004_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_004_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_004_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_004_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_004_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_004_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_004_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_004_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_004_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_004_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_004_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_004_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_004_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_005_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_005_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_005_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_005_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_005_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_005_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_005_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_005_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_005_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_005_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_005_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_005_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_005_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_005_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_005_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_005_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_005_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_005_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_005_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_005_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_005_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_005_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_005_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_005_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_005_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_005_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_005_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_005_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_005_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_005_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_005_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_005_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_005_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_005_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_005_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_005_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_005_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_005_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_005_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_005_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_005_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_005_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_005_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_005_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_005_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_006_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_006_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_006_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_006_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_006_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_006_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_006_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_006_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_006_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_006_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_006_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_006_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_006_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_006_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_006_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_006_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_006_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_006_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_006_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_006_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_006_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_006_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_006_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_006_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_006_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_006_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_006_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_006_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_006_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_006_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_006_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_006_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_006_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_006_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_006_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_006_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_006_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_006_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_006_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_006_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_006_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_006_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_006_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_006_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_006_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_007_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_007_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_007_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_007_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_007_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_007_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_007_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_007_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_007_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_007_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_007_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_007_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_007_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_007_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_007_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_007_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_007_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_007_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_007_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_007_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_007_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_007_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_007_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_007_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_007_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_007_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_007_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_007_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_007_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_007_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_007_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_007_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_007_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_007_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_007_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_007_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_007_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_007_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_007_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_007_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_007_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_007_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_007_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_007_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_007_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_010_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_010_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_010_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_010_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_010_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_010_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_010_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_010_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_010_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_010_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_010_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_010_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_010_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_010_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_010_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_010_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_010_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_010_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_010_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_010_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_010_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_010_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_010_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_010_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_010_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_010_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_010_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_010_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_010_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_010_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_010_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_010_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_010_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_010_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_010_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_010_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_010_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_010_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_010_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_010_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_010_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_010_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_010_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_010_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_010_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_011_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_011_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_011_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_011_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_011_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_011_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_011_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_011_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_011_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_011_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_011_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_011_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_011_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_011_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_011_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_011_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_011_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_011_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_011_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_011_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_011_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_011_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_011_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_011_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_011_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_011_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_011_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_011_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_011_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_011_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_011_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_011_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_011_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_011_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_011_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_011_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_011_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_011_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_011_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_011_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_011_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_011_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_011_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_011_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_011_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_012_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_012_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_012_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_012_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_012_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_012_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_012_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_012_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_012_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_012_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_012_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_012_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_012_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_012_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_012_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_012_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_012_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_012_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_012_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_012_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_012_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_012_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_012_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_012_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_012_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_012_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_012_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_012_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_012_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_012_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_012_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_012_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_012_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_012_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_012_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_012_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_012_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_012_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_012_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_012_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_012_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_012_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_012_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_012_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_012_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_013_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_013_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_013_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_013_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_013_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_013_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_013_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_013_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_013_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_013_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_013_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_013_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_013_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_013_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_013_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_013_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_013_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_013_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_013_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_013_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_013_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_013_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_013_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_013_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_013_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_013_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_013_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_013_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_013_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_013_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_013_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_013_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_013_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_013_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_013_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_013_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_013_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_013_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_013_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_013_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_013_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_013_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_013_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_013_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_013_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_014_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_014_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_014_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_014_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_014_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_014_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_014_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_014_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_014_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_014_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_014_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_014_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_014_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_014_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_014_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_014_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_014_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_014_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_014_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_014_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_014_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_014_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_014_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_014_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_014_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_014_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_014_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_014_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_014_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_014_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_014_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_014_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_014_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_014_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_014_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_014_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_014_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_014_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_014_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_014_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_014_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_014_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_014_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_014_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_014_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_015_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_015_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_015_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_015_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_015_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_015_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_015_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_015_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_015_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_015_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_015_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_015_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_015_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_015_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_015_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_015_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_015_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_015_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_015_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_015_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_015_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_015_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_015_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_015_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_015_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_015_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_015_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_015_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_015_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_015_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_015_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_015_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_015_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_015_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_015_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_015_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_015_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_015_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_015_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_015_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_015_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_015_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_015_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_015_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_015_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_016_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_016_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_016_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_016_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_016_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_016_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_016_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_016_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_016_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_016_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_016_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_016_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_016_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_016_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_016_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_016_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_016_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_016_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_016_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_016_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_016_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_016_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_016_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_016_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_016_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_016_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_016_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_016_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_016_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_016_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_016_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_016_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_016_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_016_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_016_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_016_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_016_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_016_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_016_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_016_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_016_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_016_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_016_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_016_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_016_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_017_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_017_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_017_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_017_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_017_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_017_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_017_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_017_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_017_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_017_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_017_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_017_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_017_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_017_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_017_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_017_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_017_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_017_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_017_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_017_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_017_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_017_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_017_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_017_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_017_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_017_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_017_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_017_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_017_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_017_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_017_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_017_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_017_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_017_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_017_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_017_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_017_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_017_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_017_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_017_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_017_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_017_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_017_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_017_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_017_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_020_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_020_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_020_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_020_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_020_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_020_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_020_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_020_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_020_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_020_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_020_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_020_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_020_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_020_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_020_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_020_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_020_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_020_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_020_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_020_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_020_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_020_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_020_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_020_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_020_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_020_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_020_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_020_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_020_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_020_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_020_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_020_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_020_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_020_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_020_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_020_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_020_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_020_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_020_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_020_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_020_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_020_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_020_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_020_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_020_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_021_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_021_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_021_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_021_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_021_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_021_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_021_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_021_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_021_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_021_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_021_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_021_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_021_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_021_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_021_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_021_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_021_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_021_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_021_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_021_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_021_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_021_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_021_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_021_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_021_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_021_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_021_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_021_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_021_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_021_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_021_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_021_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_021_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_021_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_021_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_021_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_021_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_021_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_021_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_021_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_021_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_021_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_021_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_021_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_021_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_022_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_022_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_022_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_022_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_022_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_022_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_022_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_022_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_022_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_022_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_022_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_022_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_022_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_022_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_022_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_022_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_022_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_022_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_022_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_022_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_022_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_022_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_022_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_022_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_022_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_022_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_022_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_022_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_022_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_022_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_022_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_022_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_022_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_022_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_022_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_022_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_022_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_022_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_022_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_022_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_022_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_022_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_022_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_022_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_022_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_023_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_023_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_023_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_023_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_023_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_023_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_023_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_023_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_023_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_023_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_023_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_023_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_023_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_023_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_023_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_023_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_023_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_023_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_023_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_023_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_023_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_023_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_023_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_023_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_023_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_023_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_023_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_023_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_023_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_023_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_023_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_023_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_023_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_023_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_023_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_023_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_023_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_023_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_023_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_023_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_023_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_023_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_023_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_023_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_023_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_024_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_024_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_024_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_024_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_024_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_024_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_024_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_024_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_024_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_024_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_024_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_024_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_024_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_024_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_024_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_024_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_024_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_024_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_024_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_024_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_024_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_024_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_024_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_024_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_024_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_024_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_024_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_024_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_024_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_024_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_024_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_024_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_024_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_024_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_024_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_024_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_024_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_024_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_024_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_024_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_024_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_024_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_024_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_024_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_024_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_025_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_025_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_025_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_025_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_025_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_025_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_025_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_025_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_025_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_025_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_025_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_025_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_025_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_025_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_025_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_025_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_025_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_025_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_025_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_025_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_025_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_025_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_025_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_025_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_025_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_025_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_025_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_025_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_025_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_025_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_025_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_025_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_025_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_025_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_025_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_025_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_025_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_025_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_025_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_025_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_025_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_025_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_025_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_025_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_025_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_026_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_026_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_026_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_026_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_026_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_026_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_026_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_026_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_026_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_026_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_026_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_026_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_026_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_026_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_026_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_026_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_026_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_026_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_026_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_026_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_026_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_026_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_026_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_026_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_026_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_026_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_026_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_026_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_026_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_026_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_026_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_026_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_026_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_026_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_026_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_026_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_026_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_026_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_026_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_026_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_026_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_026_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_026_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_026_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_026_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_027_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_027_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_027_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_027_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_027_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_027_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_027_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_027_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_027_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_027_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_027_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_027_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_027_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_027_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_027_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_027_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_027_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_027_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_027_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_027_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_027_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_027_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_027_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_027_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_027_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_027_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_027_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_027_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_027_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_027_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_027_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_027_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_027_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_027_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_027_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_027_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_027_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_027_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_027_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_027_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_027_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_027_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_027_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_027_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_027_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_030_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_030_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_030_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_030_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_030_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_030_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_030_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_030_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_030_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_030_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_030_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_030_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_030_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_030_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_030_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_030_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_030_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_030_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_030_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_030_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_030_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_030_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_030_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_030_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_030_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_030_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_030_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_030_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_030_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_030_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_030_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_030_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_030_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_030_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_030_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_030_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_030_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_030_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_030_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_030_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_030_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_030_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_030_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_030_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_030_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_031_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_031_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_031_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_031_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_031_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_031_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_031_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_031_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_031_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_031_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_031_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_031_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_031_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_031_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_031_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_031_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_031_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_031_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_031_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_031_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_031_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_031_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_031_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_031_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_031_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_031_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_031_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_031_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_031_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_031_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_031_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_031_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_031_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_031_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_031_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_031_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_031_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_031_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_031_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_031_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_031_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_031_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_031_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_031_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_031_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_032_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_032_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_032_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_032_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_032_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_032_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_032_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_032_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_032_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_032_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_032_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_032_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_032_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_032_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_032_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_032_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_032_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_032_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_032_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_032_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_032_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_032_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_032_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_032_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_032_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_032_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_032_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_032_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_032_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_032_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_032_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_032_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_032_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_032_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_032_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_032_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_032_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_032_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_032_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_032_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_032_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_032_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_032_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_032_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_032_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_033_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_033_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_033_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_033_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_033_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_033_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_033_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_033_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_033_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_033_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_033_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_033_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_033_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_033_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_033_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_033_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_033_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_033_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_033_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_033_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_033_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_033_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_033_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_033_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_033_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_033_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_033_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_033_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_033_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_033_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_033_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_033_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_033_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_033_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_033_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_033_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_033_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_033_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_033_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_033_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_033_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_033_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_033_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_033_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_033_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_034_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_034_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_034_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_034_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_034_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_034_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_034_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_034_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_034_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_034_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_034_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_034_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_034_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_034_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_034_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_034_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_034_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_034_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_034_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_034_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_034_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_034_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_034_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_034_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_034_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_034_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_034_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_034_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_034_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_034_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_034_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_034_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_034_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_034_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_034_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_034_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_034_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_034_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_034_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_034_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_034_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_034_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_034_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_034_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_034_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_035_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_035_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_035_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_035_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_035_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_035_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_035_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_035_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_035_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_035_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_035_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_035_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_035_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_035_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_035_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_035_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_035_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_035_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_035_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_035_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_035_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_035_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_035_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_035_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_035_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_035_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_035_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_035_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_035_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_035_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_035_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_035_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_035_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_035_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_035_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_035_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_035_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_035_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_035_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_035_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_035_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_035_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_035_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_035_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_035_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_000_036_INST_GPIO_036_PIN_CONTROL  ------------------- */
#define GPIO_000_036_INST_GPIO_036_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_000_036_INST GPIO_036_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_000_036_INST_GPIO_036_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_000_036_INST GPIO_036_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_036_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_000_036_INST GPIO_036_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_000_036_INST_GPIO_036_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_000_036_INST GPIO_036_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_036_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_000_036_INST GPIO_036_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_000_036_INST_GPIO_036_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_000_036_INST GPIO_036_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_000_036_INST_GPIO_036_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_000_036_INST GPIO_036_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_000_036_INST_GPIO_036_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_000_036_INST GPIO_036_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_036_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_000_036_INST GPIO_036_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_000_036_INST_GPIO_036_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_000_036_INST GPIO_036_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_036_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_000_036_INST GPIO_036_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_000_036_INST_GPIO_036_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_000_036_INST GPIO_036_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_036_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_000_036_INST GPIO_036_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_000_036_INST_GPIO_036_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_000_036_INST GPIO_036_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_036_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_000_036_INST GPIO_036_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_000_036_INST_GPIO_036_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_000_036_INST GPIO_036_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_036_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_000_036_INST GPIO_036_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_000_036_INST_GPIO_036_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_000_036_INST GPIO_036_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_000_036_INST_GPIO_036_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_000_036_INST GPIO_036_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_000_036_INST_GPIO_036_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_000_036_INST GPIO_036_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_000_036_INST_GPIO_036_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_000_036_INST GPIO_036_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_000_036_INST_GPIO_036_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_000_036_INST GPIO_036_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */


/* ================================================================================ */
/* ================   struct 'GPIO_040_076_INST' Position & Mask   ================ */
/* ================================================================================ */


/* -------------------  GPIO_040_076_INST_GPIO_040_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_040_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_040_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_040_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_040_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_040_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_040_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_040_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_040_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_040_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_040_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_040_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_040_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_040_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_040_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_040_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_040_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_040_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_040_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_040_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_040_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_040_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_040_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_040_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_040_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_040_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_040_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_040_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_040_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_040_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_040_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_040_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_040_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_040_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_040_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_040_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_040_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_040_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_040_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_040_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_040_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_040_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_040_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_040_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_040_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_041_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_041_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_041_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_041_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_041_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_041_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_041_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_041_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_041_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_041_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_041_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_041_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_041_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_041_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_041_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_041_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_041_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_041_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_041_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_041_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_041_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_041_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_041_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_041_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_041_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_041_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_041_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_041_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_041_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_041_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_041_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_041_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_041_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_041_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_041_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_041_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_041_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_041_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_041_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_041_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_041_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_041_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_041_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_041_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_041_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_042_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_042_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_042_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_042_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_042_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_042_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_042_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_042_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_042_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_042_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_042_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_042_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_042_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_042_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_042_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_042_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_042_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_042_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_042_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_042_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_042_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_042_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_042_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_042_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_042_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_042_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_042_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_042_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_042_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_042_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_042_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_042_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_042_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_042_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_042_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_042_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_042_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_042_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_042_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_042_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_042_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_042_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_042_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_042_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_042_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_043_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_043_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_043_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_043_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_043_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_043_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_043_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_043_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_043_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_043_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_043_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_043_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_043_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_043_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_043_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_043_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_043_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_043_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_043_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_043_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_043_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_043_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_043_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_043_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_043_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_043_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_043_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_043_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_043_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_043_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_043_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_043_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_043_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_043_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_043_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_043_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_043_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_043_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_043_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_043_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_043_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_043_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_043_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_043_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_043_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_044_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_044_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_044_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_044_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_044_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_044_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_044_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_044_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_044_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_044_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_044_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_044_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_044_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_044_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_044_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_044_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_044_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_044_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_044_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_044_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_044_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_044_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_044_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_044_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_044_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_044_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_044_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_044_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_044_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_044_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_044_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_044_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_044_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_044_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_044_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_044_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_044_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_044_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_044_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_044_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_044_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_044_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_044_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_044_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_044_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_045_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_045_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_045_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_045_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_045_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_045_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_045_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_045_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_045_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_045_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_045_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_045_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_045_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_045_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_045_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_045_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_045_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_045_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_045_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_045_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_045_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_045_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_045_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_045_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_045_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_045_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_045_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_045_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_045_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_045_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_045_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_045_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_045_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_045_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_045_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_045_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_045_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_045_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_045_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_045_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_045_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_045_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_045_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_045_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_045_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_046_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_046_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_046_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_046_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_046_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_046_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_046_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_046_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_046_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_046_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_046_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_046_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_046_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_046_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_046_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_046_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_046_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_046_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_046_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_046_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_046_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_046_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_046_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_046_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_046_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_046_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_046_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_046_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_046_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_046_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_046_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_046_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_046_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_046_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_046_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_046_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_046_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_046_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_046_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_046_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_046_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_046_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_046_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_046_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_046_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_047_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_047_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_047_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_047_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_047_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_047_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_047_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_047_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_047_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_047_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_047_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_047_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_047_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_047_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_047_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_047_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_047_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_047_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_047_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_047_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_047_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_047_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_047_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_047_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_047_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_047_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_047_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_047_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_047_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_047_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_047_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_047_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_047_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_047_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_047_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_047_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_047_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_047_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_047_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_047_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_047_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_047_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_047_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_047_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_047_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_050_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_050_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_050_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_050_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_050_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_050_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_050_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_050_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_050_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_050_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_050_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_050_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_050_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_050_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_050_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_050_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_050_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_050_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_050_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_050_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_050_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_050_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_050_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_050_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_050_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_050_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_050_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_050_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_050_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_050_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_050_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_050_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_050_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_050_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_050_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_050_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_050_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_050_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_050_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_050_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_050_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_050_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_050_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_050_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_050_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_051_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_051_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_051_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_051_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_051_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_051_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_051_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_051_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_051_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_051_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_051_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_051_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_051_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_051_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_051_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_051_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_051_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_051_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_051_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_051_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_051_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_051_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_051_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_051_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_051_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_051_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_051_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_051_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_051_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_051_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_051_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_051_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_051_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_051_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_051_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_051_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_051_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_051_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_051_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_051_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_051_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_051_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_051_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_051_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_051_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_052_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_052_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_052_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_052_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_052_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_052_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_052_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_052_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_052_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_052_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_052_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_052_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_052_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_052_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_052_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_052_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_052_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_052_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_052_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_052_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_052_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_052_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_052_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_052_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_052_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_052_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_052_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_052_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_052_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_052_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_052_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_052_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_052_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_052_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_052_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_052_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_052_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_052_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_052_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_052_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_052_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_052_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_052_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_052_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_052_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_053_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_053_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_053_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_053_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_053_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_053_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_053_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_053_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_053_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_053_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_053_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_053_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_053_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_053_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_053_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_053_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_053_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_053_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_053_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_053_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_053_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_053_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_053_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_053_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_053_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_053_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_053_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_053_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_053_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_053_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_053_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_053_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_053_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_053_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_053_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_053_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_053_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_053_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_053_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_053_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_053_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_053_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_053_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_053_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_053_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_054_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_054_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_054_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_054_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_054_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_054_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_054_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_054_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_054_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_054_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_054_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_054_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_054_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_054_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_054_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_054_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_054_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_054_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_054_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_054_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_054_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_054_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_054_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_054_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_054_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_054_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_054_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_054_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_054_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_054_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_054_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_054_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_054_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_054_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_054_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_054_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_054_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_054_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_054_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_054_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_054_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_054_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_054_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_054_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_054_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_055_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_055_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_055_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_055_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_055_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_055_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_055_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_055_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_055_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_055_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_055_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_055_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_055_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_055_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_055_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_055_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_055_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_055_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_055_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_055_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_055_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_055_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_055_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_055_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_055_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_055_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_055_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_055_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_055_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_055_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_055_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_055_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_055_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_055_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_055_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_055_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_055_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_055_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_055_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_055_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_055_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_055_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_055_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_055_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_055_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_056_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_056_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_056_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_056_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_056_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_056_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_056_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_056_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_056_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_056_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_056_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_056_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_056_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_056_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_056_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_056_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_056_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_056_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_056_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_056_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_056_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_056_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_056_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_056_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_056_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_056_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_056_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_056_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_056_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_056_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_056_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_056_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_056_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_056_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_056_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_056_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_056_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_056_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_056_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_056_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_056_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_056_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_056_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_056_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_056_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_057_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_057_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_057_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_057_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_057_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_057_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_057_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_057_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_057_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_057_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_057_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_057_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_057_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_057_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_057_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_057_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_057_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_057_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_057_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_057_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_057_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_057_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_057_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_057_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_057_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_057_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_057_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_057_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_057_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_057_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_057_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_057_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_057_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_057_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_057_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_057_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_057_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_057_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_057_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_057_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_057_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_057_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_057_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_057_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_057_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_060_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_060_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_060_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_060_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_060_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_060_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_060_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_060_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_060_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_060_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_060_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_060_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_060_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_060_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_060_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_060_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_060_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_060_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_060_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_060_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_060_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_060_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_060_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_060_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_060_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_060_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_060_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_060_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_060_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_060_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_060_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_060_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_060_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_060_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_060_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_060_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_060_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_060_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_060_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_060_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_060_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_060_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_060_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_060_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_060_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_061_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_061_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_061_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_061_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_061_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_061_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_061_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_061_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_061_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_061_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_061_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_061_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_061_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_061_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_061_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_061_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_061_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_061_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_061_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_061_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_061_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_061_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_061_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_061_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_061_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_061_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_061_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_061_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_061_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_061_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_061_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_061_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_061_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_061_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_061_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_061_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_061_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_061_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_061_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_061_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_061_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_061_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_061_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_061_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_061_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_062_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_062_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_062_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_062_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_062_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_062_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_062_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_062_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_062_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_062_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_062_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_062_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_062_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_062_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_062_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_062_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_062_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_062_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_062_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_062_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_062_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_062_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_062_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_062_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_062_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_062_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_062_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_062_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_062_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_062_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_062_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_062_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_062_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_062_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_062_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_062_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_062_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_062_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_062_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_062_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_062_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_062_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_062_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_062_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_062_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_063_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_063_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_063_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_063_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_063_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_063_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_063_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_063_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_063_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_063_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_063_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_063_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_063_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_063_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_063_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_063_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_063_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_063_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_063_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_063_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_063_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_063_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_063_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_063_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_063_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_063_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_063_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_063_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_063_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_063_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_063_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_063_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_063_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_063_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_063_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_063_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_063_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_063_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_063_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_063_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_063_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_063_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_063_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_063_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_063_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_064_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_064_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_064_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_064_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_064_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_064_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_064_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_064_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_064_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_064_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_064_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_064_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_064_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_064_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_064_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_064_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_064_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_064_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_064_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_064_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_064_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_064_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_064_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_064_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_064_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_064_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_064_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_064_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_064_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_064_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_064_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_064_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_064_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_064_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_064_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_064_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_064_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_064_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_064_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_064_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_064_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_064_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_064_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_064_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_064_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_065_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_065_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_065_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_065_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_065_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_065_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_065_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_065_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_065_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_065_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_065_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_065_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_065_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_065_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_065_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_065_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_065_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_065_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_065_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_065_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_065_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_065_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_065_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_065_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_065_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_065_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_065_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_065_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_065_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_065_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_065_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_065_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_065_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_065_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_065_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_065_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_065_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_065_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_065_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_065_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_065_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_065_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_065_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_065_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_065_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_066_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_066_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_066_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_066_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_066_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_066_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_066_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_066_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_066_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_066_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_066_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_066_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_066_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_066_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_066_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_066_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_066_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_066_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_066_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_066_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_066_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_066_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_066_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_066_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_066_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_066_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_066_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_066_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_066_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_066_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_066_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_066_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_066_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_066_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_066_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_066_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_066_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_066_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_066_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_066_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_066_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_066_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_066_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_066_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_066_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_067_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_067_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_067_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_067_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_067_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_067_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_067_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_067_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_067_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_067_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_067_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_067_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_067_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_067_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_067_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_067_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_067_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_067_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_067_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_067_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_067_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_067_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_067_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_067_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_067_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_067_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_067_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_067_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_067_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_067_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_067_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_067_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_067_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_067_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_067_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_067_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_067_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_067_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_067_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_067_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_067_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_067_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_067_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_067_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_067_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_070_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_070_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_070_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_070_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_070_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_070_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_070_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_070_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_070_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_070_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_070_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_070_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_070_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_070_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_070_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_070_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_070_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_070_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_070_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_070_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_070_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_070_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_070_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_070_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_070_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_070_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_070_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_070_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_070_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_070_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_070_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_070_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_070_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_070_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_070_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_070_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_070_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_070_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_070_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_070_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_070_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_070_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_070_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_070_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_070_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_071_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_071_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_071_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_071_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_071_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_071_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_071_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_071_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_071_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_071_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_071_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_071_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_071_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_071_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_071_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_071_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_071_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_071_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_071_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_071_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_071_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_071_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_071_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_071_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_071_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_071_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_071_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_071_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_071_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_071_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_071_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_071_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_071_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_071_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_071_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_071_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_071_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_071_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_071_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_071_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_071_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_071_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_071_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_071_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_071_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_072_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_072_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_072_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_072_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_072_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_072_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_072_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_072_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_072_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_072_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_072_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_072_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_072_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_072_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_072_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_072_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_072_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_072_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_072_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_072_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_072_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_072_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_072_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_072_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_072_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_072_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_072_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_072_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_072_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_072_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_072_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_072_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_072_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_072_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_072_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_072_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_072_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_072_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_072_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_072_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_072_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_072_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_072_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_072_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_072_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_073_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_073_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_073_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_073_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_073_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_073_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_073_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_073_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_073_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_073_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_073_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_073_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_073_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_073_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_073_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_073_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_073_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_073_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_073_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_073_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_073_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_073_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_073_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_073_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_073_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_073_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_073_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_073_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_073_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_073_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_073_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_073_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_073_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_073_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_073_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_073_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_073_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_073_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_073_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_073_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_073_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_073_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_073_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_073_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_073_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_074_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_074_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_074_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_074_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_074_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_074_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_074_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_074_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_074_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_074_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_074_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_074_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_074_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_074_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_074_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_074_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_074_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_074_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_074_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_074_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_074_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_074_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_074_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_074_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_074_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_074_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_074_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_074_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_074_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_074_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_074_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_074_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_074_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_074_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_074_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_074_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_074_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_074_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_074_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_074_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_074_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_074_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_074_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_074_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_074_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_075_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_075_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_075_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_075_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_075_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_075_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_075_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_075_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_075_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_075_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_075_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_075_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_075_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_075_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_075_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_075_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_075_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_075_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_075_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_075_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_075_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_075_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_075_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_075_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_075_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_075_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_075_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_075_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_075_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_075_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_075_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_075_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_075_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_075_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_075_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_075_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_075_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_075_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_075_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_075_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_075_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_075_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_075_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_075_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_075_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_040_076_INST_GPIO_076_PIN_CONTROL  ------------------- */
#define GPIO_040_076_INST_GPIO_076_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_040_076_INST GPIO_076_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_040_076_INST_GPIO_076_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_040_076_INST GPIO_076_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_076_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_040_076_INST GPIO_076_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_040_076_INST_GPIO_076_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_040_076_INST GPIO_076_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_076_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_040_076_INST GPIO_076_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_040_076_INST_GPIO_076_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_040_076_INST GPIO_076_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_040_076_INST_GPIO_076_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_040_076_INST GPIO_076_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_040_076_INST_GPIO_076_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_040_076_INST GPIO_076_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_076_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_040_076_INST GPIO_076_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_040_076_INST_GPIO_076_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_040_076_INST GPIO_076_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_076_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_040_076_INST GPIO_076_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_040_076_INST_GPIO_076_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_040_076_INST GPIO_076_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_076_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_040_076_INST GPIO_076_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_040_076_INST_GPIO_076_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_040_076_INST GPIO_076_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_076_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_040_076_INST GPIO_076_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_040_076_INST_GPIO_076_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_040_076_INST GPIO_076_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_076_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_040_076_INST GPIO_076_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_040_076_INST_GPIO_076_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_040_076_INST GPIO_076_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_040_076_INST_GPIO_076_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_040_076_INST GPIO_076_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_040_076_INST_GPIO_076_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_040_076_INST GPIO_076_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_040_076_INST_GPIO_076_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_040_076_INST GPIO_076_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_040_076_INST_GPIO_076_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_040_076_INST GPIO_076_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */


/* ================================================================================ */
/* ================   struct 'GPIO_100_137_INST' Position & Mask   ================ */
/* ================================================================================ */


/* -------------------  GPIO_100_137_INST_GPIO_100_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_100_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_100_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_100_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_100_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_100_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_100_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_100_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_100_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_100_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_100_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_100_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_100_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_100_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_100_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_100_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_100_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_100_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_100_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_100_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_100_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_100_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_100_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_100_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_100_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_100_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_100_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_100_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_100_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_100_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_100_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_100_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_100_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_100_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_100_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_100_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_100_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_100_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_100_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_100_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_100_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_100_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_100_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_100_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_100_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_101_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_101_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_101_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_101_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_101_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_101_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_101_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_101_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_101_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_101_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_101_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_101_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_101_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_101_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_101_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_101_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_101_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_101_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_101_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_101_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_101_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_101_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_101_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_101_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_101_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_101_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_101_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_101_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_101_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_101_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_101_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_101_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_101_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_101_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_101_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_101_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_101_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_101_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_101_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_101_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_101_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_101_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_101_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_101_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_101_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_102_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_102_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_102_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_102_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_102_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_102_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_102_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_102_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_102_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_102_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_102_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_102_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_102_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_102_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_102_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_102_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_102_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_102_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_102_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_102_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_102_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_102_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_102_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_102_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_102_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_102_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_102_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_102_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_102_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_102_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_102_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_102_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_102_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_102_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_102_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_102_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_102_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_102_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_102_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_102_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_102_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_102_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_102_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_102_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_102_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_103_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_103_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_103_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_103_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_103_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_103_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_103_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_103_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_103_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_103_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_103_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_103_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_103_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_103_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_103_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_103_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_103_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_103_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_103_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_103_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_103_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_103_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_103_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_103_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_103_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_103_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_103_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_103_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_103_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_103_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_103_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_103_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_103_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_103_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_103_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_103_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_103_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_103_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_103_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_103_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_103_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_103_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_103_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_103_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_103_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_104_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_104_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_104_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_104_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_104_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_104_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_104_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_104_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_104_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_104_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_104_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_104_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_104_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_104_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_104_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_104_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_104_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_104_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_104_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_104_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_104_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_104_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_104_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_104_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_104_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_104_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_104_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_104_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_104_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_104_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_104_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_104_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_104_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_104_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_104_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_104_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_104_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_104_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_104_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_104_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_104_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_104_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_104_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_104_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_104_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_105_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_105_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_105_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_105_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_105_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_105_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_105_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_105_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_105_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_105_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_105_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_105_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_105_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_105_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_105_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_105_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_105_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_105_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_105_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_105_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_105_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_105_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_105_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_105_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_105_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_105_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_105_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_105_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_105_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_105_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_105_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_105_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_105_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_105_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_105_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_105_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_105_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_105_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_105_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_105_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_105_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_105_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_105_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_105_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_105_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_106_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_106_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_106_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_106_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_106_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_106_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_106_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_106_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_106_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_106_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_106_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_106_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_106_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_106_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_106_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_106_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_106_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_106_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_106_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_106_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_106_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_106_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_106_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_106_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_106_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_106_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_106_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_106_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_106_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_106_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_106_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_106_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_106_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_106_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_106_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_106_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_106_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_106_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_106_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_106_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_106_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_106_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_106_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_106_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_106_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_107_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_107_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_107_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_107_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_107_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_107_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_107_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_107_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_107_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_107_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_107_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_107_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_107_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_107_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_107_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_107_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_107_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_107_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_107_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_107_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_107_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_107_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_107_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_107_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_107_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_107_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_107_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_107_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_107_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_107_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_107_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_107_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_107_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_107_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_107_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_107_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_107_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_107_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_107_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_107_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_107_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_107_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_107_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_107_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_107_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_110_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_110_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_110_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_110_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_110_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_110_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_110_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_110_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_110_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_110_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_110_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_110_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_110_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_110_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_110_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_110_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_110_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_110_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_110_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_110_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_110_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_110_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_110_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_110_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_110_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_110_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_110_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_110_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_110_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_110_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_110_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_110_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_110_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_110_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_110_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_110_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_110_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_110_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_110_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_110_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_110_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_110_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_110_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_110_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_110_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_111_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_111_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_111_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_111_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_111_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_111_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_111_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_111_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_111_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_111_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_111_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_111_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_111_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_111_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_111_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_111_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_111_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_111_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_111_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_111_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_111_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_111_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_111_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_111_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_111_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_111_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_111_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_111_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_111_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_111_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_111_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_111_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_111_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_111_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_111_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_111_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_111_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_111_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_111_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_111_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_111_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_111_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_111_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_111_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_111_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_112_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_112_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_112_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_112_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_112_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_112_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_112_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_112_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_112_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_112_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_112_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_112_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_112_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_112_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_112_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_112_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_112_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_112_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_112_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_112_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_112_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_112_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_112_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_112_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_112_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_112_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_112_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_112_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_112_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_112_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_112_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_112_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_112_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_112_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_112_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_112_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_112_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_112_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_112_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_112_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_112_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_112_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_112_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_112_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_112_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_113_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_113_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_113_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_113_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_113_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_113_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_113_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_113_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_113_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_113_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_113_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_113_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_113_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_113_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_113_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_113_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_113_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_113_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_113_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_113_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_113_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_113_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_113_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_113_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_113_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_113_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_113_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_113_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_113_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_113_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_113_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_113_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_113_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_113_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_113_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_113_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_113_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_113_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_113_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_113_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_113_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_113_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_113_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_113_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_113_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_114_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_114_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_114_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_114_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_114_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_114_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_114_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_114_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_114_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_114_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_114_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_114_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_114_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_114_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_114_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_114_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_114_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_114_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_114_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_114_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_114_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_114_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_114_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_114_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_114_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_114_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_114_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_114_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_114_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_114_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_114_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_114_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_114_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_114_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_114_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_114_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_114_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_114_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_114_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_114_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_114_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_114_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_114_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_114_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_114_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_115_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_115_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_115_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_115_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_115_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_115_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_115_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_115_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_115_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_115_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_115_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_115_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_115_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_115_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_115_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_115_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_115_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_115_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_115_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_115_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_115_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_115_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_115_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_115_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_115_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_115_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_115_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_115_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_115_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_115_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_115_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_115_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_115_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_115_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_115_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_115_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_115_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_115_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_115_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_115_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_115_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_115_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_115_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_115_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_115_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_116_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_116_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_116_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_116_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_116_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_116_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_116_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_116_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_116_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_116_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_116_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_116_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_116_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_116_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_116_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_116_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_116_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_116_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_116_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_116_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_116_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_116_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_116_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_116_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_116_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_116_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_116_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_116_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_116_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_116_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_116_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_116_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_116_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_116_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_116_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_116_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_116_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_116_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_116_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_116_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_116_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_116_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_116_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_116_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_116_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_117_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_117_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_117_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_117_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_117_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_117_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_117_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_117_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_117_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_117_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_117_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_117_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_117_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_117_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_117_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_117_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_117_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_117_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_117_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_117_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_117_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_117_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_117_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_117_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_117_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_117_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_117_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_117_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_117_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_117_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_117_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_117_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_117_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_117_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_117_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_117_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_117_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_117_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_117_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_117_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_117_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_117_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_117_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_117_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_117_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_120_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_120_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_120_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_120_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_120_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_120_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_120_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_120_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_120_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_120_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_120_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_120_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_120_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_120_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_120_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_120_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_120_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_120_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_120_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_120_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_120_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_120_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_120_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_120_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_120_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_120_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_120_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_120_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_120_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_120_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_120_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_120_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_120_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_120_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_120_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_120_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_120_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_120_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_120_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_120_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_120_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_120_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_120_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_120_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_120_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_121_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_121_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_121_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_121_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_121_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_121_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_121_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_121_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_121_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_121_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_121_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_121_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_121_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_121_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_121_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_121_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_121_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_121_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_121_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_121_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_121_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_121_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_121_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_121_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_121_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_121_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_121_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_121_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_121_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_121_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_121_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_121_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_121_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_121_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_121_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_121_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_121_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_121_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_121_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_121_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_121_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_121_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_121_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_121_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_121_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_122_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_122_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_122_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_122_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_122_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_122_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_122_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_122_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_122_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_122_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_122_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_122_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_122_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_122_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_122_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_122_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_122_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_122_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_122_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_122_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_122_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_122_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_122_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_122_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_122_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_122_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_122_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_122_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_122_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_122_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_122_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_122_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_122_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_122_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_122_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_122_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_122_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_122_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_122_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_122_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_122_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_122_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_122_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_122_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_122_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_123_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_123_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_123_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_123_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_123_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_123_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_123_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_123_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_123_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_123_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_123_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_123_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_123_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_123_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_123_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_123_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_123_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_123_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_123_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_123_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_123_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_123_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_123_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_123_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_123_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_123_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_123_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_123_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_123_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_123_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_123_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_123_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_123_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_123_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_123_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_123_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_123_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_123_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_123_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_123_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_123_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_123_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_123_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_123_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_123_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_124_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_124_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_124_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_124_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_124_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_124_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_124_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_124_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_124_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_124_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_124_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_124_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_124_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_124_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_124_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_124_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_124_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_124_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_124_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_124_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_124_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_124_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_124_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_124_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_124_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_124_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_124_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_124_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_124_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_124_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_124_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_124_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_124_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_124_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_124_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_124_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_124_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_124_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_124_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_124_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_124_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_124_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_124_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_124_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_124_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_125_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_125_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_125_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_125_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_125_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_125_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_125_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_125_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_125_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_125_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_125_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_125_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_125_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_125_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_125_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_125_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_125_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_125_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_125_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_125_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_125_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_125_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_125_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_125_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_125_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_125_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_125_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_125_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_125_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_125_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_125_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_125_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_125_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_125_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_125_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_125_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_125_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_125_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_125_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_125_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_125_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_125_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_125_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_125_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_125_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_126_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_126_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_126_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_126_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_126_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_126_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_126_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_126_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_126_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_126_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_126_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_126_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_126_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_126_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_126_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_126_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_126_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_126_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_126_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_126_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_126_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_126_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_126_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_126_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_126_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_126_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_126_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_126_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_126_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_126_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_126_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_126_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_126_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_126_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_126_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_126_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_126_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_126_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_126_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_126_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_126_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_126_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_126_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_126_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_126_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_127_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_127_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_127_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_127_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_127_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_127_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_127_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_127_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_127_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_127_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_127_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_127_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_127_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_127_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_127_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_127_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_127_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_127_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_127_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_127_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_127_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_127_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_127_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_127_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_127_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_127_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_127_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_127_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_127_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_127_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_127_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_127_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_127_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_127_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_127_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_127_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_127_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_127_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_127_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_127_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_127_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_127_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_127_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_127_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_127_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_130_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_130_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_130_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_130_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_130_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_130_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_130_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_130_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_130_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_130_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_130_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_130_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_130_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_130_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_130_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_130_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_130_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_130_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_130_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_130_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_130_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_130_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_130_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_130_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_130_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_130_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_130_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_130_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_130_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_130_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_130_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_130_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_130_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_130_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_130_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_130_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_130_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_130_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_130_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_130_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_130_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_130_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_130_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_130_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_130_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_131_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_131_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_131_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_131_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_131_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_131_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_131_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_131_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_131_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_131_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_131_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_131_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_131_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_131_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_131_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_131_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_131_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_131_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_131_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_131_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_131_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_131_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_131_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_131_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_131_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_131_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_131_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_131_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_131_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_131_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_131_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_131_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_131_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_131_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_131_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_131_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_131_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_131_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_131_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_131_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_131_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_131_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_131_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_131_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_131_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_132_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_132_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_132_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_132_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_132_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_132_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_132_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_132_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_132_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_132_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_132_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_132_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_132_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_132_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_132_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_132_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_132_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_132_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_132_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_132_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_132_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_132_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_132_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_132_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_132_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_132_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_132_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_132_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_132_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_132_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_132_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_132_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_132_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_132_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_132_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_132_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_132_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_132_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_132_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_132_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_132_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_132_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_132_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_132_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_132_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_133_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_133_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_133_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_133_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_133_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_133_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_133_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_133_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_133_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_133_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_133_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_133_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_133_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_133_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_133_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_133_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_133_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_133_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_133_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_133_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_133_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_133_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_133_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_133_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_133_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_133_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_133_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_133_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_133_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_133_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_133_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_133_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_133_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_133_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_133_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_133_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_133_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_133_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_133_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_133_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_133_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_133_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_133_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_133_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_133_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_134_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_134_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_134_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_134_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_134_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_134_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_134_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_134_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_134_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_134_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_134_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_134_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_134_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_134_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_134_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_134_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_134_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_134_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_134_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_134_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_134_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_134_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_134_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_134_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_134_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_134_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_134_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_134_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_134_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_134_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_134_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_134_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_134_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_134_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_134_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_134_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_134_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_134_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_134_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_134_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_134_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_134_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_134_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_134_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_134_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_100_137_INST_GPIO_135_PIN_CONTROL  ------------------- */
#define GPIO_100_137_INST_GPIO_135_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_100_137_INST GPIO_135_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_100_137_INST_GPIO_135_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_100_137_INST GPIO_135_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_135_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_100_137_INST GPIO_135_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_100_137_INST_GPIO_135_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_100_137_INST GPIO_135_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_135_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_100_137_INST GPIO_135_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_100_137_INST_GPIO_135_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_100_137_INST GPIO_135_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_100_137_INST_GPIO_135_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_100_137_INST GPIO_135_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_100_137_INST_GPIO_135_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_100_137_INST GPIO_135_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_135_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_100_137_INST GPIO_135_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_100_137_INST_GPIO_135_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_100_137_INST GPIO_135_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_135_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_100_137_INST GPIO_135_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_100_137_INST_GPIO_135_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_100_137_INST GPIO_135_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_135_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_100_137_INST GPIO_135_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_100_137_INST_GPIO_135_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_100_137_INST GPIO_135_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_135_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_100_137_INST GPIO_135_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_100_137_INST_GPIO_135_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_100_137_INST GPIO_135_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_135_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_100_137_INST GPIO_135_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_100_137_INST_GPIO_135_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_100_137_INST GPIO_135_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_100_137_INST_GPIO_135_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_100_137_INST GPIO_135_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_100_137_INST_GPIO_135_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_100_137_INST GPIO_135_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_100_137_INST_GPIO_135_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_100_137_INST GPIO_135_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_100_137_INST_GPIO_135_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_100_137_INST GPIO_135_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */


/* ================================================================================ */
/* ================   struct 'GPIO_140_176_INST' Position & Mask   ================ */
/* ================================================================================ */


/* -------------------  GPIO_140_176_INST_GPIO_140_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_140_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_140_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_140_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_140_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_140_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_140_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_140_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_140_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_140_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_140_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_140_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_140_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_140_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_140_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_140_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_140_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_140_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_140_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_140_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_140_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_140_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_140_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_140_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_140_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_140_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_140_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_140_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_140_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_140_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_140_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_140_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_140_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_140_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_140_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_140_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_140_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_140_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_140_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_140_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_140_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_140_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_140_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_140_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_140_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_141_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_141_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_141_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_141_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_141_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_141_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_141_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_141_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_141_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_141_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_141_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_141_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_141_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_141_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_141_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_141_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_141_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_141_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_141_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_141_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_141_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_141_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_141_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_141_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_141_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_141_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_141_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_141_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_141_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_141_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_141_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_141_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_141_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_141_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_141_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_141_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_141_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_141_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_141_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_141_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_141_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_141_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_141_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_141_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_141_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_142_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_142_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_142_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_142_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_142_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_142_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_142_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_142_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_142_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_142_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_142_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_142_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_142_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_142_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_142_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_142_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_142_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_142_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_142_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_142_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_142_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_142_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_142_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_142_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_142_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_142_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_142_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_142_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_142_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_142_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_142_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_142_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_142_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_142_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_142_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_142_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_142_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_142_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_142_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_142_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_142_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_142_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_142_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_142_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_142_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_143_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_143_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_143_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_143_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_143_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_143_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_143_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_143_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_143_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_143_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_143_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_143_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_143_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_143_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_143_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_143_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_143_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_143_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_143_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_143_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_143_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_143_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_143_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_143_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_143_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_143_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_143_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_143_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_143_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_143_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_143_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_143_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_143_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_143_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_143_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_143_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_143_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_143_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_143_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_143_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_143_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_143_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_143_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_143_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_143_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_144_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_144_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_144_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_144_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_144_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_144_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_144_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_144_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_144_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_144_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_144_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_144_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_144_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_144_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_144_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_144_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_144_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_144_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_144_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_144_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_144_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_144_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_144_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_144_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_144_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_144_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_144_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_144_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_144_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_144_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_144_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_144_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_144_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_144_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_144_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_144_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_144_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_144_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_144_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_144_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_144_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_144_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_144_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_144_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_144_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_145_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_145_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_145_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_145_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_145_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_145_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_145_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_145_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_145_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_145_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_145_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_145_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_145_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_145_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_145_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_145_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_145_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_145_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_145_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_145_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_145_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_145_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_145_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_145_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_145_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_145_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_145_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_145_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_145_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_145_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_145_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_145_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_145_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_145_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_145_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_145_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_145_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_145_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_145_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_145_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_145_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_145_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_145_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_145_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_145_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_146_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_146_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_146_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_146_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_146_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_146_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_146_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_146_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_146_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_146_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_146_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_146_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_146_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_146_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_146_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_146_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_146_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_146_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_146_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_146_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_146_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_146_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_146_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_146_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_146_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_146_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_146_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_146_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_146_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_146_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_146_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_146_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_146_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_146_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_146_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_146_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_146_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_146_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_146_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_146_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_146_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_146_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_146_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_146_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_146_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_147_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_147_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_147_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_147_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_147_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_147_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_147_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_147_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_147_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_147_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_147_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_147_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_147_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_147_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_147_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_147_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_147_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_147_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_147_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_147_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_147_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_147_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_147_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_147_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_147_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_147_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_147_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_147_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_147_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_147_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_147_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_147_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_147_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_147_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_147_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_147_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_147_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_147_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_147_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_147_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_147_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_147_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_147_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_147_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_147_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_150_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_150_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_150_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_150_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_150_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_150_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_150_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_150_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_150_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_150_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_150_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_150_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_150_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_150_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_150_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_150_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_150_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_150_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_150_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_150_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_150_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_150_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_150_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_150_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_150_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_150_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_150_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_150_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_150_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_150_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_150_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_150_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_150_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_150_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_150_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_150_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_150_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_150_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_150_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_150_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_150_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_150_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_150_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_150_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_150_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_151_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_151_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_151_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_151_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_151_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_151_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_151_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_151_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_151_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_151_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_151_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_151_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_151_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_151_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_151_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_151_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_151_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_151_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_151_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_151_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_151_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_151_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_151_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_151_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_151_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_151_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_151_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_151_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_151_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_151_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_151_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_151_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_151_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_151_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_151_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_151_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_151_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_151_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_151_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_151_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_151_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_151_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_151_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_151_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_151_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_152_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_152_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_152_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_152_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_152_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_152_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_152_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_152_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_152_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_152_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_152_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_152_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_152_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_152_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_152_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_152_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_152_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_152_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_152_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_152_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_152_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_152_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_152_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_152_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_152_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_152_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_152_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_152_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_152_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_152_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_152_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_152_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_152_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_152_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_152_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_152_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_152_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_152_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_152_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_152_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_152_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_152_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_152_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_152_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_152_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_153_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_153_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_153_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_153_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_153_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_153_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_153_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_153_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_153_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_153_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_153_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_153_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_153_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_153_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_153_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_153_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_153_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_153_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_153_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_153_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_153_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_153_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_153_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_153_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_153_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_153_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_153_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_153_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_153_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_153_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_153_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_153_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_153_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_153_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_153_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_153_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_153_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_153_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_153_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_153_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_153_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_153_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_153_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_153_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_153_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_154_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_154_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_154_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_154_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_154_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_154_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_154_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_154_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_154_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_154_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_154_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_154_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_154_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_154_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_154_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_154_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_154_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_154_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_154_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_154_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_154_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_154_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_154_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_154_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_154_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_154_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_154_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_154_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_154_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_154_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_154_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_154_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_154_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_154_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_154_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_154_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_154_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_154_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_154_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_154_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_154_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_154_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_154_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_154_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_154_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_155_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_155_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_155_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_155_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_155_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_155_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_155_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_155_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_155_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_155_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_155_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_155_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_155_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_155_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_155_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_155_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_155_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_155_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_155_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_155_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_155_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_155_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_155_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_155_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_155_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_155_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_155_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_155_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_155_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_155_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_155_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_155_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_155_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_155_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_155_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_155_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_155_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_155_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_155_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_155_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_155_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_155_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_155_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_155_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_155_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_156_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_156_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_156_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_156_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_156_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_156_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_156_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_156_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_156_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_156_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_156_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_156_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_156_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_156_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_156_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_156_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_156_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_156_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_156_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_156_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_156_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_156_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_156_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_156_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_156_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_156_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_156_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_156_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_156_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_156_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_156_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_156_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_156_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_156_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_156_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_156_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_156_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_156_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_156_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_156_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_156_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_156_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_156_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_156_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_156_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_157_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_157_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_157_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_157_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_157_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_157_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_157_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_157_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_157_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_157_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_157_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_157_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_157_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_157_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_157_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_157_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_157_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_157_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_157_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_157_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_157_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_157_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_157_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_157_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_157_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_157_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_157_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_157_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_157_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_157_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_157_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_157_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_157_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_157_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_157_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_157_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_157_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_157_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_157_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_157_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_157_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_157_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_157_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_157_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_157_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_160_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_160_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_160_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_160_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_160_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_160_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_160_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_160_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_160_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_160_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_160_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_160_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_160_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_160_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_160_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_160_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_160_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_160_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_160_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_160_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_160_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_160_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_160_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_160_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_160_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_160_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_160_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_160_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_160_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_160_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_160_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_160_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_160_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_160_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_160_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_160_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_160_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_160_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_160_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_160_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_160_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_160_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_160_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_160_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_160_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_161_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_161_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_161_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_161_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_161_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_161_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_161_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_161_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_161_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_161_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_161_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_161_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_161_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_161_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_161_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_161_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_161_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_161_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_161_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_161_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_161_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_161_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_161_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_161_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_161_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_161_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_161_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_161_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_161_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_161_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_161_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_161_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_161_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_161_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_161_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_161_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_161_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_161_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_161_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_161_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_161_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_161_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_161_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_161_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_161_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_162_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_162_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_162_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_162_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_162_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_162_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_162_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_162_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_162_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_162_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_162_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_162_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_162_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_162_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_162_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_162_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_162_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_162_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_162_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_162_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_162_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_162_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_162_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_162_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_162_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_162_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_162_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_162_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_162_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_162_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_162_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_162_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_162_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_162_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_162_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_162_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_162_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_162_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_162_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_162_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_162_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_162_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_162_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_162_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_162_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_163_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_163_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_163_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_163_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_163_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_163_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_163_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_163_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_163_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_163_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_163_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_163_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_163_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_163_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_163_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_163_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_163_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_163_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_163_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_163_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_163_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_163_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_163_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_163_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_163_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_163_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_163_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_163_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_163_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_163_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_163_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_163_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_163_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_163_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_163_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_163_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_163_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_163_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_163_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_163_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_163_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_163_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_163_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_163_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_163_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_164_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_164_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_164_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_164_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_164_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_164_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_164_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_164_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_164_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_164_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_164_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_164_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_164_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_164_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_164_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_164_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_164_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_164_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_164_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_164_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_164_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_164_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_164_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_164_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_164_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_164_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_164_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_164_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_164_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_164_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_164_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_164_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_164_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_164_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_164_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_164_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_164_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_164_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_164_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_164_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_164_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_164_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_164_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_164_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_164_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_165_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_165_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_165_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_165_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_165_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_165_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_165_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_165_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_165_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_165_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_165_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_165_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_165_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_165_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_165_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_165_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_165_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_165_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_165_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_165_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_165_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_165_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_165_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_165_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_165_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_165_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_165_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_165_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_165_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_165_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_165_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_165_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_165_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_165_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_165_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_165_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_165_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_165_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_165_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_165_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_165_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_165_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_165_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_165_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_165_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_166_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_166_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_166_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_166_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_166_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_166_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_166_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_166_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_166_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_166_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_166_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_166_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_166_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_166_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_166_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_166_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_166_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_166_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_166_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_166_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_166_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_166_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_166_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_166_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_166_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_166_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_166_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_166_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_166_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_166_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_166_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_166_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_166_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_166_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_166_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_166_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_166_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_166_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_166_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_166_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_166_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_166_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_166_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_166_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_166_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_167_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_167_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_167_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_167_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_167_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_167_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_167_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_167_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_167_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_167_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_167_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_167_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_167_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_167_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_167_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_167_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_167_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_167_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_167_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_167_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_167_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_167_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_167_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_167_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_167_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_167_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_167_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_167_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_167_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_167_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_167_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_167_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_167_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_167_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_167_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_167_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_167_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_167_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_167_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_167_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_167_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_167_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_167_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_167_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_167_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_170_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_170_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_170_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_170_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_170_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_170_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_170_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_170_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_170_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_170_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_170_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_170_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_170_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_170_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_170_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_170_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_170_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_170_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_170_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_170_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_170_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_170_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_170_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_170_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_170_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_170_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_170_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_170_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_170_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_170_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_170_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_170_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_170_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_170_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_170_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_170_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_170_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_170_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_170_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_170_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_170_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_170_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_170_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_170_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_170_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_171_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_171_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_171_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_171_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_171_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_171_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_171_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_171_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_171_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_171_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_171_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_171_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_171_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_171_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_171_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_171_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_171_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_171_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_171_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_171_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_171_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_171_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_171_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_171_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_171_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_171_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_171_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_171_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_171_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_171_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_171_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_171_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_171_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_171_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_171_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_171_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_171_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_171_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_171_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_171_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_171_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_171_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_171_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_171_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_171_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_172_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_172_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_172_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_172_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_172_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_172_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_172_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_172_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_172_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_172_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_172_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_172_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_172_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_172_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_172_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_172_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_172_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_172_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_172_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_172_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_172_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_172_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_172_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_172_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_172_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_172_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_172_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_172_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_172_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_172_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_172_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_172_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_172_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_172_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_172_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_172_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_172_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_172_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_172_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_172_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_172_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_172_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_172_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_172_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_172_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_173_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_173_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_173_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_173_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_173_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_173_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_173_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_173_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_173_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_173_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_173_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_173_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_173_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_173_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_173_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_173_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_173_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_173_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_173_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_173_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_173_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_173_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_173_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_173_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_173_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_173_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_173_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_173_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_173_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_173_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_173_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_173_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_173_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_173_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_173_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_173_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_173_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_173_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_173_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_173_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_173_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_173_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_173_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_173_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_173_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_174_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_174_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_174_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_174_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_174_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_174_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_174_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_174_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_174_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_174_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_174_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_174_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_174_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_174_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_174_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_174_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_174_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_174_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_174_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_174_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_174_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_174_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_174_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_174_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_174_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_174_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_174_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_174_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_174_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_174_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_174_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_174_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_174_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_174_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_174_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_174_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_174_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_174_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_174_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_174_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_174_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_174_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_174_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_174_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_174_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_140_176_INST_GPIO_175_PIN_CONTROL  ------------------- */
#define GPIO_140_176_INST_GPIO_175_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_140_176_INST GPIO_175_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_140_176_INST_GPIO_175_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_140_176_INST GPIO_175_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_175_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_140_176_INST GPIO_175_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_140_176_INST_GPIO_175_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_140_176_INST GPIO_175_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_175_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_140_176_INST GPIO_175_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_140_176_INST_GPIO_175_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_140_176_INST GPIO_175_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_140_176_INST_GPIO_175_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_140_176_INST GPIO_175_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_140_176_INST_GPIO_175_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_140_176_INST GPIO_175_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_175_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_140_176_INST GPIO_175_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_140_176_INST_GPIO_175_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_140_176_INST GPIO_175_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_175_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_140_176_INST GPIO_175_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_140_176_INST_GPIO_175_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_140_176_INST GPIO_175_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_175_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_140_176_INST GPIO_175_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_140_176_INST_GPIO_175_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_140_176_INST GPIO_175_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_175_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_140_176_INST GPIO_175_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_140_176_INST_GPIO_175_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_140_176_INST GPIO_175_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_175_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_140_176_INST GPIO_175_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_140_176_INST_GPIO_175_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_140_176_INST GPIO_175_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_140_176_INST_GPIO_175_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_140_176_INST GPIO_175_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_140_176_INST_GPIO_175_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_140_176_INST GPIO_175_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_140_176_INST_GPIO_175_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_140_176_INST GPIO_175_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_140_176_INST_GPIO_175_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_140_176_INST GPIO_175_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */


/* ================================================================================ */
/* ================   struct 'GPIO_200_236_INST' Position & Mask   ================ */
/* ================================================================================ */


/* -------------------  GPIO_200_236_INST_GPIO_200_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_200_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_200_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_200_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_200_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_200_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_200_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_200_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_200_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_200_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_200_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_200_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_200_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_200_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_200_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_200_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_200_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_200_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_200_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_200_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_200_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_200_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_200_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_200_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_200_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_200_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_200_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_200_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_200_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_200_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_200_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_200_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_200_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_200_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_200_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_200_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_200_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_200_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_200_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_200_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_200_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_200_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_200_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_200_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_200_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_201_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_201_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_201_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_201_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_201_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_201_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_201_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_201_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_201_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_201_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_201_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_201_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_201_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_201_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_201_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_201_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_201_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_201_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_201_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_201_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_201_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_201_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_201_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_201_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_201_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_201_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_201_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_201_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_201_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_201_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_201_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_201_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_201_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_201_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_201_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_201_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_201_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_201_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_201_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_201_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_201_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_201_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_201_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_201_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_201_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_202_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_202_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_202_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_202_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_202_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_202_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_202_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_202_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_202_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_202_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_202_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_202_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_202_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_202_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_202_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_202_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_202_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_202_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_202_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_202_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_202_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_202_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_202_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_202_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_202_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_202_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_202_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_202_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_202_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_202_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_202_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_202_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_202_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_202_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_202_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_202_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_202_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_202_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_202_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_202_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_202_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_202_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_202_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_202_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_202_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_203_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_203_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_203_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_203_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_203_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_203_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_203_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_203_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_203_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_203_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_203_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_203_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_203_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_203_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_203_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_203_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_203_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_203_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_203_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_203_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_203_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_203_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_203_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_203_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_203_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_203_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_203_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_203_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_203_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_203_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_203_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_203_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_203_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_203_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_203_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_203_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_203_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_203_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_203_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_203_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_203_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_203_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_203_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_203_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_203_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_204_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_204_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_204_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_204_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_204_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_204_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_204_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_204_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_204_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_204_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_204_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_204_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_204_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_204_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_204_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_204_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_204_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_204_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_204_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_204_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_204_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_204_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_204_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_204_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_204_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_204_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_204_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_204_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_204_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_204_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_204_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_204_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_204_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_204_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_204_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_204_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_204_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_204_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_204_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_204_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_204_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_204_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_204_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_204_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_204_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_205_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_205_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_205_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_205_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_205_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_205_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_205_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_205_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_205_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_205_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_205_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_205_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_205_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_205_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_205_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_205_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_205_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_205_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_205_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_205_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_205_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_205_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_205_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_205_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_205_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_205_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_205_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_205_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_205_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_205_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_205_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_205_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_205_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_205_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_205_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_205_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_205_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_205_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_205_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_205_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_205_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_205_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_205_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_205_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_205_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_206_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_206_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_206_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_206_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_206_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_206_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_206_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_206_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_206_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_206_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_206_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_206_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_206_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_206_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_206_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_206_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_206_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_206_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_206_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_206_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_206_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_206_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_206_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_206_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_206_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_206_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_206_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_206_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_206_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_206_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_206_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_206_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_206_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_206_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_206_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_206_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_206_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_206_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_206_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_206_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_206_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_206_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_206_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_206_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_206_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_207_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_207_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_207_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_207_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_207_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_207_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_207_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_207_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_207_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_207_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_207_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_207_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_207_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_207_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_207_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_207_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_207_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_207_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_207_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_207_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_207_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_207_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_207_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_207_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_207_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_207_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_207_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_207_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_207_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_207_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_207_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_207_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_207_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_207_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_207_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_207_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_207_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_207_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_207_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_207_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_207_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_207_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_207_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_207_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_207_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_210_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_210_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_210_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_210_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_210_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_210_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_210_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_210_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_210_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_210_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_210_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_210_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_210_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_210_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_210_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_210_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_210_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_210_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_210_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_210_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_210_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_210_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_210_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_210_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_210_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_210_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_210_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_210_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_210_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_210_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_210_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_210_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_210_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_210_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_210_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_210_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_210_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_210_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_210_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_210_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_210_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_210_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_210_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_210_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_210_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_211_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_211_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_211_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_211_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_211_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_211_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_211_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_211_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_211_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_211_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_211_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_211_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_211_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_211_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_211_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_211_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_211_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_211_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_211_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_211_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_211_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_211_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_211_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_211_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_211_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_211_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_211_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_211_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_211_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_211_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_211_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_211_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_211_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_211_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_211_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_211_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_211_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_211_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_211_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_211_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_211_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_211_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_211_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_211_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_211_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_212_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_212_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_212_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_212_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_212_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_212_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_212_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_212_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_212_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_212_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_212_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_212_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_212_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_212_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_212_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_212_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_212_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_212_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_212_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_212_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_212_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_212_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_212_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_212_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_212_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_212_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_212_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_212_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_212_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_212_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_212_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_212_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_212_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_212_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_212_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_212_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_212_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_212_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_212_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_212_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_212_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_212_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_212_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_212_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_212_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_213_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_213_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_213_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_213_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_213_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_213_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_213_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_213_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_213_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_213_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_213_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_213_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_213_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_213_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_213_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_213_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_213_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_213_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_213_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_213_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_213_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_213_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_213_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_213_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_213_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_213_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_213_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_213_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_213_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_213_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_213_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_213_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_213_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_213_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_213_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_213_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_213_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_213_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_213_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_213_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_213_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_213_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_213_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_213_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_213_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_214_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_214_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_214_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_214_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_214_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_214_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_214_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_214_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_214_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_214_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_214_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_214_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_214_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_214_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_214_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_214_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_214_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_214_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_214_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_214_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_214_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_214_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_214_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_214_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_214_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_214_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_214_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_214_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_214_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_214_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_214_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_214_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_214_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_214_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_214_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_214_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_214_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_214_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_214_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_214_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_214_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_214_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_214_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_214_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_214_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_215_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_215_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_215_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_215_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_215_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_215_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_215_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_215_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_215_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_215_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_215_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_215_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_215_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_215_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_215_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_215_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_215_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_215_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_215_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_215_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_215_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_215_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_215_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_215_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_215_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_215_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_215_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_215_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_215_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_215_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_215_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_215_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_215_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_215_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_215_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_215_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_215_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_215_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_215_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_215_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_215_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_215_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_215_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_215_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_215_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_216_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_216_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_216_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_216_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_216_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_216_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_216_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_216_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_216_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_216_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_216_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_216_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_216_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_216_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_216_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_216_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_216_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_216_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_216_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_216_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_216_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_216_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_216_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_216_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_216_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_216_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_216_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_216_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_216_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_216_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_216_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_216_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_216_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_216_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_216_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_216_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_216_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_216_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_216_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_216_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_216_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_216_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_216_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_216_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_216_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_217_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_217_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_217_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_217_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_217_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_217_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_217_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_217_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_217_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_217_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_217_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_217_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_217_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_217_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_217_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_217_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_217_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_217_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_217_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_217_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_217_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_217_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_217_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_217_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_217_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_217_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_217_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_217_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_217_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_217_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_217_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_217_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_217_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_217_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_217_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_217_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_217_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_217_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_217_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_217_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_217_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_217_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_217_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_217_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_217_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_221_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_221_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_221_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_221_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_221_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_221_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_221_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_221_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_221_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_221_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_221_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_221_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_221_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_221_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_221_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_221_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_221_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_221_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_221_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_221_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_221_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_221_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_221_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_221_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_221_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_221_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_221_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_221_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_221_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_221_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_221_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_221_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_221_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_221_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_221_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_221_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_221_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_221_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_221_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_221_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_221_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_221_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_221_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_221_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_221_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_222_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_222_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_222_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_222_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_222_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_222_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_222_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_222_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_222_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_222_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_222_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_222_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_222_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_222_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_222_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_222_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_222_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_222_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_222_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_222_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_222_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_222_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_222_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_222_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_222_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_222_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_222_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_222_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_222_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_222_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_222_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_222_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_222_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_222_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_222_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_222_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_222_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_222_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_222_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_222_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_222_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_222_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_222_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_222_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_222_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_223_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_223_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_223_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_223_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_223_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_223_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_223_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_223_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_223_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_223_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_223_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_223_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_223_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_223_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_223_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_223_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_223_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_223_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_223_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_223_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_223_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_223_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_223_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_223_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_223_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_223_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_223_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_223_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_223_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_223_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_223_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_223_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_223_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_223_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_223_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_223_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_223_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_223_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_223_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_223_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_223_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_223_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_223_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_223_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_223_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_224_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_224_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_224_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_224_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_224_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_224_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_224_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_224_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_224_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_224_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_224_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_224_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_224_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_224_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_224_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_224_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_224_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_224_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_224_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_224_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_224_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_224_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_224_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_224_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_224_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_224_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_224_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_224_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_224_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_224_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_224_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_224_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_224_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_224_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_224_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_224_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_224_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_224_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_224_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_224_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_224_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_224_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_224_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_224_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_224_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_225_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_225_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_225_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_225_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_225_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_225_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_225_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_225_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_225_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_225_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_225_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_225_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_225_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_225_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_225_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_225_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_225_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_225_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_225_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_225_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_225_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_225_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_225_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_225_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_225_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_225_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_225_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_225_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_225_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_225_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_225_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_225_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_225_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_225_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_225_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_225_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_225_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_225_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_225_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_225_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_225_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_225_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_225_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_225_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_225_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_226_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_226_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_226_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_226_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_226_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_226_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_226_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_226_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_226_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_226_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_226_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_226_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_226_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_226_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_226_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_226_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_226_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_226_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_226_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_226_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_226_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_226_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_226_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_226_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_226_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_226_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_226_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_226_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_226_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_226_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_226_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_226_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_226_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_226_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_226_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_226_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_226_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_226_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_226_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_226_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_226_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_226_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_226_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_226_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_226_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_227_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_227_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_227_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_227_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_227_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_227_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_227_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_227_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_227_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_227_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_227_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_227_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_227_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_227_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_227_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_227_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_227_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_227_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_227_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_227_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_227_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_227_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_227_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_227_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_227_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_227_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_227_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_227_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_227_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_227_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_227_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_227_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_227_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_227_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_227_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_227_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_227_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_227_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_227_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_227_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_227_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_227_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_227_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_227_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_227_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_230_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_230_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_230_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_230_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_230_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_230_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_230_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_230_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_230_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_230_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_230_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_230_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_230_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_230_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_230_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_230_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_230_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_230_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_230_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_230_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_230_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_230_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_230_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_230_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_230_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_230_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_230_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_230_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_230_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_230_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_230_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_230_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_230_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_230_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_230_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_230_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_230_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_230_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_230_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_230_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_230_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_230_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_230_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_230_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_230_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_231_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_231_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_231_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_231_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_231_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_231_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_231_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_231_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_231_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_231_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_231_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_231_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_231_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_231_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_231_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_231_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_231_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_231_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_231_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_231_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_231_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_231_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_231_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_231_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_231_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_231_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_231_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_231_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_231_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_231_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_231_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_231_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_231_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_231_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_231_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_231_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_231_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_231_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_231_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_231_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_231_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_231_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_231_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_231_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_231_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_233_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_233_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_233_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_233_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_233_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_233_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_233_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_233_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_233_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_233_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_233_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_233_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_233_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_233_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_233_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_233_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_233_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_233_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_233_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_233_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_233_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_233_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_233_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_233_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_233_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_233_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_233_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_233_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_233_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_233_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_233_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_233_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_233_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_233_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_233_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_233_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_233_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_233_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_233_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_233_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_233_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_233_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_233_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_233_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_233_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_234_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_234_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_234_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_234_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_234_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_234_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_234_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_234_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_234_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_234_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_234_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_234_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_234_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_234_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_234_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_234_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_234_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_234_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_234_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_234_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_234_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_234_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_234_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_234_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_234_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_234_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_234_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_234_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_234_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_234_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_234_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_234_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_234_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_234_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_234_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_234_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_234_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_234_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_234_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_234_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_234_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_234_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_234_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_234_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_234_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_200_236_INST_GPIO_235_PIN_CONTROL  ------------------- */
#define GPIO_200_236_INST_GPIO_235_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_200_236_INST GPIO_235_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_200_236_INST_GPIO_235_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_200_236_INST GPIO_235_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_235_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_200_236_INST GPIO_235_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_200_236_INST_GPIO_235_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_200_236_INST GPIO_235_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_235_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_200_236_INST GPIO_235_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_200_236_INST_GPIO_235_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_200_236_INST GPIO_235_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_200_236_INST_GPIO_235_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_200_236_INST GPIO_235_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_200_236_INST_GPIO_235_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_200_236_INST GPIO_235_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_235_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_200_236_INST GPIO_235_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_200_236_INST_GPIO_235_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_200_236_INST GPIO_235_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_235_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_200_236_INST GPIO_235_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_200_236_INST_GPIO_235_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_200_236_INST GPIO_235_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_235_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_200_236_INST GPIO_235_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_200_236_INST_GPIO_235_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_200_236_INST GPIO_235_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_235_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_200_236_INST GPIO_235_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_200_236_INST_GPIO_235_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_200_236_INST GPIO_235_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_235_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_200_236_INST GPIO_235_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_200_236_INST_GPIO_235_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_200_236_INST GPIO_235_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_200_236_INST_GPIO_235_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_200_236_INST GPIO_235_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_200_236_INST_GPIO_235_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_200_236_INST GPIO_235_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_200_236_INST_GPIO_235_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_200_236_INST GPIO_235_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_200_236_INST_GPIO_235_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_200_236_INST GPIO_235_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */


/* ================================================================================ */
/* ================   struct 'GPIO_240_257_INST' Position & Mask   ================ */
/* ================================================================================ */


/* -------------------  GPIO_240_257_INST_GPIO_240_PIN_CONTROL  ------------------- */
#define GPIO_240_257_INST_GPIO_240_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_240_257_INST GPIO_240_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_240_257_INST_GPIO_240_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_240_257_INST GPIO_240_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_240_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_240_257_INST GPIO_240_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_240_257_INST_GPIO_240_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_240_257_INST GPIO_240_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_240_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_240_257_INST GPIO_240_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_240_257_INST_GPIO_240_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_240_257_INST GPIO_240_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_240_257_INST_GPIO_240_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_240_257_INST GPIO_240_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_240_257_INST_GPIO_240_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_240_257_INST GPIO_240_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_240_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_240_257_INST GPIO_240_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_240_257_INST_GPIO_240_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_240_257_INST GPIO_240_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_240_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_240_257_INST GPIO_240_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_240_257_INST_GPIO_240_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_240_257_INST GPIO_240_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_240_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_240_257_INST GPIO_240_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_240_257_INST_GPIO_240_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_240_257_INST GPIO_240_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_240_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_240_257_INST GPIO_240_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_240_257_INST_GPIO_240_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_240_257_INST GPIO_240_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_240_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_240_257_INST GPIO_240_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_240_257_INST_GPIO_240_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_240_257_INST GPIO_240_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_240_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_240_257_INST GPIO_240_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_240_257_INST_GPIO_240_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_240_257_INST GPIO_240_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_240_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_240_257_INST GPIO_240_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_240_257_INST_GPIO_240_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_240_257_INST GPIO_240_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_240_257_INST_GPIO_241_PIN_CONTROL  ------------------- */
#define GPIO_240_257_INST_GPIO_241_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_240_257_INST GPIO_241_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_240_257_INST_GPIO_241_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_240_257_INST GPIO_241_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_241_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_240_257_INST GPIO_241_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_240_257_INST_GPIO_241_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_240_257_INST GPIO_241_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_241_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_240_257_INST GPIO_241_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_240_257_INST_GPIO_241_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_240_257_INST GPIO_241_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_240_257_INST_GPIO_241_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_240_257_INST GPIO_241_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_240_257_INST_GPIO_241_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_240_257_INST GPIO_241_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_241_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_240_257_INST GPIO_241_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_240_257_INST_GPIO_241_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_240_257_INST GPIO_241_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_241_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_240_257_INST GPIO_241_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_240_257_INST_GPIO_241_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_240_257_INST GPIO_241_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_241_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_240_257_INST GPIO_241_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_240_257_INST_GPIO_241_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_240_257_INST GPIO_241_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_241_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_240_257_INST GPIO_241_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_240_257_INST_GPIO_241_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_240_257_INST GPIO_241_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_241_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_240_257_INST GPIO_241_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_240_257_INST_GPIO_241_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_240_257_INST GPIO_241_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_241_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_240_257_INST GPIO_241_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_240_257_INST_GPIO_241_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_240_257_INST GPIO_241_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_241_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_240_257_INST GPIO_241_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_240_257_INST_GPIO_241_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_240_257_INST GPIO_241_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_240_257_INST_GPIO_242_PIN_CONTROL  ------------------- */
#define GPIO_240_257_INST_GPIO_242_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_240_257_INST GPIO_242_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_240_257_INST_GPIO_242_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_240_257_INST GPIO_242_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_242_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_240_257_INST GPIO_242_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_240_257_INST_GPIO_242_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_240_257_INST GPIO_242_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_242_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_240_257_INST GPIO_242_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_240_257_INST_GPIO_242_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_240_257_INST GPIO_242_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_240_257_INST_GPIO_242_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_240_257_INST GPIO_242_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_240_257_INST_GPIO_242_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_240_257_INST GPIO_242_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_242_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_240_257_INST GPIO_242_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_240_257_INST_GPIO_242_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_240_257_INST GPIO_242_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_242_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_240_257_INST GPIO_242_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_240_257_INST_GPIO_242_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_240_257_INST GPIO_242_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_242_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_240_257_INST GPIO_242_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_240_257_INST_GPIO_242_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_240_257_INST GPIO_242_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_242_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_240_257_INST GPIO_242_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_240_257_INST_GPIO_242_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_240_257_INST GPIO_242_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_242_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_240_257_INST GPIO_242_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_240_257_INST_GPIO_242_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_240_257_INST GPIO_242_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_242_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_240_257_INST GPIO_242_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_240_257_INST_GPIO_242_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_240_257_INST GPIO_242_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_242_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_240_257_INST GPIO_242_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_240_257_INST_GPIO_242_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_240_257_INST GPIO_242_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_240_257_INST_GPIO_243_PIN_CONTROL  ------------------- */
#define GPIO_240_257_INST_GPIO_243_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_240_257_INST GPIO_243_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_240_257_INST_GPIO_243_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_240_257_INST GPIO_243_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_243_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_240_257_INST GPIO_243_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_240_257_INST_GPIO_243_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_240_257_INST GPIO_243_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_243_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_240_257_INST GPIO_243_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_240_257_INST_GPIO_243_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_240_257_INST GPIO_243_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_240_257_INST_GPIO_243_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_240_257_INST GPIO_243_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_240_257_INST_GPIO_243_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_240_257_INST GPIO_243_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_243_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_240_257_INST GPIO_243_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_240_257_INST_GPIO_243_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_240_257_INST GPIO_243_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_243_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_240_257_INST GPIO_243_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_240_257_INST_GPIO_243_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_240_257_INST GPIO_243_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_243_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_240_257_INST GPIO_243_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_240_257_INST_GPIO_243_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_240_257_INST GPIO_243_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_243_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_240_257_INST GPIO_243_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_240_257_INST_GPIO_243_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_240_257_INST GPIO_243_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_243_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_240_257_INST GPIO_243_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_240_257_INST_GPIO_243_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_240_257_INST GPIO_243_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_243_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_240_257_INST GPIO_243_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_240_257_INST_GPIO_243_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_240_257_INST GPIO_243_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_243_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_240_257_INST GPIO_243_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_240_257_INST_GPIO_243_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_240_257_INST GPIO_243_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_240_257_INST_GPIO_244_PIN_CONTROL  ------------------- */
#define GPIO_240_257_INST_GPIO_244_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_240_257_INST GPIO_244_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_240_257_INST_GPIO_244_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_240_257_INST GPIO_244_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_244_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_240_257_INST GPIO_244_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_240_257_INST_GPIO_244_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_240_257_INST GPIO_244_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_244_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_240_257_INST GPIO_244_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_240_257_INST_GPIO_244_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_240_257_INST GPIO_244_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_240_257_INST_GPIO_244_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_240_257_INST GPIO_244_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_240_257_INST_GPIO_244_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_240_257_INST GPIO_244_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_244_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_240_257_INST GPIO_244_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_240_257_INST_GPIO_244_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_240_257_INST GPIO_244_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_244_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_240_257_INST GPIO_244_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_240_257_INST_GPIO_244_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_240_257_INST GPIO_244_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_244_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_240_257_INST GPIO_244_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_240_257_INST_GPIO_244_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_240_257_INST GPIO_244_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_244_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_240_257_INST GPIO_244_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_240_257_INST_GPIO_244_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_240_257_INST GPIO_244_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_244_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_240_257_INST GPIO_244_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_240_257_INST_GPIO_244_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_240_257_INST GPIO_244_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_244_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_240_257_INST GPIO_244_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_240_257_INST_GPIO_244_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_240_257_INST GPIO_244_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_244_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_240_257_INST GPIO_244_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_240_257_INST_GPIO_244_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_240_257_INST GPIO_244_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_240_257_INST_GPIO_245_PIN_CONTROL  ------------------- */
#define GPIO_240_257_INST_GPIO_245_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_240_257_INST GPIO_245_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_240_257_INST_GPIO_245_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_240_257_INST GPIO_245_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_245_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_240_257_INST GPIO_245_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_240_257_INST_GPIO_245_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_240_257_INST GPIO_245_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_245_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_240_257_INST GPIO_245_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_240_257_INST_GPIO_245_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_240_257_INST GPIO_245_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_240_257_INST_GPIO_245_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_240_257_INST GPIO_245_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_240_257_INST_GPIO_245_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_240_257_INST GPIO_245_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_245_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_240_257_INST GPIO_245_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_240_257_INST_GPIO_245_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_240_257_INST GPIO_245_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_245_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_240_257_INST GPIO_245_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_240_257_INST_GPIO_245_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_240_257_INST GPIO_245_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_245_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_240_257_INST GPIO_245_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_240_257_INST_GPIO_245_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_240_257_INST GPIO_245_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_245_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_240_257_INST GPIO_245_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_240_257_INST_GPIO_245_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_240_257_INST GPIO_245_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_245_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_240_257_INST GPIO_245_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_240_257_INST_GPIO_245_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_240_257_INST GPIO_245_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_245_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_240_257_INST GPIO_245_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_240_257_INST_GPIO_245_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_240_257_INST GPIO_245_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_245_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_240_257_INST GPIO_245_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_240_257_INST_GPIO_245_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_240_257_INST GPIO_245_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_240_257_INST_GPIO_246_PIN_CONTROL  ------------------- */
#define GPIO_240_257_INST_GPIO_246_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_240_257_INST GPIO_246_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_240_257_INST_GPIO_246_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_240_257_INST GPIO_246_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_246_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_240_257_INST GPIO_246_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_240_257_INST_GPIO_246_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_240_257_INST GPIO_246_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_246_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_240_257_INST GPIO_246_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_240_257_INST_GPIO_246_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_240_257_INST GPIO_246_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_240_257_INST_GPIO_246_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_240_257_INST GPIO_246_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_240_257_INST_GPIO_246_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_240_257_INST GPIO_246_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_246_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_240_257_INST GPIO_246_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_240_257_INST_GPIO_246_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_240_257_INST GPIO_246_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_246_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_240_257_INST GPIO_246_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_240_257_INST_GPIO_246_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_240_257_INST GPIO_246_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_246_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_240_257_INST GPIO_246_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_240_257_INST_GPIO_246_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_240_257_INST GPIO_246_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_246_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_240_257_INST GPIO_246_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_240_257_INST_GPIO_246_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_240_257_INST GPIO_246_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_246_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_240_257_INST GPIO_246_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_240_257_INST_GPIO_246_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_240_257_INST GPIO_246_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_246_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_240_257_INST GPIO_246_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_240_257_INST_GPIO_246_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_240_257_INST GPIO_246_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_246_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_240_257_INST GPIO_246_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_240_257_INST_GPIO_246_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_240_257_INST GPIO_246_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_240_257_INST_GPIO_250_PIN_CONTROL  ------------------- */
#define GPIO_240_257_INST_GPIO_250_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_240_257_INST GPIO_250_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_240_257_INST_GPIO_250_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_240_257_INST GPIO_250_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_250_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_240_257_INST GPIO_250_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_240_257_INST_GPIO_250_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_240_257_INST GPIO_250_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_250_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_240_257_INST GPIO_250_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_240_257_INST_GPIO_250_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_240_257_INST GPIO_250_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_240_257_INST_GPIO_250_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_240_257_INST GPIO_250_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_240_257_INST_GPIO_250_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_240_257_INST GPIO_250_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_250_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_240_257_INST GPIO_250_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_240_257_INST_GPIO_250_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_240_257_INST GPIO_250_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_250_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_240_257_INST GPIO_250_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_240_257_INST_GPIO_250_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_240_257_INST GPIO_250_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_250_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_240_257_INST GPIO_250_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_240_257_INST_GPIO_250_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_240_257_INST GPIO_250_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_250_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_240_257_INST GPIO_250_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_240_257_INST_GPIO_250_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_240_257_INST GPIO_250_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_250_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_240_257_INST GPIO_250_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_240_257_INST_GPIO_250_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_240_257_INST GPIO_250_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_250_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_240_257_INST GPIO_250_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_240_257_INST_GPIO_250_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_240_257_INST GPIO_250_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_250_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_240_257_INST GPIO_250_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_240_257_INST_GPIO_250_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_240_257_INST GPIO_250_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_240_257_INST_GPIO_253_PIN_CONTROL  ------------------- */
#define GPIO_240_257_INST_GPIO_253_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_240_257_INST GPIO_253_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_240_257_INST_GPIO_253_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_240_257_INST GPIO_253_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_253_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_240_257_INST GPIO_253_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_240_257_INST_GPIO_253_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_240_257_INST GPIO_253_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_253_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_240_257_INST GPIO_253_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_240_257_INST_GPIO_253_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_240_257_INST GPIO_253_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_240_257_INST_GPIO_253_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_240_257_INST GPIO_253_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_240_257_INST_GPIO_253_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_240_257_INST GPIO_253_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_253_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_240_257_INST GPIO_253_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_240_257_INST_GPIO_253_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_240_257_INST GPIO_253_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_253_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_240_257_INST GPIO_253_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_240_257_INST_GPIO_253_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_240_257_INST GPIO_253_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_253_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_240_257_INST GPIO_253_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_240_257_INST_GPIO_253_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_240_257_INST GPIO_253_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_253_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_240_257_INST GPIO_253_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_240_257_INST_GPIO_253_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_240_257_INST GPIO_253_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_253_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_240_257_INST GPIO_253_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_240_257_INST_GPIO_253_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_240_257_INST GPIO_253_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_253_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_240_257_INST GPIO_253_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_240_257_INST_GPIO_253_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_240_257_INST GPIO_253_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_253_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_240_257_INST GPIO_253_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_240_257_INST_GPIO_253_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_240_257_INST GPIO_253_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */

/* -------------------  GPIO_240_257_INST_GPIO_254_PIN_CONTROL  ------------------- */
#define GPIO_240_257_INST_GPIO_254_PIN_CONTROL_PU_PD_Pos (0UL)          /*!< GPIO_240_257_INST GPIO_254_PIN_CONTROL: PU_PD (Bit 0)       */
#define GPIO_240_257_INST_GPIO_254_PIN_CONTROL_PU_PD_Msk (0x3UL)        /*!< GPIO_240_257_INST GPIO_254_PIN_CONTROL: PU_PD (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_254_PIN_CONTROL_POWER_GATING_Pos (2UL)   /*!< GPIO_240_257_INST GPIO_254_PIN_CONTROL: POWER_GATING (Bit 2) */
#define GPIO_240_257_INST_GPIO_254_PIN_CONTROL_POWER_GATING_Msk (0xcUL) /*!< GPIO_240_257_INST GPIO_254_PIN_CONTROL: POWER_GATING (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_254_PIN_CONTROL_INTERRUPT_DETECTION_Pos (4UL) /*!< GPIO_240_257_INST GPIO_254_PIN_CONTROL: INTERRUPT_DETECTION (Bit 4) */
#define GPIO_240_257_INST_GPIO_254_PIN_CONTROL_INTERRUPT_DETECTION_Msk (0x70UL) /*!< GPIO_240_257_INST GPIO_254_PIN_CONTROL: INTERRUPT_DETECTION (Bitfield-Mask: 0x07) */
#define GPIO_240_257_INST_GPIO_254_PIN_CONTROL_EDGE_ENABLE_Pos (7UL)    /*!< GPIO_240_257_INST GPIO_254_PIN_CONTROL: EDGE_ENABLE (Bit 7) */
#define GPIO_240_257_INST_GPIO_254_PIN_CONTROL_EDGE_ENABLE_Msk (0x80UL) /*!< GPIO_240_257_INST GPIO_254_PIN_CONTROL: EDGE_ENABLE (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_254_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Pos (8UL) /*!< GPIO_240_257_INST GPIO_254_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bit 8) */
#define GPIO_240_257_INST_GPIO_254_PIN_CONTROL_OUTPUT_BUFFER_TYPE_Msk (0x100UL) /*!< GPIO_240_257_INST GPIO_254_PIN_CONTROL: OUTPUT_BUFFER_TYPE (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_254_PIN_CONTROL_GPIO_DIRECTION_Pos (9UL) /*!< GPIO_240_257_INST GPIO_254_PIN_CONTROL: GPIO_DIRECTION (Bit 9) */
#define GPIO_240_257_INST_GPIO_254_PIN_CONTROL_GPIO_DIRECTION_Msk (0x200UL) /*!< GPIO_240_257_INST GPIO_254_PIN_CONTROL: GPIO_DIRECTION (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_254_PIN_CONTROL_GPIO_OUTPUT_SELECT_Pos (10UL) /*!< GPIO_240_257_INST GPIO_254_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bit 10) */
#define GPIO_240_257_INST_GPIO_254_PIN_CONTROL_GPIO_OUTPUT_SELECT_Msk (0x400UL) /*!< GPIO_240_257_INST GPIO_254_PIN_CONTROL: GPIO_OUTPUT_SELECT (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_254_PIN_CONTROL_POLARITY_Pos (11UL)      /*!< GPIO_240_257_INST GPIO_254_PIN_CONTROL: POLARITY (Bit 11)   */
#define GPIO_240_257_INST_GPIO_254_PIN_CONTROL_POLARITY_Msk (0x800UL)   /*!< GPIO_240_257_INST GPIO_254_PIN_CONTROL: POLARITY (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_254_PIN_CONTROL_MUX_CONTROL_Pos (12UL)   /*!< GPIO_240_257_INST GPIO_254_PIN_CONTROL: MUX_CONTROL (Bit 12) */
#define GPIO_240_257_INST_GPIO_254_PIN_CONTROL_MUX_CONTROL_Msk (0x3000UL) /*!< GPIO_240_257_INST GPIO_254_PIN_CONTROL: MUX_CONTROL (Bitfield-Mask: 0x03) */
#define GPIO_240_257_INST_GPIO_254_PIN_CONTROL_ALTERNATE_GPIO_DATA_Pos (16UL) /*!< GPIO_240_257_INST GPIO_254_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bit 16) */
#define GPIO_240_257_INST_GPIO_254_PIN_CONTROL_ALTERNATE_GPIO_DATA_Msk (0x10000UL) /*!< GPIO_240_257_INST GPIO_254_PIN_CONTROL: ALTERNATE_GPIO_DATA (Bitfield-Mask: 0x01) */
#define GPIO_240_257_INST_GPIO_254_PIN_CONTROL_GPIO_INPUT_Pos (24UL)    /*!< GPIO_240_257_INST GPIO_254_PIN_CONTROL: GPIO_INPUT (Bit 24) */
#define GPIO_240_257_INST_GPIO_254_PIN_CONTROL_GPIO_INPUT_Msk (0x1000000UL) /*!< GPIO_240_257_INST GPIO_254_PIN_CONTROL: GPIO_INPUT (Bitfield-Mask: 0x01) */


/* ================================================================================ */
/* ================struct 'GPIO_PIN_CONTROL_2_INST' Position & Mask================ */
/* ================================================================================ */


/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_000_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_000_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_000_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_000_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_000_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_000_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_000_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_000_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_000_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_001_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_001_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_001_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_001_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_001_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_001_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_001_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_001_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_001_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_002_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_002_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_002_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_002_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_002_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_002_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_002_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_002_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_002_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_003_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_003_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_003_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_003_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_003_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_003_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_003_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_003_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_003_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_004_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_004_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_004_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_004_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_004_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_004_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_004_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_004_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_004_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_005_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_005_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_005_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_005_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_005_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_005_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_005_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_005_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_005_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_006_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_006_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_006_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_006_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_006_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_006_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_006_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_006_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_006_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_007_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_007_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_007_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_007_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_007_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_007_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_007_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_007_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_007_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_010_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_010_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_010_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_010_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_010_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_010_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_010_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_010_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_010_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_011_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_011_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_011_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_011_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_011_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_011_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_011_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_011_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_011_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_012_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_012_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_012_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_012_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_012_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_012_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_012_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_012_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_012_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_013_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_013_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_013_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_013_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_013_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_013_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_013_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_013_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_013_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_014_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_014_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_014_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_014_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_014_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_014_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_014_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_014_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_014_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_015_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_015_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_015_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_015_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_015_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_015_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_015_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_015_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_015_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_016_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_016_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_016_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_016_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_016_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_016_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_016_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_016_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_016_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_017_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_017_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_017_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_017_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_017_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_017_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_017_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_017_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_017_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_020_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_020_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_020_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_020_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_020_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_020_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_020_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_020_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_020_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_021_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_021_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_021_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_021_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_021_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_021_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_021_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_021_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_021_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_022_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_022_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_022_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_022_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_022_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_022_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_022_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_022_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_022_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_023_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_023_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_023_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_023_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_023_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_023_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_023_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_023_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_023_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_024_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_024_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_024_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_024_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_024_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_024_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_024_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_024_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_024_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_025_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_025_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_025_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_025_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_025_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_025_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_025_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_025_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_025_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_026_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_026_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_026_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_026_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_026_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_026_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_026_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_026_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_026_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_027_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_027_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_027_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_027_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_027_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_027_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_027_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_027_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_027_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_030_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_030_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_030_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_030_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_030_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_030_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_030_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_030_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_030_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_031_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_031_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_031_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_031_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_031_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_031_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_031_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_031_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_031_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_032_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_032_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_032_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_032_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_032_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_032_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_032_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_032_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_032_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_033_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_033_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_033_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_033_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_033_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_033_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_033_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_033_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_033_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_034_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_034_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_034_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_034_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_034_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_034_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_034_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_034_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_034_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_035_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_035_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_035_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_035_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_035_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_035_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_035_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_035_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_035_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_036_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_036_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_036_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_036_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_036_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_036_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_036_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_036_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_036_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_040_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_040_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_040_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_040_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_040_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_040_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_040_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_040_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_040_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_041_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_041_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_041_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_041_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_041_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_041_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_041_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_041_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_041_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_042_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_042_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_042_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_042_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_042_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_042_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_042_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_042_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_042_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_043_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_043_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_043_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_043_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_043_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_043_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_043_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_043_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_043_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_044_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_044_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_044_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_044_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_044_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_044_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_044_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_044_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_044_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_045_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_045_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_045_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_045_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_045_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_045_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_045_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_045_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_045_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_046_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_046_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_046_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_046_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_046_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_046_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_046_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_046_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_046_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_047_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_047_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_047_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_047_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_047_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_047_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_047_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_047_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_047_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_050_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_050_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_050_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_050_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_050_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_050_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_050_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_050_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_050_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_051_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_051_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_051_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_051_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_051_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_051_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_051_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_051_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_051_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_052_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_052_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_052_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_052_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_052_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_052_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_052_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_052_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_052_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_053_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_053_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_053_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_053_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_053_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_053_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_053_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_053_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_053_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_054_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_054_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_054_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_054_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_054_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_054_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_054_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_054_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_054_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_055_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_055_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_055_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_055_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_055_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_055_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_055_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_055_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_055_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_056_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_056_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_056_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_056_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_056_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_056_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_056_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_056_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_056_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_057_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_057_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_057_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_057_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_057_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_057_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_057_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_057_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_057_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_060_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_060_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_060_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_060_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_060_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_060_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_060_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_060_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_060_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_061_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_061_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_061_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_061_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_061_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_061_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_061_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_061_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_061_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_062_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_062_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_062_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_062_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_062_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_062_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_062_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_062_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_062_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_063_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_063_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_063_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_063_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_063_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_063_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_063_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_063_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_063_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_064_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_064_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_064_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_064_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_064_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_064_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_064_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_064_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_064_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_065_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_065_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_065_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_065_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_065_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_065_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_065_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_065_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_065_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_066_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_066_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_066_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_066_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_066_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_066_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_066_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_066_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_066_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_067_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_067_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_067_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_067_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_067_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_067_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_067_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_067_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_067_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_070_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_070_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_070_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_070_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_070_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_070_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_070_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_070_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_070_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_071_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_071_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_071_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_071_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_071_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_071_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_071_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_071_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_071_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_072_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_072_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_072_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_072_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_072_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_072_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_072_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_072_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_072_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_073_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_073_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_073_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_073_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_073_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_073_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_073_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_073_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_073_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_074_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_074_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_074_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_074_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_074_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_074_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_074_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_074_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_074_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_075_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_075_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_075_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_075_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_075_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_075_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_075_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_075_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_075_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_076_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_076_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_076_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_076_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_076_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_076_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_076_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_076_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_076_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_100_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_100_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_100_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_100_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_100_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_100_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_100_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_100_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_100_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_101_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_101_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_101_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_101_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_101_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_101_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_101_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_101_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_101_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_102_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_102_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_102_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_102_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_102_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_102_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_102_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_102_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_102_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_103_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_103_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_103_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_103_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_103_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_103_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_103_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_103_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_103_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_104_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_104_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_104_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_104_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_104_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_104_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_104_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_104_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_104_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_105_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_105_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_105_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_105_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_105_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_105_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_105_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_105_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_105_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_106_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_106_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_106_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_106_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_106_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_106_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_106_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_106_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_106_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_107_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_107_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_107_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_107_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_107_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_107_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_107_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_107_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_107_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_110_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_110_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_110_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_110_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_110_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_110_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_110_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_110_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_110_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_111_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_111_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_111_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_111_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_111_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_111_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_111_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_111_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_111_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_112_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_112_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_112_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_112_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_112_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_112_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_112_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_112_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_112_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_113_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_113_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_113_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_113_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_113_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_113_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_113_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_113_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_113_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_114_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_114_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_114_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_114_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_114_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_114_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_114_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_114_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_114_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_115_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_115_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_115_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_115_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_115_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_115_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_115_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_115_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_115_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_116_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_116_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_116_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_116_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_116_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_116_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_116_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_116_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_116_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_117_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_117_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_117_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_117_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_117_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_117_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_117_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_117_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_117_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_120_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_120_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_120_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_120_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_120_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_120_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_120_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_120_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_120_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_121_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_121_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_121_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_121_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_121_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_121_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_121_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_121_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_121_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_122_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_122_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_122_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_122_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_122_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_122_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_122_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_122_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_122_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_123_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_123_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_123_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_123_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_123_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_123_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_123_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_123_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_123_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_124_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_124_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_124_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_124_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_124_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_124_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_124_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_124_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_124_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_125_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_125_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_125_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_125_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_125_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_125_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_125_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_125_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_125_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_126_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_126_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_126_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_126_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_126_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_126_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_126_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_126_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_126_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_127_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_127_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_127_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_127_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_127_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_127_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_127_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_127_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_127_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_130_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_130_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_130_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_130_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_130_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_130_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_130_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_130_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_130_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_131_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_131_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_131_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_131_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_131_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_131_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_131_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_131_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_131_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_132_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_132_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_132_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_132_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_132_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_132_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_132_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_132_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_132_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_133_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_133_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_133_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_133_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_133_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_133_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_133_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_133_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_133_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_134_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_134_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_134_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_134_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_134_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_134_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_134_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_134_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_134_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_135_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_135_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_135_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_135_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_135_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_135_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_135_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_135_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_135_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_140_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_140_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_140_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_140_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_140_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_140_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_140_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_140_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_140_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_141_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_141_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_141_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_141_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_141_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_141_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_141_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_141_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_141_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_142_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_142_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_142_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_142_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_142_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_142_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_142_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_142_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_142_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_143_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_143_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_143_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_143_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_143_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_143_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_143_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_143_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_143_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_144_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_144_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_144_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_144_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_144_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_144_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_144_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_144_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_144_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_145_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_145_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_145_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_145_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_145_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_145_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_145_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_145_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_145_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_146_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_146_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_146_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_146_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_146_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_146_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_146_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_146_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_146_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_147_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_147_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_147_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_147_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_147_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_147_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_147_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_147_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_147_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_150_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_150_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_150_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_150_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_150_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_150_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_150_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_150_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_150_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_151_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_151_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_151_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_151_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_151_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_151_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_151_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_151_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_151_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_152_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_152_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_152_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_152_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_152_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_152_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_152_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_152_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_152_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_153_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_153_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_153_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_153_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_153_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_153_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_153_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_153_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_153_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_154_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_154_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_154_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_154_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_154_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_154_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_154_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_154_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_154_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_155_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_155_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_155_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_155_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_155_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_155_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_155_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_155_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_155_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_156_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_156_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_156_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_156_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_156_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_156_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_156_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_156_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_156_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_157_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_157_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_157_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_157_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_157_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_157_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_157_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_157_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_157_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_160_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_160_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_160_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_160_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_160_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_160_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_160_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_160_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_160_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_161_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_161_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_161_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_161_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_161_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_161_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_161_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_161_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_161_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_162_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_162_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_162_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_162_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_162_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_162_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_162_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_162_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_162_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_163_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_163_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_163_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_163_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_163_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_163_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_163_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_163_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_163_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_164_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_164_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_164_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_164_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_164_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_164_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_164_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_164_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_164_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_165_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_165_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_165_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_165_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_165_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_165_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_165_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_165_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_165_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_166_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_166_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_166_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_166_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_166_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_166_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_166_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_166_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_166_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_167_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_167_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_167_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_167_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_167_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_167_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_167_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_167_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_167_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_170_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_170_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_170_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_170_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_170_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_170_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_170_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_170_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_170_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_171_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_171_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_171_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_171_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_171_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_171_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_171_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_171_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_171_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_172_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_172_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_172_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_172_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_172_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_172_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_172_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_172_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_172_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_173_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_173_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_173_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_173_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_173_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_173_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_173_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_173_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_173_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_174_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_174_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_174_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_174_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_174_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_174_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_174_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_174_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_174_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_175_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_175_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_175_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_175_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_175_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_175_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_175_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_175_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_175_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_200_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_200_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_200_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_200_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_200_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_200_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_200_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_200_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_200_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_201_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_201_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_201_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_201_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_201_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_201_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_201_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_201_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_201_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_202_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_202_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_202_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_202_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_202_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_202_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_202_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_202_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_202_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_203_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_203_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_203_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_203_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_203_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_203_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_203_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_203_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_203_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_204_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_204_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_204_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_204_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_204_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_204_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_204_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_204_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_204_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_205_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_205_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_205_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_205_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_205_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_205_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_205_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_205_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_205_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_206_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_206_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_206_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_206_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_206_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_206_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_206_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_206_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_206_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_207_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_207_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_207_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_207_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_207_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_207_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_207_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_207_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_207_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_210_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_210_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_210_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_210_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_210_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_210_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_210_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_210_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_210_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_211_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_211_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_211_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_211_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_211_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_211_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_211_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_211_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_211_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_212_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_212_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_212_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_212_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_212_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_212_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_212_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_212_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_212_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_213_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_213_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_213_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_213_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_213_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_213_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_213_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_213_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_213_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_214_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_214_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_214_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_214_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_214_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_214_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_214_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_214_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_214_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_215_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_215_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_215_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_215_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_215_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_215_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_215_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_215_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_215_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_216_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_216_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_216_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_216_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_216_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_216_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_216_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_216_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_216_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_217_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_217_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_217_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_217_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_217_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_217_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_217_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_217_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_217_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_221_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_221_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_221_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_221_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_221_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_221_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_221_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_221_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_221_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_222_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_222_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_222_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_222_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_222_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_222_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_222_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_222_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_222_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_223_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_223_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_223_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_223_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_223_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_223_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_223_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_223_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_223_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_224_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_224_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_224_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_224_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_224_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_224_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_224_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_224_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_224_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_225_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_225_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_225_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_225_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_225_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_225_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_225_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_225_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_225_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_226_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_226_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_226_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_226_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_226_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_226_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_226_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_226_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_226_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_227_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_227_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_227_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_227_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_227_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_227_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_227_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_227_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_227_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_230_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_230_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_230_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_230_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_230_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_230_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_230_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_230_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_230_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_231_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_231_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_231_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_231_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_231_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_231_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_231_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_231_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_231_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_233_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_233_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_233_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_233_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_233_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_233_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_233_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_233_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_233_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_234_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_234_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_234_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_234_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_234_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_234_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_234_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_234_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_234_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_235_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_235_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_235_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_235_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_235_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_235_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_235_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_235_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_235_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_240_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_240_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_240_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_240_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_240_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_240_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_240_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_240_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_240_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_241_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_241_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_241_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_241_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_241_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_241_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_241_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_241_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_241_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_242_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_242_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_242_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_242_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_242_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_242_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_242_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_242_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_242_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_243_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_243_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_243_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_243_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_243_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_243_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_243_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_243_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_243_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_244_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_244_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_244_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_244_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_244_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_244_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_244_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_244_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_244_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_245_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_245_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_245_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_245_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_245_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_245_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_245_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_245_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_245_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_246_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_246_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_246_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_246_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_246_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_246_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_246_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_246_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_246_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_250_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_250_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_250_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_250_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_250_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_250_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_250_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_250_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_250_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_253_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_253_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_253_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_253_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_253_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_253_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_253_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_253_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_253_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */

/* ---------------- GPIO_PIN_CONTROL_2_INST_GPIO_254_PIN_CONTROL_2 ---------------- */
#define GPIO_PIN_CONTROL_2_INST_GPIO_254_PIN_CONTROL_2_SLEW_RATE_Pos (0UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_254_PIN_CONTROL_2: SLEW_RATE (Bit 0) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_254_PIN_CONTROL_2_SLEW_RATE_Msk (0x1UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_254_PIN_CONTROL_2: SLEW_RATE (Bitfield-Mask: 0x01) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_254_PIN_CONTROL_2_DRIVE_STRENGTH_Pos (4UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_254_PIN_CONTROL_2: DRIVE_STRENGTH (Bit 4) */
#define GPIO_PIN_CONTROL_2_INST_GPIO_254_PIN_CONTROL_2_DRIVE_STRENGTH_Msk (0x30UL) /*!< GPIO_PIN_CONTROL_2_INST GPIO_254_PIN_CONTROL_2: DRIVE_STRENGTH (Bitfield-Mask: 0x03) */


/* ================================================================================ */
/* ================        struct 'WDT_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ----------------------------  WDT_INST_WDT_CONTROL  ---------------------------- */
#define WDT_INST_WDT_CONTROL_WDT_ENABLE_Pos   (0UL)                     /*!< WDT_INST WDT_CONTROL: WDT_ENABLE (Bit 0)                    */
#define WDT_INST_WDT_CONTROL_WDT_ENABLE_Msk   (0x1UL)                   /*!< WDT_INST WDT_CONTROL: WDT_ENABLE (Bitfield-Mask: 0x01)      */
#define WDT_INST_WDT_CONTROL_WDT_STATUS_Pos   (1UL)                     /*!< WDT_INST WDT_CONTROL: WDT_STATUS (Bit 1)                    */
#define WDT_INST_WDT_CONTROL_WDT_STATUS_Msk   (0x2UL)                   /*!< WDT_INST WDT_CONTROL: WDT_STATUS (Bitfield-Mask: 0x01)      */
#define WDT_INST_WDT_CONTROL_HIBERNATION_TIMER0_STALL_Pos (2UL)         /*!< WDT_INST WDT_CONTROL: HIBERNATION_TIMER0_STALL (Bit 2)      */
#define WDT_INST_WDT_CONTROL_HIBERNATION_TIMER0_STALL_Msk (0x4UL)       /*!< WDT_INST WDT_CONTROL: HIBERNATION_TIMER0_STALL (Bitfield-Mask: 0x01) */
#define WDT_INST_WDT_CONTROL_WEEK_TIMER_STALL_Pos (3UL)                 /*!< WDT_INST WDT_CONTROL: WEEK_TIMER_STALL (Bit 3)              */
#define WDT_INST_WDT_CONTROL_WEEK_TIMER_STALL_Msk (0x8UL)               /*!< WDT_INST WDT_CONTROL: WEEK_TIMER_STALL (Bitfield-Mask: 0x01) */
#define WDT_INST_WDT_CONTROL_JTAG_STALL_Pos   (4UL)                     /*!< WDT_INST WDT_CONTROL: JTAG_STALL (Bit 4)                    */
#define WDT_INST_WDT_CONTROL_JTAG_STALL_Msk   (0x10UL)                  /*!< WDT_INST WDT_CONTROL: JTAG_STALL (Bitfield-Mask: 0x01)      */


/* ================================================================================ */
/* ================      struct 'TIMER0_INST' Position & Mask      ================ */
/* ================================================================================ */


/* -----------------------------  TIMER0_INST_STATUS  ----------------------------- */
#define TIMER0_INST_STATUS_EVENT_INTERRUPT_Pos (0UL)                    /*!< TIMER0_INST STATUS: EVENT_INTERRUPT (Bit 0)                 */
#define TIMER0_INST_STATUS_EVENT_INTERRUPT_Msk (0x1UL)                  /*!< TIMER0_INST STATUS: EVENT_INTERRUPT (Bitfield-Mask: 0x01)   */

/* -----------------------------  TIMER0_INST_INT_EN  ----------------------------- */
#define TIMER0_INST_INT_EN_ENABLE_Pos         (0UL)                     /*!< TIMER0_INST INT_EN: ENABLE (Bit 0)                          */
#define TIMER0_INST_INT_EN_ENABLE_Msk         (0x1UL)                   /*!< TIMER0_INST INT_EN: ENABLE (Bitfield-Mask: 0x01)            */

/* -----------------------------  TIMER0_INST_CONTROL  ---------------------------- */
#define TIMER0_INST_CONTROL_ENABLE_Pos        (0UL)                     /*!< TIMER0_INST CONTROL: ENABLE (Bit 0)                         */
#define TIMER0_INST_CONTROL_ENABLE_Msk        (0x1UL)                   /*!< TIMER0_INST CONTROL: ENABLE (Bitfield-Mask: 0x01)           */
#define TIMER0_INST_CONTROL_COUNT_UP_Pos      (2UL)                     /*!< TIMER0_INST CONTROL: COUNT_UP (Bit 2)                       */
#define TIMER0_INST_CONTROL_COUNT_UP_Msk      (0x4UL)                   /*!< TIMER0_INST CONTROL: COUNT_UP (Bitfield-Mask: 0x01)         */
#define TIMER0_INST_CONTROL_AUTO_RESTART_Pos  (3UL)                     /*!< TIMER0_INST CONTROL: AUTO_RESTART (Bit 3)                   */
#define TIMER0_INST_CONTROL_AUTO_RESTART_Msk  (0x8UL)                   /*!< TIMER0_INST CONTROL: AUTO_RESTART (Bitfield-Mask: 0x01)     */
#define TIMER0_INST_CONTROL_SOFT_RESET_Pos    (4UL)                     /*!< TIMER0_INST CONTROL: SOFT_RESET (Bit 4)                     */
#define TIMER0_INST_CONTROL_SOFT_RESET_Msk    (0x10UL)                  /*!< TIMER0_INST CONTROL: SOFT_RESET (Bitfield-Mask: 0x01)       */
#define TIMER0_INST_CONTROL_START_Pos         (5UL)                     /*!< TIMER0_INST CONTROL: START (Bit 5)                          */
#define TIMER0_INST_CONTROL_START_Msk         (0x20UL)                  /*!< TIMER0_INST CONTROL: START (Bitfield-Mask: 0x01)            */
#define TIMER0_INST_CONTROL_RELOAD_Pos        (6UL)                     /*!< TIMER0_INST CONTROL: RELOAD (Bit 6)                         */
#define TIMER0_INST_CONTROL_RELOAD_Msk        (0x40UL)                  /*!< TIMER0_INST CONTROL: RELOAD (Bitfield-Mask: 0x01)           */
#define TIMER0_INST_CONTROL_HALT_Pos          (7UL)                     /*!< TIMER0_INST CONTROL: HALT (Bit 7)                           */
#define TIMER0_INST_CONTROL_HALT_Msk          (0x80UL)                  /*!< TIMER0_INST CONTROL: HALT (Bitfield-Mask: 0x01)             */
#define TIMER0_INST_CONTROL_PRE_SCALE_Pos     (16UL)                    /*!< TIMER0_INST CONTROL: PRE_SCALE (Bit 16)                     */
#define TIMER0_INST_CONTROL_PRE_SCALE_Msk     (0xffff0000UL)            /*!< TIMER0_INST CONTROL: PRE_SCALE (Bitfield-Mask: 0xffff)      */


/* ================================================================================ */
/* ================      struct 'TIMER1_INST' Position & Mask      ================ */
/* ================================================================================ */


/* -----------------------------  TIMER1_INST_STATUS  ----------------------------- */
#define TIMER1_INST_STATUS_EVENT_INTERRUPT_Pos (0UL)                    /*!< TIMER1_INST STATUS: EVENT_INTERRUPT (Bit 0)                 */
#define TIMER1_INST_STATUS_EVENT_INTERRUPT_Msk (0x1UL)                  /*!< TIMER1_INST STATUS: EVENT_INTERRUPT (Bitfield-Mask: 0x01)   */

/* -----------------------------  TIMER1_INST_INT_EN  ----------------------------- */
#define TIMER1_INST_INT_EN_ENABLE_Pos         (0UL)                     /*!< TIMER1_INST INT_EN: ENABLE (Bit 0)                          */
#define TIMER1_INST_INT_EN_ENABLE_Msk         (0x1UL)                   /*!< TIMER1_INST INT_EN: ENABLE (Bitfield-Mask: 0x01)            */

/* -----------------------------  TIMER1_INST_CONTROL  ---------------------------- */
#define TIMER1_INST_CONTROL_ENABLE_Pos        (0UL)                     /*!< TIMER1_INST CONTROL: ENABLE (Bit 0)                         */
#define TIMER1_INST_CONTROL_ENABLE_Msk        (0x1UL)                   /*!< TIMER1_INST CONTROL: ENABLE (Bitfield-Mask: 0x01)           */
#define TIMER1_INST_CONTROL_COUNT_UP_Pos      (2UL)                     /*!< TIMER1_INST CONTROL: COUNT_UP (Bit 2)                       */
#define TIMER1_INST_CONTROL_COUNT_UP_Msk      (0x4UL)                   /*!< TIMER1_INST CONTROL: COUNT_UP (Bitfield-Mask: 0x01)         */
#define TIMER1_INST_CONTROL_AUTO_RESTART_Pos  (3UL)                     /*!< TIMER1_INST CONTROL: AUTO_RESTART (Bit 3)                   */
#define TIMER1_INST_CONTROL_AUTO_RESTART_Msk  (0x8UL)                   /*!< TIMER1_INST CONTROL: AUTO_RESTART (Bitfield-Mask: 0x01)     */
#define TIMER1_INST_CONTROL_SOFT_RESET_Pos    (4UL)                     /*!< TIMER1_INST CONTROL: SOFT_RESET (Bit 4)                     */
#define TIMER1_INST_CONTROL_SOFT_RESET_Msk    (0x10UL)                  /*!< TIMER1_INST CONTROL: SOFT_RESET (Bitfield-Mask: 0x01)       */
#define TIMER1_INST_CONTROL_START_Pos         (5UL)                     /*!< TIMER1_INST CONTROL: START (Bit 5)                          */
#define TIMER1_INST_CONTROL_START_Msk         (0x20UL)                  /*!< TIMER1_INST CONTROL: START (Bitfield-Mask: 0x01)            */
#define TIMER1_INST_CONTROL_RELOAD_Pos        (6UL)                     /*!< TIMER1_INST CONTROL: RELOAD (Bit 6)                         */
#define TIMER1_INST_CONTROL_RELOAD_Msk        (0x40UL)                  /*!< TIMER1_INST CONTROL: RELOAD (Bitfield-Mask: 0x01)           */
#define TIMER1_INST_CONTROL_HALT_Pos          (7UL)                     /*!< TIMER1_INST CONTROL: HALT (Bit 7)                           */
#define TIMER1_INST_CONTROL_HALT_Msk          (0x80UL)                  /*!< TIMER1_INST CONTROL: HALT (Bitfield-Mask: 0x01)             */
#define TIMER1_INST_CONTROL_PRE_SCALE_Pos     (16UL)                    /*!< TIMER1_INST CONTROL: PRE_SCALE (Bit 16)                     */
#define TIMER1_INST_CONTROL_PRE_SCALE_Msk     (0xffff0000UL)            /*!< TIMER1_INST CONTROL: PRE_SCALE (Bitfield-Mask: 0xffff)      */


/* ================================================================================ */
/* ================      struct 'TIMER2_INST' Position & Mask      ================ */
/* ================================================================================ */


/* -----------------------------  TIMER2_INST_STATUS  ----------------------------- */
#define TIMER2_INST_STATUS_EVENT_INTERRUPT_Pos (0UL)                    /*!< TIMER2_INST STATUS: EVENT_INTERRUPT (Bit 0)                 */
#define TIMER2_INST_STATUS_EVENT_INTERRUPT_Msk (0x1UL)                  /*!< TIMER2_INST STATUS: EVENT_INTERRUPT (Bitfield-Mask: 0x01)   */

/* -----------------------------  TIMER2_INST_INT_EN  ----------------------------- */
#define TIMER2_INST_INT_EN_ENABLE_Pos         (0UL)                     /*!< TIMER2_INST INT_EN: ENABLE (Bit 0)                          */
#define TIMER2_INST_INT_EN_ENABLE_Msk         (0x1UL)                   /*!< TIMER2_INST INT_EN: ENABLE (Bitfield-Mask: 0x01)            */

/* -----------------------------  TIMER2_INST_CONTROL  ---------------------------- */
#define TIMER2_INST_CONTROL_ENABLE_Pos        (0UL)                     /*!< TIMER2_INST CONTROL: ENABLE (Bit 0)                         */
#define TIMER2_INST_CONTROL_ENABLE_Msk        (0x1UL)                   /*!< TIMER2_INST CONTROL: ENABLE (Bitfield-Mask: 0x01)           */
#define TIMER2_INST_CONTROL_COUNT_UP_Pos      (2UL)                     /*!< TIMER2_INST CONTROL: COUNT_UP (Bit 2)                       */
#define TIMER2_INST_CONTROL_COUNT_UP_Msk      (0x4UL)                   /*!< TIMER2_INST CONTROL: COUNT_UP (Bitfield-Mask: 0x01)         */
#define TIMER2_INST_CONTROL_AUTO_RESTART_Pos  (3UL)                     /*!< TIMER2_INST CONTROL: AUTO_RESTART (Bit 3)                   */
#define TIMER2_INST_CONTROL_AUTO_RESTART_Msk  (0x8UL)                   /*!< TIMER2_INST CONTROL: AUTO_RESTART (Bitfield-Mask: 0x01)     */
#define TIMER2_INST_CONTROL_SOFT_RESET_Pos    (4UL)                     /*!< TIMER2_INST CONTROL: SOFT_RESET (Bit 4)                     */
#define TIMER2_INST_CONTROL_SOFT_RESET_Msk    (0x10UL)                  /*!< TIMER2_INST CONTROL: SOFT_RESET (Bitfield-Mask: 0x01)       */
#define TIMER2_INST_CONTROL_START_Pos         (5UL)                     /*!< TIMER2_INST CONTROL: START (Bit 5)                          */
#define TIMER2_INST_CONTROL_START_Msk         (0x20UL)                  /*!< TIMER2_INST CONTROL: START (Bitfield-Mask: 0x01)            */
#define TIMER2_INST_CONTROL_RELOAD_Pos        (6UL)                     /*!< TIMER2_INST CONTROL: RELOAD (Bit 6)                         */
#define TIMER2_INST_CONTROL_RELOAD_Msk        (0x40UL)                  /*!< TIMER2_INST CONTROL: RELOAD (Bitfield-Mask: 0x01)           */
#define TIMER2_INST_CONTROL_HALT_Pos          (7UL)                     /*!< TIMER2_INST CONTROL: HALT (Bit 7)                           */
#define TIMER2_INST_CONTROL_HALT_Msk          (0x80UL)                  /*!< TIMER2_INST CONTROL: HALT (Bitfield-Mask: 0x01)             */
#define TIMER2_INST_CONTROL_PRE_SCALE_Pos     (16UL)                    /*!< TIMER2_INST CONTROL: PRE_SCALE (Bit 16)                     */
#define TIMER2_INST_CONTROL_PRE_SCALE_Msk     (0xffff0000UL)            /*!< TIMER2_INST CONTROL: PRE_SCALE (Bitfield-Mask: 0xffff)      */


/* ================================================================================ */
/* ================      struct 'TIMER3_INST' Position & Mask      ================ */
/* ================================================================================ */


/* -----------------------------  TIMER3_INST_STATUS  ----------------------------- */
#define TIMER3_INST_STATUS_EVENT_INTERRUPT_Pos (0UL)                    /*!< TIMER3_INST STATUS: EVENT_INTERRUPT (Bit 0)                 */
#define TIMER3_INST_STATUS_EVENT_INTERRUPT_Msk (0x1UL)                  /*!< TIMER3_INST STATUS: EVENT_INTERRUPT (Bitfield-Mask: 0x01)   */

/* -----------------------------  TIMER3_INST_INT_EN  ----------------------------- */
#define TIMER3_INST_INT_EN_ENABLE_Pos         (0UL)                     /*!< TIMER3_INST INT_EN: ENABLE (Bit 0)                          */
#define TIMER3_INST_INT_EN_ENABLE_Msk         (0x1UL)                   /*!< TIMER3_INST INT_EN: ENABLE (Bitfield-Mask: 0x01)            */

/* -----------------------------  TIMER3_INST_CONTROL  ---------------------------- */
#define TIMER3_INST_CONTROL_ENABLE_Pos        (0UL)                     /*!< TIMER3_INST CONTROL: ENABLE (Bit 0)                         */
#define TIMER3_INST_CONTROL_ENABLE_Msk        (0x1UL)                   /*!< TIMER3_INST CONTROL: ENABLE (Bitfield-Mask: 0x01)           */
#define TIMER3_INST_CONTROL_COUNT_UP_Pos      (2UL)                     /*!< TIMER3_INST CONTROL: COUNT_UP (Bit 2)                       */
#define TIMER3_INST_CONTROL_COUNT_UP_Msk      (0x4UL)                   /*!< TIMER3_INST CONTROL: COUNT_UP (Bitfield-Mask: 0x01)         */
#define TIMER3_INST_CONTROL_AUTO_RESTART_Pos  (3UL)                     /*!< TIMER3_INST CONTROL: AUTO_RESTART (Bit 3)                   */
#define TIMER3_INST_CONTROL_AUTO_RESTART_Msk  (0x8UL)                   /*!< TIMER3_INST CONTROL: AUTO_RESTART (Bitfield-Mask: 0x01)     */
#define TIMER3_INST_CONTROL_SOFT_RESET_Pos    (4UL)                     /*!< TIMER3_INST CONTROL: SOFT_RESET (Bit 4)                     */
#define TIMER3_INST_CONTROL_SOFT_RESET_Msk    (0x10UL)                  /*!< TIMER3_INST CONTROL: SOFT_RESET (Bitfield-Mask: 0x01)       */
#define TIMER3_INST_CONTROL_START_Pos         (5UL)                     /*!< TIMER3_INST CONTROL: START (Bit 5)                          */
#define TIMER3_INST_CONTROL_START_Msk         (0x20UL)                  /*!< TIMER3_INST CONTROL: START (Bitfield-Mask: 0x01)            */
#define TIMER3_INST_CONTROL_RELOAD_Pos        (6UL)                     /*!< TIMER3_INST CONTROL: RELOAD (Bit 6)                         */
#define TIMER3_INST_CONTROL_RELOAD_Msk        (0x40UL)                  /*!< TIMER3_INST CONTROL: RELOAD (Bitfield-Mask: 0x01)           */
#define TIMER3_INST_CONTROL_HALT_Pos          (7UL)                     /*!< TIMER3_INST CONTROL: HALT (Bit 7)                           */
#define TIMER3_INST_CONTROL_HALT_Msk          (0x80UL)                  /*!< TIMER3_INST CONTROL: HALT (Bitfield-Mask: 0x01)             */
#define TIMER3_INST_CONTROL_PRE_SCALE_Pos     (16UL)                    /*!< TIMER3_INST CONTROL: PRE_SCALE (Bit 16)                     */
#define TIMER3_INST_CONTROL_PRE_SCALE_Msk     (0xffff0000UL)            /*!< TIMER3_INST CONTROL: PRE_SCALE (Bitfield-Mask: 0xffff)      */


/* ================================================================================ */
/* ================      struct 'TIMER4_INST' Position & Mask      ================ */
/* ================================================================================ */


/* -----------------------------  TIMER4_INST_STATUS  ----------------------------- */
#define TIMER4_INST_STATUS_EVENT_INTERRUPT_Pos (0UL)                    /*!< TIMER4_INST STATUS: EVENT_INTERRUPT (Bit 0)                 */
#define TIMER4_INST_STATUS_EVENT_INTERRUPT_Msk (0x1UL)                  /*!< TIMER4_INST STATUS: EVENT_INTERRUPT (Bitfield-Mask: 0x01)   */

/* -----------------------------  TIMER4_INST_INT_EN  ----------------------------- */
#define TIMER4_INST_INT_EN_ENABLE_Pos         (0UL)                     /*!< TIMER4_INST INT_EN: ENABLE (Bit 0)                          */
#define TIMER4_INST_INT_EN_ENABLE_Msk         (0x1UL)                   /*!< TIMER4_INST INT_EN: ENABLE (Bitfield-Mask: 0x01)            */

/* -----------------------------  TIMER4_INST_CONTROL  ---------------------------- */
#define TIMER4_INST_CONTROL_ENABLE_Pos        (0UL)                     /*!< TIMER4_INST CONTROL: ENABLE (Bit 0)                         */
#define TIMER4_INST_CONTROL_ENABLE_Msk        (0x1UL)                   /*!< TIMER4_INST CONTROL: ENABLE (Bitfield-Mask: 0x01)           */
#define TIMER4_INST_CONTROL_COUNT_UP_Pos      (2UL)                     /*!< TIMER4_INST CONTROL: COUNT_UP (Bit 2)                       */
#define TIMER4_INST_CONTROL_COUNT_UP_Msk      (0x4UL)                   /*!< TIMER4_INST CONTROL: COUNT_UP (Bitfield-Mask: 0x01)         */
#define TIMER4_INST_CONTROL_AUTO_RESTART_Pos  (3UL)                     /*!< TIMER4_INST CONTROL: AUTO_RESTART (Bit 3)                   */
#define TIMER4_INST_CONTROL_AUTO_RESTART_Msk  (0x8UL)                   /*!< TIMER4_INST CONTROL: AUTO_RESTART (Bitfield-Mask: 0x01)     */
#define TIMER4_INST_CONTROL_SOFT_RESET_Pos    (4UL)                     /*!< TIMER4_INST CONTROL: SOFT_RESET (Bit 4)                     */
#define TIMER4_INST_CONTROL_SOFT_RESET_Msk    (0x10UL)                  /*!< TIMER4_INST CONTROL: SOFT_RESET (Bitfield-Mask: 0x01)       */
#define TIMER4_INST_CONTROL_START_Pos         (5UL)                     /*!< TIMER4_INST CONTROL: START (Bit 5)                          */
#define TIMER4_INST_CONTROL_START_Msk         (0x20UL)                  /*!< TIMER4_INST CONTROL: START (Bitfield-Mask: 0x01)            */
#define TIMER4_INST_CONTROL_RELOAD_Pos        (6UL)                     /*!< TIMER4_INST CONTROL: RELOAD (Bit 6)                         */
#define TIMER4_INST_CONTROL_RELOAD_Msk        (0x40UL)                  /*!< TIMER4_INST CONTROL: RELOAD (Bitfield-Mask: 0x01)           */
#define TIMER4_INST_CONTROL_HALT_Pos          (7UL)                     /*!< TIMER4_INST CONTROL: HALT (Bit 7)                           */
#define TIMER4_INST_CONTROL_HALT_Msk          (0x80UL)                  /*!< TIMER4_INST CONTROL: HALT (Bitfield-Mask: 0x01)             */
#define TIMER4_INST_CONTROL_PRE_SCALE_Pos     (16UL)                    /*!< TIMER4_INST CONTROL: PRE_SCALE (Bit 16)                     */
#define TIMER4_INST_CONTROL_PRE_SCALE_Msk     (0xffff0000UL)            /*!< TIMER4_INST CONTROL: PRE_SCALE (Bitfield-Mask: 0xffff)      */


/* ================================================================================ */
/* ================      struct 'TIMER5_INST' Position & Mask      ================ */
/* ================================================================================ */


/* -----------------------------  TIMER5_INST_STATUS  ----------------------------- */
#define TIMER5_INST_STATUS_EVENT_INTERRUPT_Pos (0UL)                    /*!< TIMER5_INST STATUS: EVENT_INTERRUPT (Bit 0)                 */
#define TIMER5_INST_STATUS_EVENT_INTERRUPT_Msk (0x1UL)                  /*!< TIMER5_INST STATUS: EVENT_INTERRUPT (Bitfield-Mask: 0x01)   */

/* -----------------------------  TIMER5_INST_INT_EN  ----------------------------- */
#define TIMER5_INST_INT_EN_ENABLE_Pos         (0UL)                     /*!< TIMER5_INST INT_EN: ENABLE (Bit 0)                          */
#define TIMER5_INST_INT_EN_ENABLE_Msk         (0x1UL)                   /*!< TIMER5_INST INT_EN: ENABLE (Bitfield-Mask: 0x01)            */

/* -----------------------------  TIMER5_INST_CONTROL  ---------------------------- */
#define TIMER5_INST_CONTROL_ENABLE_Pos        (0UL)                     /*!< TIMER5_INST CONTROL: ENABLE (Bit 0)                         */
#define TIMER5_INST_CONTROL_ENABLE_Msk        (0x1UL)                   /*!< TIMER5_INST CONTROL: ENABLE (Bitfield-Mask: 0x01)           */
#define TIMER5_INST_CONTROL_COUNT_UP_Pos      (2UL)                     /*!< TIMER5_INST CONTROL: COUNT_UP (Bit 2)                       */
#define TIMER5_INST_CONTROL_COUNT_UP_Msk      (0x4UL)                   /*!< TIMER5_INST CONTROL: COUNT_UP (Bitfield-Mask: 0x01)         */
#define TIMER5_INST_CONTROL_AUTO_RESTART_Pos  (3UL)                     /*!< TIMER5_INST CONTROL: AUTO_RESTART (Bit 3)                   */
#define TIMER5_INST_CONTROL_AUTO_RESTART_Msk  (0x8UL)                   /*!< TIMER5_INST CONTROL: AUTO_RESTART (Bitfield-Mask: 0x01)     */
#define TIMER5_INST_CONTROL_SOFT_RESET_Pos    (4UL)                     /*!< TIMER5_INST CONTROL: SOFT_RESET (Bit 4)                     */
#define TIMER5_INST_CONTROL_SOFT_RESET_Msk    (0x10UL)                  /*!< TIMER5_INST CONTROL: SOFT_RESET (Bitfield-Mask: 0x01)       */
#define TIMER5_INST_CONTROL_START_Pos         (5UL)                     /*!< TIMER5_INST CONTROL: START (Bit 5)                          */
#define TIMER5_INST_CONTROL_START_Msk         (0x20UL)                  /*!< TIMER5_INST CONTROL: START (Bitfield-Mask: 0x01)            */
#define TIMER5_INST_CONTROL_RELOAD_Pos        (6UL)                     /*!< TIMER5_INST CONTROL: RELOAD (Bit 6)                         */
#define TIMER5_INST_CONTROL_RELOAD_Msk        (0x40UL)                  /*!< TIMER5_INST CONTROL: RELOAD (Bitfield-Mask: 0x01)           */
#define TIMER5_INST_CONTROL_HALT_Pos          (7UL)                     /*!< TIMER5_INST CONTROL: HALT (Bit 7)                           */
#define TIMER5_INST_CONTROL_HALT_Msk          (0x80UL)                  /*!< TIMER5_INST CONTROL: HALT (Bitfield-Mask: 0x01)             */
#define TIMER5_INST_CONTROL_PRE_SCALE_Pos     (16UL)                    /*!< TIMER5_INST CONTROL: PRE_SCALE (Bit 16)                     */
#define TIMER5_INST_CONTROL_PRE_SCALE_Msk     (0xffff0000UL)            /*!< TIMER5_INST CONTROL: PRE_SCALE (Bitfield-Mask: 0xffff)      */


/* ================================================================================ */
/* ================  struct 'COUNTER_TIMER0_INST' Position & Mask  ================ */
/* ================================================================================ */


/* ---------------------  COUNTER_TIMER0_INST_TIMERX_CONTROL  --------------------- */
#define COUNTER_TIMER0_INST_TIMERX_CONTROL_ENABLE_Pos (0UL)             /*!< COUNTER_TIMER0_INST TIMERX_CONTROL: ENABLE (Bit 0)          */
#define COUNTER_TIMER0_INST_TIMERX_CONTROL_ENABLE_Msk (0x1UL)           /*!< COUNTER_TIMER0_INST TIMERX_CONTROL: ENABLE (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER0_INST_TIMERX_CONTROL_RESET_Pos (1UL)              /*!< COUNTER_TIMER0_INST TIMERX_CONTROL: RESET (Bit 1)           */
#define COUNTER_TIMER0_INST_TIMERX_CONTROL_RESET_Msk (0x2UL)            /*!< COUNTER_TIMER0_INST TIMERX_CONTROL: RESET (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER0_INST_TIMERX_CONTROL_MODE_Pos (2UL)               /*!< COUNTER_TIMER0_INST TIMERX_CONTROL: MODE (Bit 2)            */
#define COUNTER_TIMER0_INST_TIMERX_CONTROL_MODE_Msk (0xcUL)             /*!< COUNTER_TIMER0_INST TIMERX_CONTROL: MODE (Bitfield-Mask: 0x03) */
#define COUNTER_TIMER0_INST_TIMERX_CONTROL_INPOL_Pos (4UL)              /*!< COUNTER_TIMER0_INST TIMERX_CONTROL: INPOL (Bit 4)           */
#define COUNTER_TIMER0_INST_TIMERX_CONTROL_INPOL_Msk (0x10UL)           /*!< COUNTER_TIMER0_INST TIMERX_CONTROL: INPOL (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER0_INST_TIMERX_CONTROL_UPDN_Pos (5UL)               /*!< COUNTER_TIMER0_INST TIMERX_CONTROL: UPDN (Bit 5)            */
#define COUNTER_TIMER0_INST_TIMERX_CONTROL_UPDN_Msk (0x20UL)            /*!< COUNTER_TIMER0_INST TIMERX_CONTROL: UPDN (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER0_INST_TIMERX_CONTROL_TOUT_EN_Pos (6UL)            /*!< COUNTER_TIMER0_INST TIMERX_CONTROL: TOUT_EN (Bit 6)         */
#define COUNTER_TIMER0_INST_TIMERX_CONTROL_TOUT_EN_Msk (0x40UL)         /*!< COUNTER_TIMER0_INST TIMERX_CONTROL: TOUT_EN (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER0_INST_TIMERX_CONTROL_RLOAD_Pos (7UL)              /*!< COUNTER_TIMER0_INST TIMERX_CONTROL: RLOAD (Bit 7)           */
#define COUNTER_TIMER0_INST_TIMERX_CONTROL_RLOAD_Msk (0x80UL)           /*!< COUNTER_TIMER0_INST TIMERX_CONTROL: RLOAD (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER0_INST_TIMERX_CONTROL_FILTER_BYPASS_Pos (8UL)      /*!< COUNTER_TIMER0_INST TIMERX_CONTROL: FILTER_BYPASS (Bit 8)   */
#define COUNTER_TIMER0_INST_TIMERX_CONTROL_FILTER_BYPASS_Msk (0x100UL)  /*!< COUNTER_TIMER0_INST TIMERX_CONTROL: FILTER_BYPASS (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER0_INST_TIMERX_CONTROL_PD_Pos (9UL)                 /*!< COUNTER_TIMER0_INST TIMERX_CONTROL: PD (Bit 9)              */
#define COUNTER_TIMER0_INST_TIMERX_CONTROL_PD_Msk (0x200UL)             /*!< COUNTER_TIMER0_INST TIMERX_CONTROL: PD (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER0_INST_TIMERX_CONTROL_TOUT_POLARITY_Pos (10UL)     /*!< COUNTER_TIMER0_INST TIMERX_CONTROL: TOUT_POLARITY (Bit 10)  */
#define COUNTER_TIMER0_INST_TIMERX_CONTROL_TOUT_POLARITY_Msk (0x400UL)  /*!< COUNTER_TIMER0_INST TIMERX_CONTROL: TOUT_POLARITY (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER0_INST_TIMERX_CONTROL_SLEEP_ENABLE_Pos (11UL)      /*!< COUNTER_TIMER0_INST TIMERX_CONTROL: SLEEP_ENABLE (Bit 11)   */
#define COUNTER_TIMER0_INST_TIMERX_CONTROL_SLEEP_ENABLE_Msk (0x800UL)   /*!< COUNTER_TIMER0_INST TIMERX_CONTROL: SLEEP_ENABLE (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER0_INST_TIMERX_CONTROL_TIMERX_CLK_REQ_Pos (12UL)    /*!< COUNTER_TIMER0_INST TIMERX_CONTROL: TIMERX_CLK_REQ (Bit 12) */
#define COUNTER_TIMER0_INST_TIMERX_CONTROL_TIMERX_CLK_REQ_Msk (0x1000UL) /*!< COUNTER_TIMER0_INST TIMERX_CONTROL: TIMERX_CLK_REQ (Bitfield-Mask: 0x01) */

/* -------------------------  COUNTER_TIMER0_INST_PRELOAD  ------------------------ */
#define COUNTER_TIMER0_INST_PRELOAD_TCLK_Pos  (0UL)                     /*!< COUNTER_TIMER0_INST PRELOAD: TCLK (Bit 0)                   */
#define COUNTER_TIMER0_INST_PRELOAD_TCLK_Msk  (0xfUL)                   /*!< COUNTER_TIMER0_INST PRELOAD: TCLK (Bitfield-Mask: 0x0f)     */
#define COUNTER_TIMER0_INST_PRELOAD_EDGE_Pos  (5UL)                     /*!< COUNTER_TIMER0_INST PRELOAD: EDGE (Bit 5)                   */
#define COUNTER_TIMER0_INST_PRELOAD_EDGE_Msk  (0x60UL)                  /*!< COUNTER_TIMER0_INST PRELOAD: EDGE (Bitfield-Mask: 0x03)     */
#define COUNTER_TIMER0_INST_PRELOAD_EVENT_Pos (7UL)                     /*!< COUNTER_TIMER0_INST PRELOAD: EVENT (Bit 7)                  */
#define COUNTER_TIMER0_INST_PRELOAD_EVENT_Msk (0x80UL)                  /*!< COUNTER_TIMER0_INST PRELOAD: EVENT (Bitfield-Mask: 0x01)    */
#define COUNTER_TIMER0_INST_PRELOAD_FCLK_Pos  (8UL)                     /*!< COUNTER_TIMER0_INST PRELOAD: FCLK (Bit 8)                   */
#define COUNTER_TIMER0_INST_PRELOAD_FCLK_Msk  (0xf00UL)                 /*!< COUNTER_TIMER0_INST PRELOAD: FCLK (Bitfield-Mask: 0x0f)     */

/* ----------------------  COUNTER_TIMER0_INST_TIMERX_RELOAD  --------------------- */
#define COUNTER_TIMER0_INST_TIMERX_RELOAD_TIMER_RELOAD_Pos (0UL)        /*!< COUNTER_TIMER0_INST TIMERX_RELOAD: TIMER_RELOAD (Bit 0)     */
#define COUNTER_TIMER0_INST_TIMERX_RELOAD_TIMER_RELOAD_Msk (0xffffUL)   /*!< COUNTER_TIMER0_INST TIMERX_RELOAD: TIMER_RELOAD (Bitfield-Mask: 0xffff) */

/* ----------------------  COUNTER_TIMER0_INST_TIMERX_COUNT  ---------------------- */
#define COUNTER_TIMER0_INST_TIMERX_COUNT_TIMER_COUNT_Pos (0UL)          /*!< COUNTER_TIMER0_INST TIMERX_COUNT: TIMER_COUNT (Bit 0)       */
#define COUNTER_TIMER0_INST_TIMERX_COUNT_TIMER_COUNT_Msk (0xffffUL)     /*!< COUNTER_TIMER0_INST TIMERX_COUNT: TIMER_COUNT (Bitfield-Mask: 0xffff) */


/* ================================================================================ */
/* ================  struct 'COUNTER_TIMER1_INST' Position & Mask  ================ */
/* ================================================================================ */


/* ---------------------  COUNTER_TIMER1_INST_TIMERX_CONTROL  --------------------- */
#define COUNTER_TIMER1_INST_TIMERX_CONTROL_ENABLE_Pos (0UL)             /*!< COUNTER_TIMER1_INST TIMERX_CONTROL: ENABLE (Bit 0)          */
#define COUNTER_TIMER1_INST_TIMERX_CONTROL_ENABLE_Msk (0x1UL)           /*!< COUNTER_TIMER1_INST TIMERX_CONTROL: ENABLE (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER1_INST_TIMERX_CONTROL_RESET_Pos (1UL)              /*!< COUNTER_TIMER1_INST TIMERX_CONTROL: RESET (Bit 1)           */
#define COUNTER_TIMER1_INST_TIMERX_CONTROL_RESET_Msk (0x2UL)            /*!< COUNTER_TIMER1_INST TIMERX_CONTROL: RESET (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER1_INST_TIMERX_CONTROL_MODE_Pos (2UL)               /*!< COUNTER_TIMER1_INST TIMERX_CONTROL: MODE (Bit 2)            */
#define COUNTER_TIMER1_INST_TIMERX_CONTROL_MODE_Msk (0xcUL)             /*!< COUNTER_TIMER1_INST TIMERX_CONTROL: MODE (Bitfield-Mask: 0x03) */
#define COUNTER_TIMER1_INST_TIMERX_CONTROL_INPOL_Pos (4UL)              /*!< COUNTER_TIMER1_INST TIMERX_CONTROL: INPOL (Bit 4)           */
#define COUNTER_TIMER1_INST_TIMERX_CONTROL_INPOL_Msk (0x10UL)           /*!< COUNTER_TIMER1_INST TIMERX_CONTROL: INPOL (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER1_INST_TIMERX_CONTROL_UPDN_Pos (5UL)               /*!< COUNTER_TIMER1_INST TIMERX_CONTROL: UPDN (Bit 5)            */
#define COUNTER_TIMER1_INST_TIMERX_CONTROL_UPDN_Msk (0x20UL)            /*!< COUNTER_TIMER1_INST TIMERX_CONTROL: UPDN (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER1_INST_TIMERX_CONTROL_TOUT_EN_Pos (6UL)            /*!< COUNTER_TIMER1_INST TIMERX_CONTROL: TOUT_EN (Bit 6)         */
#define COUNTER_TIMER1_INST_TIMERX_CONTROL_TOUT_EN_Msk (0x40UL)         /*!< COUNTER_TIMER1_INST TIMERX_CONTROL: TOUT_EN (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER1_INST_TIMERX_CONTROL_RLOAD_Pos (7UL)              /*!< COUNTER_TIMER1_INST TIMERX_CONTROL: RLOAD (Bit 7)           */
#define COUNTER_TIMER1_INST_TIMERX_CONTROL_RLOAD_Msk (0x80UL)           /*!< COUNTER_TIMER1_INST TIMERX_CONTROL: RLOAD (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER1_INST_TIMERX_CONTROL_FILTER_BYPASS_Pos (8UL)      /*!< COUNTER_TIMER1_INST TIMERX_CONTROL: FILTER_BYPASS (Bit 8)   */
#define COUNTER_TIMER1_INST_TIMERX_CONTROL_FILTER_BYPASS_Msk (0x100UL)  /*!< COUNTER_TIMER1_INST TIMERX_CONTROL: FILTER_BYPASS (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER1_INST_TIMERX_CONTROL_PD_Pos (9UL)                 /*!< COUNTER_TIMER1_INST TIMERX_CONTROL: PD (Bit 9)              */
#define COUNTER_TIMER1_INST_TIMERX_CONTROL_PD_Msk (0x200UL)             /*!< COUNTER_TIMER1_INST TIMERX_CONTROL: PD (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER1_INST_TIMERX_CONTROL_TOUT_POLARITY_Pos (10UL)     /*!< COUNTER_TIMER1_INST TIMERX_CONTROL: TOUT_POLARITY (Bit 10)  */
#define COUNTER_TIMER1_INST_TIMERX_CONTROL_TOUT_POLARITY_Msk (0x400UL)  /*!< COUNTER_TIMER1_INST TIMERX_CONTROL: TOUT_POLARITY (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER1_INST_TIMERX_CONTROL_SLEEP_ENABLE_Pos (11UL)      /*!< COUNTER_TIMER1_INST TIMERX_CONTROL: SLEEP_ENABLE (Bit 11)   */
#define COUNTER_TIMER1_INST_TIMERX_CONTROL_SLEEP_ENABLE_Msk (0x800UL)   /*!< COUNTER_TIMER1_INST TIMERX_CONTROL: SLEEP_ENABLE (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER1_INST_TIMERX_CONTROL_TIMERX_CLK_REQ_Pos (12UL)    /*!< COUNTER_TIMER1_INST TIMERX_CONTROL: TIMERX_CLK_REQ (Bit 12) */
#define COUNTER_TIMER1_INST_TIMERX_CONTROL_TIMERX_CLK_REQ_Msk (0x1000UL) /*!< COUNTER_TIMER1_INST TIMERX_CONTROL: TIMERX_CLK_REQ (Bitfield-Mask: 0x01) */

/* -------------------------  COUNTER_TIMER1_INST_PRELOAD  ------------------------ */
#define COUNTER_TIMER1_INST_PRELOAD_TCLK_Pos  (0UL)                     /*!< COUNTER_TIMER1_INST PRELOAD: TCLK (Bit 0)                   */
#define COUNTER_TIMER1_INST_PRELOAD_TCLK_Msk  (0xfUL)                   /*!< COUNTER_TIMER1_INST PRELOAD: TCLK (Bitfield-Mask: 0x0f)     */
#define COUNTER_TIMER1_INST_PRELOAD_EDGE_Pos  (5UL)                     /*!< COUNTER_TIMER1_INST PRELOAD: EDGE (Bit 5)                   */
#define COUNTER_TIMER1_INST_PRELOAD_EDGE_Msk  (0x60UL)                  /*!< COUNTER_TIMER1_INST PRELOAD: EDGE (Bitfield-Mask: 0x03)     */
#define COUNTER_TIMER1_INST_PRELOAD_EVENT_Pos (7UL)                     /*!< COUNTER_TIMER1_INST PRELOAD: EVENT (Bit 7)                  */
#define COUNTER_TIMER1_INST_PRELOAD_EVENT_Msk (0x80UL)                  /*!< COUNTER_TIMER1_INST PRELOAD: EVENT (Bitfield-Mask: 0x01)    */
#define COUNTER_TIMER1_INST_PRELOAD_FCLK_Pos  (8UL)                     /*!< COUNTER_TIMER1_INST PRELOAD: FCLK (Bit 8)                   */
#define COUNTER_TIMER1_INST_PRELOAD_FCLK_Msk  (0xf00UL)                 /*!< COUNTER_TIMER1_INST PRELOAD: FCLK (Bitfield-Mask: 0x0f)     */

/* ----------------------  COUNTER_TIMER1_INST_TIMERX_RELOAD  --------------------- */
#define COUNTER_TIMER1_INST_TIMERX_RELOAD_TIMER_RELOAD_Pos (0UL)        /*!< COUNTER_TIMER1_INST TIMERX_RELOAD: TIMER_RELOAD (Bit 0)     */
#define COUNTER_TIMER1_INST_TIMERX_RELOAD_TIMER_RELOAD_Msk (0xffffUL)   /*!< COUNTER_TIMER1_INST TIMERX_RELOAD: TIMER_RELOAD (Bitfield-Mask: 0xffff) */

/* ----------------------  COUNTER_TIMER1_INST_TIMERX_COUNT  ---------------------- */
#define COUNTER_TIMER1_INST_TIMERX_COUNT_TIMER_COUNT_Pos (0UL)          /*!< COUNTER_TIMER1_INST TIMERX_COUNT: TIMER_COUNT (Bit 0)       */
#define COUNTER_TIMER1_INST_TIMERX_COUNT_TIMER_COUNT_Msk (0xffffUL)     /*!< COUNTER_TIMER1_INST TIMERX_COUNT: TIMER_COUNT (Bitfield-Mask: 0xffff) */


/* ================================================================================ */
/* ================  struct 'COUNTER_TIMER2_INST' Position & Mask  ================ */
/* ================================================================================ */


/* ---------------------  COUNTER_TIMER2_INST_TIMERX_CONTROL  --------------------- */
#define COUNTER_TIMER2_INST_TIMERX_CONTROL_ENABLE_Pos (0UL)             /*!< COUNTER_TIMER2_INST TIMERX_CONTROL: ENABLE (Bit 0)          */
#define COUNTER_TIMER2_INST_TIMERX_CONTROL_ENABLE_Msk (0x1UL)           /*!< COUNTER_TIMER2_INST TIMERX_CONTROL: ENABLE (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER2_INST_TIMERX_CONTROL_RESET_Pos (1UL)              /*!< COUNTER_TIMER2_INST TIMERX_CONTROL: RESET (Bit 1)           */
#define COUNTER_TIMER2_INST_TIMERX_CONTROL_RESET_Msk (0x2UL)            /*!< COUNTER_TIMER2_INST TIMERX_CONTROL: RESET (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER2_INST_TIMERX_CONTROL_MODE_Pos (2UL)               /*!< COUNTER_TIMER2_INST TIMERX_CONTROL: MODE (Bit 2)            */
#define COUNTER_TIMER2_INST_TIMERX_CONTROL_MODE_Msk (0xcUL)             /*!< COUNTER_TIMER2_INST TIMERX_CONTROL: MODE (Bitfield-Mask: 0x03) */
#define COUNTER_TIMER2_INST_TIMERX_CONTROL_INPOL_Pos (4UL)              /*!< COUNTER_TIMER2_INST TIMERX_CONTROL: INPOL (Bit 4)           */
#define COUNTER_TIMER2_INST_TIMERX_CONTROL_INPOL_Msk (0x10UL)           /*!< COUNTER_TIMER2_INST TIMERX_CONTROL: INPOL (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER2_INST_TIMERX_CONTROL_UPDN_Pos (5UL)               /*!< COUNTER_TIMER2_INST TIMERX_CONTROL: UPDN (Bit 5)            */
#define COUNTER_TIMER2_INST_TIMERX_CONTROL_UPDN_Msk (0x20UL)            /*!< COUNTER_TIMER2_INST TIMERX_CONTROL: UPDN (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER2_INST_TIMERX_CONTROL_TOUT_EN_Pos (6UL)            /*!< COUNTER_TIMER2_INST TIMERX_CONTROL: TOUT_EN (Bit 6)         */
#define COUNTER_TIMER2_INST_TIMERX_CONTROL_TOUT_EN_Msk (0x40UL)         /*!< COUNTER_TIMER2_INST TIMERX_CONTROL: TOUT_EN (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER2_INST_TIMERX_CONTROL_RLOAD_Pos (7UL)              /*!< COUNTER_TIMER2_INST TIMERX_CONTROL: RLOAD (Bit 7)           */
#define COUNTER_TIMER2_INST_TIMERX_CONTROL_RLOAD_Msk (0x80UL)           /*!< COUNTER_TIMER2_INST TIMERX_CONTROL: RLOAD (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER2_INST_TIMERX_CONTROL_FILTER_BYPASS_Pos (8UL)      /*!< COUNTER_TIMER2_INST TIMERX_CONTROL: FILTER_BYPASS (Bit 8)   */
#define COUNTER_TIMER2_INST_TIMERX_CONTROL_FILTER_BYPASS_Msk (0x100UL)  /*!< COUNTER_TIMER2_INST TIMERX_CONTROL: FILTER_BYPASS (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER2_INST_TIMERX_CONTROL_PD_Pos (9UL)                 /*!< COUNTER_TIMER2_INST TIMERX_CONTROL: PD (Bit 9)              */
#define COUNTER_TIMER2_INST_TIMERX_CONTROL_PD_Msk (0x200UL)             /*!< COUNTER_TIMER2_INST TIMERX_CONTROL: PD (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER2_INST_TIMERX_CONTROL_TOUT_POLARITY_Pos (10UL)     /*!< COUNTER_TIMER2_INST TIMERX_CONTROL: TOUT_POLARITY (Bit 10)  */
#define COUNTER_TIMER2_INST_TIMERX_CONTROL_TOUT_POLARITY_Msk (0x400UL)  /*!< COUNTER_TIMER2_INST TIMERX_CONTROL: TOUT_POLARITY (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER2_INST_TIMERX_CONTROL_SLEEP_ENABLE_Pos (11UL)      /*!< COUNTER_TIMER2_INST TIMERX_CONTROL: SLEEP_ENABLE (Bit 11)   */
#define COUNTER_TIMER2_INST_TIMERX_CONTROL_SLEEP_ENABLE_Msk (0x800UL)   /*!< COUNTER_TIMER2_INST TIMERX_CONTROL: SLEEP_ENABLE (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER2_INST_TIMERX_CONTROL_TIMERX_CLK_REQ_Pos (12UL)    /*!< COUNTER_TIMER2_INST TIMERX_CONTROL: TIMERX_CLK_REQ (Bit 12) */
#define COUNTER_TIMER2_INST_TIMERX_CONTROL_TIMERX_CLK_REQ_Msk (0x1000UL) /*!< COUNTER_TIMER2_INST TIMERX_CONTROL: TIMERX_CLK_REQ (Bitfield-Mask: 0x01) */

/* -------------------------  COUNTER_TIMER2_INST_PRELOAD  ------------------------ */
#define COUNTER_TIMER2_INST_PRELOAD_TCLK_Pos  (0UL)                     /*!< COUNTER_TIMER2_INST PRELOAD: TCLK (Bit 0)                   */
#define COUNTER_TIMER2_INST_PRELOAD_TCLK_Msk  (0xfUL)                   /*!< COUNTER_TIMER2_INST PRELOAD: TCLK (Bitfield-Mask: 0x0f)     */
#define COUNTER_TIMER2_INST_PRELOAD_EDGE_Pos  (5UL)                     /*!< COUNTER_TIMER2_INST PRELOAD: EDGE (Bit 5)                   */
#define COUNTER_TIMER2_INST_PRELOAD_EDGE_Msk  (0x60UL)                  /*!< COUNTER_TIMER2_INST PRELOAD: EDGE (Bitfield-Mask: 0x03)     */
#define COUNTER_TIMER2_INST_PRELOAD_EVENT_Pos (7UL)                     /*!< COUNTER_TIMER2_INST PRELOAD: EVENT (Bit 7)                  */
#define COUNTER_TIMER2_INST_PRELOAD_EVENT_Msk (0x80UL)                  /*!< COUNTER_TIMER2_INST PRELOAD: EVENT (Bitfield-Mask: 0x01)    */
#define COUNTER_TIMER2_INST_PRELOAD_FCLK_Pos  (8UL)                     /*!< COUNTER_TIMER2_INST PRELOAD: FCLK (Bit 8)                   */
#define COUNTER_TIMER2_INST_PRELOAD_FCLK_Msk  (0xf00UL)                 /*!< COUNTER_TIMER2_INST PRELOAD: FCLK (Bitfield-Mask: 0x0f)     */

/* ----------------------  COUNTER_TIMER2_INST_TIMERX_RELOAD  --------------------- */
#define COUNTER_TIMER2_INST_TIMERX_RELOAD_TIMER_RELOAD_Pos (0UL)        /*!< COUNTER_TIMER2_INST TIMERX_RELOAD: TIMER_RELOAD (Bit 0)     */
#define COUNTER_TIMER2_INST_TIMERX_RELOAD_TIMER_RELOAD_Msk (0xffffUL)   /*!< COUNTER_TIMER2_INST TIMERX_RELOAD: TIMER_RELOAD (Bitfield-Mask: 0xffff) */

/* ----------------------  COUNTER_TIMER2_INST_TIMERX_COUNT  ---------------------- */
#define COUNTER_TIMER2_INST_TIMERX_COUNT_TIMER_COUNT_Pos (0UL)          /*!< COUNTER_TIMER2_INST TIMERX_COUNT: TIMER_COUNT (Bit 0)       */
#define COUNTER_TIMER2_INST_TIMERX_COUNT_TIMER_COUNT_Msk (0xffffUL)     /*!< COUNTER_TIMER2_INST TIMERX_COUNT: TIMER_COUNT (Bitfield-Mask: 0xffff) */


/* ================================================================================ */
/* ================  struct 'COUNTER_TIMER3_INST' Position & Mask  ================ */
/* ================================================================================ */


/* ---------------------  COUNTER_TIMER3_INST_TIMERX_CONTROL  --------------------- */
#define COUNTER_TIMER3_INST_TIMERX_CONTROL_ENABLE_Pos (0UL)             /*!< COUNTER_TIMER3_INST TIMERX_CONTROL: ENABLE (Bit 0)          */
#define COUNTER_TIMER3_INST_TIMERX_CONTROL_ENABLE_Msk (0x1UL)           /*!< COUNTER_TIMER3_INST TIMERX_CONTROL: ENABLE (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER3_INST_TIMERX_CONTROL_RESET_Pos (1UL)              /*!< COUNTER_TIMER3_INST TIMERX_CONTROL: RESET (Bit 1)           */
#define COUNTER_TIMER3_INST_TIMERX_CONTROL_RESET_Msk (0x2UL)            /*!< COUNTER_TIMER3_INST TIMERX_CONTROL: RESET (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER3_INST_TIMERX_CONTROL_MODE_Pos (2UL)               /*!< COUNTER_TIMER3_INST TIMERX_CONTROL: MODE (Bit 2)            */
#define COUNTER_TIMER3_INST_TIMERX_CONTROL_MODE_Msk (0xcUL)             /*!< COUNTER_TIMER3_INST TIMERX_CONTROL: MODE (Bitfield-Mask: 0x03) */
#define COUNTER_TIMER3_INST_TIMERX_CONTROL_INPOL_Pos (4UL)              /*!< COUNTER_TIMER3_INST TIMERX_CONTROL: INPOL (Bit 4)           */
#define COUNTER_TIMER3_INST_TIMERX_CONTROL_INPOL_Msk (0x10UL)           /*!< COUNTER_TIMER3_INST TIMERX_CONTROL: INPOL (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER3_INST_TIMERX_CONTROL_UPDN_Pos (5UL)               /*!< COUNTER_TIMER3_INST TIMERX_CONTROL: UPDN (Bit 5)            */
#define COUNTER_TIMER3_INST_TIMERX_CONTROL_UPDN_Msk (0x20UL)            /*!< COUNTER_TIMER3_INST TIMERX_CONTROL: UPDN (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER3_INST_TIMERX_CONTROL_TOUT_EN_Pos (6UL)            /*!< COUNTER_TIMER3_INST TIMERX_CONTROL: TOUT_EN (Bit 6)         */
#define COUNTER_TIMER3_INST_TIMERX_CONTROL_TOUT_EN_Msk (0x40UL)         /*!< COUNTER_TIMER3_INST TIMERX_CONTROL: TOUT_EN (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER3_INST_TIMERX_CONTROL_RLOAD_Pos (7UL)              /*!< COUNTER_TIMER3_INST TIMERX_CONTROL: RLOAD (Bit 7)           */
#define COUNTER_TIMER3_INST_TIMERX_CONTROL_RLOAD_Msk (0x80UL)           /*!< COUNTER_TIMER3_INST TIMERX_CONTROL: RLOAD (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER3_INST_TIMERX_CONTROL_FILTER_BYPASS_Pos (8UL)      /*!< COUNTER_TIMER3_INST TIMERX_CONTROL: FILTER_BYPASS (Bit 8)   */
#define COUNTER_TIMER3_INST_TIMERX_CONTROL_FILTER_BYPASS_Msk (0x100UL)  /*!< COUNTER_TIMER3_INST TIMERX_CONTROL: FILTER_BYPASS (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER3_INST_TIMERX_CONTROL_PD_Pos (9UL)                 /*!< COUNTER_TIMER3_INST TIMERX_CONTROL: PD (Bit 9)              */
#define COUNTER_TIMER3_INST_TIMERX_CONTROL_PD_Msk (0x200UL)             /*!< COUNTER_TIMER3_INST TIMERX_CONTROL: PD (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER3_INST_TIMERX_CONTROL_TOUT_POLARITY_Pos (10UL)     /*!< COUNTER_TIMER3_INST TIMERX_CONTROL: TOUT_POLARITY (Bit 10)  */
#define COUNTER_TIMER3_INST_TIMERX_CONTROL_TOUT_POLARITY_Msk (0x400UL)  /*!< COUNTER_TIMER3_INST TIMERX_CONTROL: TOUT_POLARITY (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER3_INST_TIMERX_CONTROL_SLEEP_ENABLE_Pos (11UL)      /*!< COUNTER_TIMER3_INST TIMERX_CONTROL: SLEEP_ENABLE (Bit 11)   */
#define COUNTER_TIMER3_INST_TIMERX_CONTROL_SLEEP_ENABLE_Msk (0x800UL)   /*!< COUNTER_TIMER3_INST TIMERX_CONTROL: SLEEP_ENABLE (Bitfield-Mask: 0x01) */
#define COUNTER_TIMER3_INST_TIMERX_CONTROL_TIMERX_CLK_REQ_Pos (12UL)    /*!< COUNTER_TIMER3_INST TIMERX_CONTROL: TIMERX_CLK_REQ (Bit 12) */
#define COUNTER_TIMER3_INST_TIMERX_CONTROL_TIMERX_CLK_REQ_Msk (0x1000UL) /*!< COUNTER_TIMER3_INST TIMERX_CONTROL: TIMERX_CLK_REQ (Bitfield-Mask: 0x01) */

/* -------------------------  COUNTER_TIMER3_INST_PRELOAD  ------------------------ */
#define COUNTER_TIMER3_INST_PRELOAD_TCLK_Pos  (0UL)                     /*!< COUNTER_TIMER3_INST PRELOAD: TCLK (Bit 0)                   */
#define COUNTER_TIMER3_INST_PRELOAD_TCLK_Msk  (0xfUL)                   /*!< COUNTER_TIMER3_INST PRELOAD: TCLK (Bitfield-Mask: 0x0f)     */
#define COUNTER_TIMER3_INST_PRELOAD_EDGE_Pos  (5UL)                     /*!< COUNTER_TIMER3_INST PRELOAD: EDGE (Bit 5)                   */
#define COUNTER_TIMER3_INST_PRELOAD_EDGE_Msk  (0x60UL)                  /*!< COUNTER_TIMER3_INST PRELOAD: EDGE (Bitfield-Mask: 0x03)     */
#define COUNTER_TIMER3_INST_PRELOAD_EVENT_Pos (7UL)                     /*!< COUNTER_TIMER3_INST PRELOAD: EVENT (Bit 7)                  */
#define COUNTER_TIMER3_INST_PRELOAD_EVENT_Msk (0x80UL)                  /*!< COUNTER_TIMER3_INST PRELOAD: EVENT (Bitfield-Mask: 0x01)    */
#define COUNTER_TIMER3_INST_PRELOAD_FCLK_Pos  (8UL)                     /*!< COUNTER_TIMER3_INST PRELOAD: FCLK (Bit 8)                   */
#define COUNTER_TIMER3_INST_PRELOAD_FCLK_Msk  (0xf00UL)                 /*!< COUNTER_TIMER3_INST PRELOAD: FCLK (Bitfield-Mask: 0x0f)     */

/* ----------------------  COUNTER_TIMER3_INST_TIMERX_RELOAD  --------------------- */
#define COUNTER_TIMER3_INST_TIMERX_RELOAD_TIMER_RELOAD_Pos (0UL)        /*!< COUNTER_TIMER3_INST TIMERX_RELOAD: TIMER_RELOAD (Bit 0)     */
#define COUNTER_TIMER3_INST_TIMERX_RELOAD_TIMER_RELOAD_Msk (0xffffUL)   /*!< COUNTER_TIMER3_INST TIMERX_RELOAD: TIMER_RELOAD (Bitfield-Mask: 0xffff) */

/* ----------------------  COUNTER_TIMER3_INST_TIMERX_COUNT  ---------------------- */
#define COUNTER_TIMER3_INST_TIMERX_COUNT_TIMER_COUNT_Pos (0UL)          /*!< COUNTER_TIMER3_INST TIMERX_COUNT: TIMER_COUNT (Bit 0)       */
#define COUNTER_TIMER3_INST_TIMERX_COUNT_TIMER_COUNT_Msk (0xffffUL)     /*!< COUNTER_TIMER3_INST TIMERX_COUNT: TIMER_COUNT (Bitfield-Mask: 0xffff) */


/* ================================================================================ */
/* ================struct 'CAPTURE_COMPARE_TIMER_INST' Position & Mask================ */
/* ================================================================================ */


/* ----------------CAPTURE_COMPARE_TIMER_INST_CAPTURE_COMPARE_TIMER_CONTROL---------------- */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_COMPARE_TIMER_CONTROL_ACTIVATE_Pos (0UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_COMPARE_TIMER_CONTROL: ACTIVATE (Bit 0) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_COMPARE_TIMER_CONTROL_ACTIVATE_Msk (0x1UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_COMPARE_TIMER_CONTROL: ACTIVATE (Bitfield-Mask: 0x01) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_COMPARE_TIMER_CONTROL_FREE_ENABLE_Pos (1UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_COMPARE_TIMER_CONTROL: FREE_ENABLE (Bit 1) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_COMPARE_TIMER_CONTROL_FREE_ENABLE_Msk (0x2UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_COMPARE_TIMER_CONTROL: FREE_ENABLE (Bitfield-Mask: 0x01) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_COMPARE_TIMER_CONTROL_FREE_RESET_Pos (2UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_COMPARE_TIMER_CONTROL: FREE_RESET (Bit 2) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_COMPARE_TIMER_CONTROL_FREE_RESET_Msk (0x4UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_COMPARE_TIMER_CONTROL: FREE_RESET (Bitfield-Mask: 0x01) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_COMPARE_TIMER_CONTROL_TCLK_Pos (4UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_COMPARE_TIMER_CONTROL: TCLK (Bit 4) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_COMPARE_TIMER_CONTROL_TCLK_Msk (0x70UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_COMPARE_TIMER_CONTROL: TCLK (Bitfield-Mask: 0x07) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_COMPARE_TIMER_CONTROL_COMPARE_ENABLE0_Pos (8UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_COMPARE_TIMER_CONTROL: COMPARE_ENABLE0 (Bit 8) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_COMPARE_TIMER_CONTROL_COMPARE_ENABLE0_Msk (0x100UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_COMPARE_TIMER_CONTROL: COMPARE_ENABLE0 (Bitfield-Mask: 0x01) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_COMPARE_TIMER_CONTROL_COMPARE_ENABLE1_Pos (9UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_COMPARE_TIMER_CONTROL: COMPARE_ENABLE1 (Bit 9) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_COMPARE_TIMER_CONTROL_COMPARE_ENABLE1_Msk (0x200UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_COMPARE_TIMER_CONTROL: COMPARE_ENABLE1 (Bitfield-Mask: 0x01) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_COMPARE_TIMER_CONTROL_COMPARE_SET1_Pos (16UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_COMPARE_TIMER_CONTROL: COMPARE_SET1 (Bit 16) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_COMPARE_TIMER_CONTROL_COMPARE_SET1_Msk (0x10000UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_COMPARE_TIMER_CONTROL: COMPARE_SET1 (Bitfield-Mask: 0x01) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_COMPARE_TIMER_CONTROL_COMPARE_SET0_Pos (17UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_COMPARE_TIMER_CONTROL: COMPARE_SET0 (Bit 17) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_COMPARE_TIMER_CONTROL_COMPARE_SET0_Msk (0x20000UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_COMPARE_TIMER_CONTROL: COMPARE_SET0 (Bitfield-Mask: 0x01) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_COMPARE_TIMER_CONTROL_COMPARE_CLEAR1_Pos (24UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_COMPARE_TIMER_CONTROL: COMPARE_CLEAR1 (Bit 24) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_COMPARE_TIMER_CONTROL_COMPARE_CLEAR1_Msk (0x1000000UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_COMPARE_TIMER_CONTROL: COMPARE_CLEAR1 (Bitfield-Mask: 0x01) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_COMPARE_TIMER_CONTROL_COMPARE_CLEAR0_Pos (25UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_COMPARE_TIMER_CONTROL: COMPARE_CLEAR0 (Bit 25) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_COMPARE_TIMER_CONTROL_COMPARE_CLEAR0_Msk (0x2000000UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_COMPARE_TIMER_CONTROL: COMPARE_CLEAR0 (Bitfield-Mask: 0x01) */

/* ----------------  CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_0  ---------------- */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_0_CAPTURE_EDGE0_Pos (0UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_0: CAPTURE_EDGE0 (Bit 0) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_0_CAPTURE_EDGE0_Msk (0x3UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_0: CAPTURE_EDGE0 (Bitfield-Mask: 0x03) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_0_FILTER_BYP0_Pos (2UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_0: FILTER_BYP0 (Bit 2) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_0_FILTER_BYP0_Msk (0x4UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_0: FILTER_BYP0 (Bitfield-Mask: 0x01) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_0_FCLK_SEL0_Pos (5UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_0: FCLK_SEL0 (Bit 5) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_0_FCLK_SEL0_Msk (0xe0UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_0: FCLK_SEL0 (Bitfield-Mask: 0x07) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_0_CAPTURE_EDGE1_Pos (8UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_0: CAPTURE_EDGE1 (Bit 8) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_0_CAPTURE_EDGE1_Msk (0x300UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_0: CAPTURE_EDGE1 (Bitfield-Mask: 0x03) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_0_FILTER_BYP1_Pos (10UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_0: FILTER_BYP1 (Bit 10) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_0_FILTER_BYP1_Msk (0x400UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_0: FILTER_BYP1 (Bitfield-Mask: 0x01) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_0_FCLK_SEL1_Pos (13UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_0: FCLK_SEL1 (Bit 13) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_0_FCLK_SEL1_Msk (0xe000UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_0: FCLK_SEL1 (Bitfield-Mask: 0x07) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_0_CAPTURE_EDGE2_Pos (16UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_0: CAPTURE_EDGE2 (Bit 16) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_0_CAPTURE_EDGE2_Msk (0x30000UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_0: CAPTURE_EDGE2 (Bitfield-Mask: 0x03) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_0_FILTER_BYP2_Pos (18UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_0: FILTER_BYP2 (Bit 18) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_0_FILTER_BYP2_Msk (0x40000UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_0: FILTER_BYP2 (Bitfield-Mask: 0x01) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_0_FCLK_SEL2_Pos (21UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_0: FCLK_SEL2 (Bit 21) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_0_FCLK_SEL2_Msk (0xe00000UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_0: FCLK_SEL2 (Bitfield-Mask: 0x07) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_0_CAPTURE_EDGE3_Pos (24UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_0: CAPTURE_EDGE3 (Bit 24) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_0_CAPTURE_EDGE3_Msk (0x3000000UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_0: CAPTURE_EDGE3 (Bitfield-Mask: 0x03) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_0_FILTER_BYP3_Pos (26UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_0: FILTER_BYP3 (Bit 26) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_0_FILTER_BYP3_Msk (0x4000000UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_0: FILTER_BYP3 (Bitfield-Mask: 0x01) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_0_FCLK_SEL3_Pos (29UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_0: FCLK_SEL3 (Bit 29) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_0_FCLK_SEL3_Msk (0xe0000000UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_0: FCLK_SEL3 (Bitfield-Mask: 0x07) */

/* ----------------  CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_1  ---------------- */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_1_CAPTURE_EDGE4_Pos (0UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_1: CAPTURE_EDGE4 (Bit 0) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_1_CAPTURE_EDGE4_Msk (0x3UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_1: CAPTURE_EDGE4 (Bitfield-Mask: 0x03) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_1_FILTER_BYP4_Pos (2UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_1: FILTER_BYP4 (Bit 2) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_1_FILTER_BYP4_Msk (0x4UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_1: FILTER_BYP4 (Bitfield-Mask: 0x01) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_1_FCLK_SEL4_Pos (5UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_1: FCLK_SEL4 (Bit 5) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_1_FCLK_SEL4_Msk (0xe0UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_1: FCLK_SEL4 (Bitfield-Mask: 0x07) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_1_CAPTURE_EDGE5_Pos (8UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_1: CAPTURE_EDGE5 (Bit 8) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_1_CAPTURE_EDGE5_Msk (0x300UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_1: CAPTURE_EDGE5 (Bitfield-Mask: 0x03) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_1_FILTER_BYP5_Pos (10UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_1: FILTER_BYP5 (Bit 10) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_1_FILTER_BYP5_Msk (0x400UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_1: FILTER_BYP5 (Bitfield-Mask: 0x01) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_1_FCLK_SEL5_Pos (13UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_1: FCLK_SEL5 (Bit 13) */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_CONTROL_1_FCLK_SEL5_Msk (0xe000UL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_CONTROL_1: FCLK_SEL5 (Bitfield-Mask: 0x07) */

/* ----------------  CAPTURE_COMPARE_TIMER_INST_FREE_RUNNING_TIMER ---------------- */
#define CAPTURE_COMPARE_TIMER_INST_FREE_RUNNING_TIMER_FREE_RUNNING_TIMER_Pos (0UL) /*!< CAPTURE_COMPARE_TIMER_INST FREE_RUNNING_TIMER: FREE_RUNNING_TIMER (Bit 0) */
#define CAPTURE_COMPARE_TIMER_INST_FREE_RUNNING_TIMER_FREE_RUNNING_TIMER_Msk (0xffffffffUL) /*!< CAPTURE_COMPARE_TIMER_INST FREE_RUNNING_TIMER: FREE_RUNNING_TIMER (Bitfield-Mask: 0xffffffff) */

/* --------------------  CAPTURE_COMPARE_TIMER_INST_CAPTURE_0  -------------------- */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_0_CAPTURE_0_Pos (0UL)        /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_0: CAPTURE_0 (Bit 0)     */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_0_CAPTURE_0_Msk (0xffffffffUL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_0: CAPTURE_0 (Bitfield-Mask: 0xffffffff) */

/* --------------------  CAPTURE_COMPARE_TIMER_INST_CAPTURE_1  -------------------- */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_1_CAPTURE_1_Pos (0UL)        /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_1: CAPTURE_1 (Bit 0)     */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_1_CAPTURE_1_Msk (0xffffffffUL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_1: CAPTURE_1 (Bitfield-Mask: 0xffffffff) */

/* --------------------  CAPTURE_COMPARE_TIMER_INST_CAPTURE_2  -------------------- */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_2_CAPTURE_2_Pos (0UL)        /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_2: CAPTURE_2 (Bit 0)     */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_2_CAPTURE_2_Msk (0xffffffffUL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_2: CAPTURE_2 (Bitfield-Mask: 0xffffffff) */

/* --------------------  CAPTURE_COMPARE_TIMER_INST_CAPTURE_3  -------------------- */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_3_CAPTURE_3_Pos (0UL)        /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_3: CAPTURE_3 (Bit 0)     */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_3_CAPTURE_3_Msk (0xffffffffUL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_3: CAPTURE_3 (Bitfield-Mask: 0xffffffff) */

/* --------------------  CAPTURE_COMPARE_TIMER_INST_CAPTURE_4  -------------------- */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_4_CAPTURE_4_Pos (0UL)        /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_4: CAPTURE_4 (Bit 0)     */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_4_CAPTURE_4_Msk (0xffffffffUL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_4: CAPTURE_4 (Bitfield-Mask: 0xffffffff) */

/* --------------------  CAPTURE_COMPARE_TIMER_INST_CAPTURE_5  -------------------- */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_5_CAPTURE_5_Pos (0UL)        /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_5: CAPTURE_5 (Bit 0)     */
#define CAPTURE_COMPARE_TIMER_INST_CAPTURE_5_CAPTURE_5_Msk (0xffffffffUL) /*!< CAPTURE_COMPARE_TIMER_INST CAPTURE_5: CAPTURE_5 (Bitfield-Mask: 0xffffffff) */

/* --------------------  CAPTURE_COMPARE_TIMER_INST_COMPARE_0  -------------------- */
#define CAPTURE_COMPARE_TIMER_INST_COMPARE_0_COMPARE_0_Pos (0UL)        /*!< CAPTURE_COMPARE_TIMER_INST COMPARE_0: COMPARE_0 (Bit 0)     */
#define CAPTURE_COMPARE_TIMER_INST_COMPARE_0_COMPARE_0_Msk (0xffffffffUL) /*!< CAPTURE_COMPARE_TIMER_INST COMPARE_0: COMPARE_0 (Bitfield-Mask: 0xffffffff) */

/* --------------------  CAPTURE_COMPARE_TIMER_INST_COMPARE_1  -------------------- */
#define CAPTURE_COMPARE_TIMER_INST_COMPARE_1_COMPARE_1_Pos (0UL)        /*!< CAPTURE_COMPARE_TIMER_INST COMPARE_1: COMPARE_1 (Bit 0)     */
#define CAPTURE_COMPARE_TIMER_INST_COMPARE_1_COMPARE_1_Msk (0xffffffffUL) /*!< CAPTURE_COMPARE_TIMER_INST COMPARE_1: COMPARE_1 (Bitfield-Mask: 0xffffffff) */


/* ================================================================================ */
/* ================       struct 'HTM0_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ----------------------------  HTM0_INST_HT_CONTROL  ---------------------------- */
#define HTM0_INST_HT_CONTROL_CTRL_Pos         (0UL)                     /*!< HTM0_INST HT_CONTROL: CTRL (Bit 0)                          */
#define HTM0_INST_HT_CONTROL_CTRL_Msk         (0x1UL)                   /*!< HTM0_INST HT_CONTROL: CTRL (Bitfield-Mask: 0x01)            */


/* ================================================================================ */
/* ================       struct 'HTM1_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ----------------------------  HTM1_INST_HT_CONTROL  ---------------------------- */
#define HTM1_INST_HT_CONTROL_CTRL_Pos         (0UL)                     /*!< HTM1_INST HT_CONTROL: CTRL (Bit 0)                          */
#define HTM1_INST_HT_CONTROL_CTRL_Msk         (0x1UL)                   /*!< HTM1_INST HT_CONTROL: CTRL (Bitfield-Mask: 0x01)            */


/* ================================================================================ */
/* ================       struct 'RTOS_INST' Position & Mask       ================ */
/* ================================================================================ */


/* -------------------------  RTOS_INST_RTOS_TIMER_COUNT  ------------------------- */
#define RTOS_INST_RTOS_TIMER_COUNT_COUNTER_Pos (0UL)                    /*!< RTOS_INST RTOS_TIMER_COUNT: COUNTER (Bit 0)                 */
#define RTOS_INST_RTOS_TIMER_COUNT_COUNTER_Msk (0xffffffffUL)           /*!< RTOS_INST RTOS_TIMER_COUNT: COUNTER (Bitfield-Mask: 0xffffffff) */

/* ------------------------  RTOS_INST_RTOS_TIMER_PRELOAD  ------------------------ */
#define RTOS_INST_RTOS_TIMER_PRELOAD_PRE_LOAD_Pos (0UL)                 /*!< RTOS_INST RTOS_TIMER_PRELOAD: PRE_LOAD (Bit 0)              */
#define RTOS_INST_RTOS_TIMER_PRELOAD_PRE_LOAD_Msk (0xffffffffUL)        /*!< RTOS_INST RTOS_TIMER_PRELOAD: PRE_LOAD (Bitfield-Mask: 0xffffffff) */

/* ------------------------  RTOS_INST_RTOS_TIMER_CONTROL  ------------------------ */
#define RTOS_INST_RTOS_TIMER_CONTROL_BLOCK_ENABLE_Pos (0UL)             /*!< RTOS_INST RTOS_TIMER_CONTROL: BLOCK_ENABLE (Bit 0)          */
#define RTOS_INST_RTOS_TIMER_CONTROL_BLOCK_ENABLE_Msk (0x1UL)           /*!< RTOS_INST RTOS_TIMER_CONTROL: BLOCK_ENABLE (Bitfield-Mask: 0x01) */
#define RTOS_INST_RTOS_TIMER_CONTROL_AUTO_RELOAD_Pos (1UL)              /*!< RTOS_INST RTOS_TIMER_CONTROL: AUTO_RELOAD (Bit 1)           */
#define RTOS_INST_RTOS_TIMER_CONTROL_AUTO_RELOAD_Msk (0x2UL)            /*!< RTOS_INST RTOS_TIMER_CONTROL: AUTO_RELOAD (Bitfield-Mask: 0x01) */
#define RTOS_INST_RTOS_TIMER_CONTROL_TIMER_START_Pos (2UL)              /*!< RTOS_INST RTOS_TIMER_CONTROL: TIMER_START (Bit 2)           */
#define RTOS_INST_RTOS_TIMER_CONTROL_TIMER_START_Msk (0x4UL)            /*!< RTOS_INST RTOS_TIMER_CONTROL: TIMER_START (Bitfield-Mask: 0x01) */
#define RTOS_INST_RTOS_TIMER_CONTROL_EXT_HARDWARE_HALT_EN_Pos (3UL)     /*!< RTOS_INST RTOS_TIMER_CONTROL: EXT_HARDWARE_HALT_EN (Bit 3)  */
#define RTOS_INST_RTOS_TIMER_CONTROL_EXT_HARDWARE_HALT_EN_Msk (0x8UL)   /*!< RTOS_INST RTOS_TIMER_CONTROL: EXT_HARDWARE_HALT_EN (Bitfield-Mask: 0x01) */
#define RTOS_INST_RTOS_TIMER_CONTROL_FIRMWARE_TIMER_HALT_Pos (4UL)      /*!< RTOS_INST RTOS_TIMER_CONTROL: FIRMWARE_TIMER_HALT (Bit 4)   */
#define RTOS_INST_RTOS_TIMER_CONTROL_FIRMWARE_TIMER_HALT_Msk (0x10UL)   /*!< RTOS_INST RTOS_TIMER_CONTROL: FIRMWARE_TIMER_HALT (Bitfield-Mask: 0x01) */

/* --------------------------  RTOS_INST_SOFT_INTERRUPT  -------------------------- */
#define RTOS_INST_SOFT_INTERRUPT_SWI_0_Pos    (0UL)                     /*!< RTOS_INST SOFT_INTERRUPT: SWI_0 (Bit 0)                     */
#define RTOS_INST_SOFT_INTERRUPT_SWI_0_Msk    (0x1UL)                   /*!< RTOS_INST SOFT_INTERRUPT: SWI_0 (Bitfield-Mask: 0x01)       */
#define RTOS_INST_SOFT_INTERRUPT_SWI_1_Pos    (1UL)                     /*!< RTOS_INST SOFT_INTERRUPT: SWI_1 (Bit 1)                     */
#define RTOS_INST_SOFT_INTERRUPT_SWI_1_Msk    (0x2UL)                   /*!< RTOS_INST SOFT_INTERRUPT: SWI_1 (Bitfield-Mask: 0x01)       */
#define RTOS_INST_SOFT_INTERRUPT_SWI_2_Pos    (2UL)                     /*!< RTOS_INST SOFT_INTERRUPT: SWI_2 (Bit 2)                     */
#define RTOS_INST_SOFT_INTERRUPT_SWI_2_Msk    (0x4UL)                   /*!< RTOS_INST SOFT_INTERRUPT: SWI_2 (Bitfield-Mask: 0x01)       */
#define RTOS_INST_SOFT_INTERRUPT_SWI_3_Pos    (3UL)                     /*!< RTOS_INST SOFT_INTERRUPT: SWI_3 (Bit 3)                     */
#define RTOS_INST_SOFT_INTERRUPT_SWI_3_Msk    (0x8UL)                   /*!< RTOS_INST SOFT_INTERRUPT: SWI_3 (Bitfield-Mask: 0x01)       */


/* ================================================================================ */
/* ================        struct 'RTC_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ------------------------------  RTC_INST_CONTROL  ------------------------------ */
#define RTC_INST_CONTROL_BLOCK_ENABLE_Pos     (0UL)                     /*!< RTC_INST CONTROL: BLOCK_ENABLE (Bit 0)                      */
#define RTC_INST_CONTROL_BLOCK_ENABLE_Msk     (0x1UL)                   /*!< RTC_INST CONTROL: BLOCK_ENABLE (Bitfield-Mask: 0x01)        */
#define RTC_INST_CONTROL_SOFT_RESET_Pos       (1UL)                     /*!< RTC_INST CONTROL: SOFT_RESET (Bit 1)                        */
#define RTC_INST_CONTROL_SOFT_RESET_Msk       (0x2UL)                   /*!< RTC_INST CONTROL: SOFT_RESET (Bitfield-Mask: 0x01)          */
#define RTC_INST_CONTROL_TEST_Pos             (2UL)                     /*!< RTC_INST CONTROL: TEST (Bit 2)                              */
#define RTC_INST_CONTROL_TEST_Msk             (0x4UL)                   /*!< RTC_INST CONTROL: TEST (Bitfield-Mask: 0x01)                */
#define RTC_INST_CONTROL_ALARM_ENABLE_Pos     (3UL)                     /*!< RTC_INST CONTROL: ALARM_ENABLE (Bit 3)                      */
#define RTC_INST_CONTROL_ALARM_ENABLE_Msk     (0x8UL)                   /*!< RTC_INST CONTROL: ALARM_ENABLE (Bitfield-Mask: 0x01)        */

/* ----------------------  RTC_INST_DAYLIGHT_SAVINGS_FORWARD  --------------------- */
#define RTC_INST_DAYLIGHT_SAVINGS_FORWARD_DST_MONTH_Pos (0UL)           /*!< RTC_INST DAYLIGHT_SAVINGS_FORWARD: DST_MONTH (Bit 0)        */
#define RTC_INST_DAYLIGHT_SAVINGS_FORWARD_DST_MONTH_Msk (0xffUL)        /*!< RTC_INST DAYLIGHT_SAVINGS_FORWARD: DST_MONTH (Bitfield-Mask: 0xff) */
#define RTC_INST_DAYLIGHT_SAVINGS_FORWARD_DST_DAY_OF_WEEK_Pos (8UL)     /*!< RTC_INST DAYLIGHT_SAVINGS_FORWARD: DST_DAY_OF_WEEK (Bit 8)  */
#define RTC_INST_DAYLIGHT_SAVINGS_FORWARD_DST_DAY_OF_WEEK_Msk (0x700UL) /*!< RTC_INST DAYLIGHT_SAVINGS_FORWARD: DST_DAY_OF_WEEK (Bitfield-Mask: 0x07) */
#define RTC_INST_DAYLIGHT_SAVINGS_FORWARD_DST_WEEK_Pos (16UL)           /*!< RTC_INST DAYLIGHT_SAVINGS_FORWARD: DST_WEEK (Bit 16)        */
#define RTC_INST_DAYLIGHT_SAVINGS_FORWARD_DST_WEEK_Msk (0x70000UL)      /*!< RTC_INST DAYLIGHT_SAVINGS_FORWARD: DST_WEEK (Bitfield-Mask: 0x07) */
#define RTC_INST_DAYLIGHT_SAVINGS_FORWARD_DST_HOUR_Pos (24UL)           /*!< RTC_INST DAYLIGHT_SAVINGS_FORWARD: DST_HOUR (Bit 24)        */
#define RTC_INST_DAYLIGHT_SAVINGS_FORWARD_DST_HOUR_Msk (0x7f000000UL)   /*!< RTC_INST DAYLIGHT_SAVINGS_FORWARD: DST_HOUR (Bitfield-Mask: 0x7f) */
#define RTC_INST_DAYLIGHT_SAVINGS_FORWARD_DST_AM_PM_Pos (31UL)          /*!< RTC_INST DAYLIGHT_SAVINGS_FORWARD: DST_AM_PM (Bit 31)       */
#define RTC_INST_DAYLIGHT_SAVINGS_FORWARD_DST_AM_PM_Msk (0x80000000UL)  /*!< RTC_INST DAYLIGHT_SAVINGS_FORWARD: DST_AM_PM (Bitfield-Mask: 0x01) */

/* ---------------------  RTC_INST_DAYLIGHT_SAVINGS_BACKWARD  --------------------- */
#define RTC_INST_DAYLIGHT_SAVINGS_BACKWARD_DST_MONTH_Pos (0UL)          /*!< RTC_INST DAYLIGHT_SAVINGS_BACKWARD: DST_MONTH (Bit 0)       */
#define RTC_INST_DAYLIGHT_SAVINGS_BACKWARD_DST_MONTH_Msk (0xffUL)       /*!< RTC_INST DAYLIGHT_SAVINGS_BACKWARD: DST_MONTH (Bitfield-Mask: 0xff) */
#define RTC_INST_DAYLIGHT_SAVINGS_BACKWARD_DST_DAY_OF_WEEK_Pos (8UL)    /*!< RTC_INST DAYLIGHT_SAVINGS_BACKWARD: DST_DAY_OF_WEEK (Bit 8) */
#define RTC_INST_DAYLIGHT_SAVINGS_BACKWARD_DST_DAY_OF_WEEK_Msk (0x700UL) /*!< RTC_INST DAYLIGHT_SAVINGS_BACKWARD: DST_DAY_OF_WEEK (Bitfield-Mask: 0x07) */
#define RTC_INST_DAYLIGHT_SAVINGS_BACKWARD_DST_WEEK_Pos (16UL)          /*!< RTC_INST DAYLIGHT_SAVINGS_BACKWARD: DST_WEEK (Bit 16)       */
#define RTC_INST_DAYLIGHT_SAVINGS_BACKWARD_DST_WEEK_Msk (0x70000UL)     /*!< RTC_INST DAYLIGHT_SAVINGS_BACKWARD: DST_WEEK (Bitfield-Mask: 0x07) */
#define RTC_INST_DAYLIGHT_SAVINGS_BACKWARD_DST_HOUR_Pos (24UL)          /*!< RTC_INST DAYLIGHT_SAVINGS_BACKWARD: DST_HOUR (Bit 24)       */
#define RTC_INST_DAYLIGHT_SAVINGS_BACKWARD_DST_HOUR_Msk (0x7f000000UL)  /*!< RTC_INST DAYLIGHT_SAVINGS_BACKWARD: DST_HOUR (Bitfield-Mask: 0x7f) */
#define RTC_INST_DAYLIGHT_SAVINGS_BACKWARD_DST_AM_PM_Pos (31UL)         /*!< RTC_INST DAYLIGHT_SAVINGS_BACKWARD: DST_AM_PM (Bit 31)      */
#define RTC_INST_DAYLIGHT_SAVINGS_BACKWARD_DST_AM_PM_Msk (0x80000000UL) /*!< RTC_INST DAYLIGHT_SAVINGS_BACKWARD: DST_AM_PM (Bitfield-Mask: 0x01) */


/* ================================================================================ */
/* ================       struct 'WEEK_INST' Position & Mask       ================ */
/* ================================================================================ */


/* -------------------------  WEEK_INST_CONTROL_REGISTER  ------------------------- */
#define WEEK_INST_CONTROL_REGISTER_WT_ENABLE_Pos (0UL)                  /*!< WEEK_INST CONTROL_REGISTER: WT_ENABLE (Bit 0)               */
#define WEEK_INST_CONTROL_REGISTER_WT_ENABLE_Msk (0x1UL)                /*!< WEEK_INST CONTROL_REGISTER: WT_ENABLE (Bitfield-Mask: 0x01) */
#define WEEK_INST_CONTROL_REGISTER_POWERUP_EN_Pos (6UL)                 /*!< WEEK_INST CONTROL_REGISTER: POWERUP_EN (Bit 6)              */
#define WEEK_INST_CONTROL_REGISTER_POWERUP_EN_Msk (0x40UL)              /*!< WEEK_INST CONTROL_REGISTER: POWERUP_EN (Bitfield-Mask: 0x01) */

/* ------------------------  WEEK_INST_WEEK_ALARM_COUNTER  ------------------------ */
#define WEEK_INST_WEEK_ALARM_COUNTER_WEEK_COUNTER_Pos (0UL)             /*!< WEEK_INST WEEK_ALARM_COUNTER: WEEK_COUNTER (Bit 0)          */
#define WEEK_INST_WEEK_ALARM_COUNTER_WEEK_COUNTER_Msk (0xfffffffUL)     /*!< WEEK_INST WEEK_ALARM_COUNTER: WEEK_COUNTER (Bitfield-Mask: 0xfffffff) */

/* ------------------------  WEEK_INST_WEEK_TIMER_COMPARE  ------------------------ */
#define WEEK_INST_WEEK_TIMER_COMPARE_WEEK_COMPARE_Pos (0UL)             /*!< WEEK_INST WEEK_TIMER_COMPARE: WEEK_COMPARE (Bit 0)          */
#define WEEK_INST_WEEK_TIMER_COMPARE_WEEK_COMPARE_Msk (0xfffffffUL)     /*!< WEEK_INST WEEK_TIMER_COMPARE: WEEK_COMPARE (Bitfield-Mask: 0xfffffff) */

/* ---------------------------  WEEK_INST_CLOCK_DIVIDER  -------------------------- */
#define WEEK_INST_CLOCK_DIVIDER_CLOCK_DIVIDER_Pos (0UL)                 /*!< WEEK_INST CLOCK_DIVIDER: CLOCK_DIVIDER (Bit 0)              */
#define WEEK_INST_CLOCK_DIVIDER_CLOCK_DIVIDER_Msk (0x7fffUL)            /*!< WEEK_INST CLOCK_DIVIDER: CLOCK_DIVIDER (Bitfield-Mask: 0x7fff) */

/* -----------------------  WEEK_INST_SUB_SECOND_INT_SELECT  ---------------------- */
#define WEEK_INST_SUB_SECOND_INT_SELECT_SPISR_Pos (0UL)                 /*!< WEEK_INST SUB_SECOND_INT_SELECT: SPISR (Bit 0)              */
#define WEEK_INST_SUB_SECOND_INT_SELECT_SPISR_Msk (0xfUL)               /*!< WEEK_INST SUB_SECOND_INT_SELECT: SPISR (Bitfield-Mask: 0x0f) */

/* -------------------------  WEEK_INST_SUB_WEEK_CONTROL  ------------------------- */
#define WEEK_INST_SUB_WEEK_CONTROL_SUBWEEK_TIMER_POWERUP_EVENT_STATUS_Pos (0UL) /*!< WEEK_INST SUB_WEEK_CONTROL: SUBWEEK_TIMER_POWERUP_EVENT_STATUS (Bit 0) */
#define WEEK_INST_SUB_WEEK_CONTROL_SUBWEEK_TIMER_POWERUP_EVENT_STATUS_Msk (0x1UL) /*!< WEEK_INST SUB_WEEK_CONTROL: SUBWEEK_TIMER_POWERUP_EVENT_STATUS (Bitfield-Mask: 0x01) */
#define WEEK_INST_SUB_WEEK_CONTROL_WEEK_TIMER_POWERUP_EVENT_STATUS_Pos (1UL) /*!< WEEK_INST SUB_WEEK_CONTROL: WEEK_TIMER_POWERUP_EVENT_STATUS (Bit 1) */
#define WEEK_INST_SUB_WEEK_CONTROL_WEEK_TIMER_POWERUP_EVENT_STATUS_Msk (0x2UL) /*!< WEEK_INST SUB_WEEK_CONTROL: WEEK_TIMER_POWERUP_EVENT_STATUS (Bitfield-Mask: 0x01) */
#define WEEK_INST_SUB_WEEK_CONTROL_TEST_Pos   (4UL)                     /*!< WEEK_INST SUB_WEEK_CONTROL: TEST (Bit 4)                    */
#define WEEK_INST_SUB_WEEK_CONTROL_TEST_Msk   (0x10UL)                  /*!< WEEK_INST SUB_WEEK_CONTROL: TEST (Bitfield-Mask: 0x01)      */
#define WEEK_INST_SUB_WEEK_CONTROL_TEST0_Pos  (5UL)                     /*!< WEEK_INST SUB_WEEK_CONTROL: TEST0 (Bit 5)                   */
#define WEEK_INST_SUB_WEEK_CONTROL_TEST0_Msk  (0x20UL)                  /*!< WEEK_INST SUB_WEEK_CONTROL: TEST0 (Bitfield-Mask: 0x01)     */
#define WEEK_INST_SUB_WEEK_CONTROL_AUTO_RELOAD_Pos (6UL)                /*!< WEEK_INST SUB_WEEK_CONTROL: AUTO_RELOAD (Bit 6)             */
#define WEEK_INST_SUB_WEEK_CONTROL_AUTO_RELOAD_Msk (0x40UL)             /*!< WEEK_INST SUB_WEEK_CONTROL: AUTO_RELOAD (Bitfield-Mask: 0x01) */
#define WEEK_INST_SUB_WEEK_CONTROL_SUBWEEK_TICK_Pos (7UL)               /*!< WEEK_INST SUB_WEEK_CONTROL: SUBWEEK_TICK (Bit 7)            */
#define WEEK_INST_SUB_WEEK_CONTROL_SUBWEEK_TICK_Msk (0x380UL)           /*!< WEEK_INST SUB_WEEK_CONTROL: SUBWEEK_TICK (Bitfield-Mask: 0x07) */

/* ----------------------  WEEK_INST_SUB_WEEK_ALARM_COUNTER  ---------------------- */
#define WEEK_INST_SUB_WEEK_ALARM_COUNTER_SUBWEEK_COUNTER_LOAD_Pos (0UL) /*!< WEEK_INST SUB_WEEK_ALARM_COUNTER: SUBWEEK_COUNTER_LOAD (Bit 0) */
#define WEEK_INST_SUB_WEEK_ALARM_COUNTER_SUBWEEK_COUNTER_LOAD_Msk (0x1ffUL) /*!< WEEK_INST SUB_WEEK_ALARM_COUNTER: SUBWEEK_COUNTER_LOAD (Bitfield-Mask: 0x1ff) */
#define WEEK_INST_SUB_WEEK_ALARM_COUNTER_SUBWEEK_COUNTER_STATUS_Pos (16UL) /*!< WEEK_INST SUB_WEEK_ALARM_COUNTER: SUBWEEK_COUNTER_STATUS (Bit 16) */
#define WEEK_INST_SUB_WEEK_ALARM_COUNTER_SUBWEEK_COUNTER_STATUS_Msk (0x1ff0000UL) /*!< WEEK_INST SUB_WEEK_ALARM_COUNTER: SUBWEEK_COUNTER_STATUS (Bitfield-Mask: 0x1ff) */

/* -----------------------------  WEEK_INST_BGPO_DATA  ---------------------------- */
#define WEEK_INST_BGPO_DATA_BGPO_Pos          (0UL)                     /*!< WEEK_INST BGPO_DATA: BGPO (Bit 0)                           */
#define WEEK_INST_BGPO_DATA_BGPO_Msk          (0x3ffUL)                 /*!< WEEK_INST BGPO_DATA: BGPO (Bitfield-Mask: 0x3ff)            */

/* ----------------------------  WEEK_INST_BGPO_POWER  ---------------------------- */
#define WEEK_INST_BGPO_POWER_BGPO_POWER_Pos   (1UL)                     /*!< WEEK_INST BGPO_POWER: BGPO_POWER (Bit 1)                    */
#define WEEK_INST_BGPO_POWER_BGPO_POWER_Msk   (0x3eUL)                  /*!< WEEK_INST BGPO_POWER: BGPO_POWER (Bitfield-Mask: 0x1f)      */

/* ----------------------------  WEEK_INST_BGPO_RESET  ---------------------------- */
#define WEEK_INST_BGPO_RESET_BGPO_RESET_Pos   (0UL)                     /*!< WEEK_INST BGPO_RESET: BGPO_RESET (Bit 0)                    */
#define WEEK_INST_BGPO_RESET_BGPO_RESET_Msk   (0x3ffUL)                 /*!< WEEK_INST BGPO_RESET: BGPO_RESET (Bitfield-Mask: 0x3ff)     */


/* ================================================================================ */
/* ================       struct 'TACH0_INST' Position & Mask      ================ */
/* ================================================================================ */


/* ---------------------------  TACH0_INST_TACH_CONTROL  -------------------------- */
#define TACH0_INST_TACH_CONTROL_TACH_OUT_OF_LIMIT_ENABLE_Pos (0UL)      /*!< TACH0_INST TACH_CONTROL: TACH_OUT_OF_LIMIT_ENABLE (Bit 0)   */
#define TACH0_INST_TACH_CONTROL_TACH_OUT_OF_LIMIT_ENABLE_Msk (0x1UL)    /*!< TACH0_INST TACH_CONTROL: TACH_OUT_OF_LIMIT_ENABLE (Bitfield-Mask: 0x01) */
#define TACH0_INST_TACH_CONTROL_TACH_ENABLE_Pos (1UL)                   /*!< TACH0_INST TACH_CONTROL: TACH_ENABLE (Bit 1)                */
#define TACH0_INST_TACH_CONTROL_TACH_ENABLE_Msk (0x2UL)                 /*!< TACH0_INST TACH_CONTROL: TACH_ENABLE (Bitfield-Mask: 0x01)  */
#define TACH0_INST_TACH_CONTROL_FILTER_ENABLE_Pos (8UL)                 /*!< TACH0_INST TACH_CONTROL: FILTER_ENABLE (Bit 8)              */
#define TACH0_INST_TACH_CONTROL_FILTER_ENABLE_Msk (0x100UL)             /*!< TACH0_INST TACH_CONTROL: FILTER_ENABLE (Bitfield-Mask: 0x01) */
#define TACH0_INST_TACH_CONTROL_TACH_READING_MODE_SELECT_Pos (10UL)     /*!< TACH0_INST TACH_CONTROL: TACH_READING_MODE_SELECT (Bit 10)  */
#define TACH0_INST_TACH_CONTROL_TACH_READING_MODE_SELECT_Msk (0x400UL)  /*!< TACH0_INST TACH_CONTROL: TACH_READING_MODE_SELECT (Bitfield-Mask: 0x01) */
#define TACH0_INST_TACH_CONTROL_TACH_EDGES_Pos (11UL)                   /*!< TACH0_INST TACH_CONTROL: TACH_EDGES (Bit 11)                */
#define TACH0_INST_TACH_CONTROL_TACH_EDGES_Msk (0x1800UL)               /*!< TACH0_INST TACH_CONTROL: TACH_EDGES (Bitfield-Mask: 0x03)   */
#define TACH0_INST_TACH_CONTROL_COUNT_READY_INT_EN_Pos (14UL)           /*!< TACH0_INST TACH_CONTROL: COUNT_READY_INT_EN (Bit 14)        */
#define TACH0_INST_TACH_CONTROL_COUNT_READY_INT_EN_Msk (0x4000UL)       /*!< TACH0_INST TACH_CONTROL: COUNT_READY_INT_EN (Bitfield-Mask: 0x01) */
#define TACH0_INST_TACH_CONTROL_TACH_INPUT_INT_EN_Pos (15UL)            /*!< TACH0_INST TACH_CONTROL: TACH_INPUT_INT_EN (Bit 15)         */
#define TACH0_INST_TACH_CONTROL_TACH_INPUT_INT_EN_Msk (0x8000UL)        /*!< TACH0_INST TACH_CONTROL: TACH_INPUT_INT_EN (Bitfield-Mask: 0x01) */
#define TACH0_INST_TACH_CONTROL_TACHX_COUNTER_Pos (16UL)                /*!< TACH0_INST TACH_CONTROL: TACHX_COUNTER (Bit 16)             */
#define TACH0_INST_TACH_CONTROL_TACHX_COUNTER_Msk (0xffff0000UL)        /*!< TACH0_INST TACH_CONTROL: TACHX_COUNTER (Bitfield-Mask: 0xffff) */

/* ---------------------------  TACH0_INST_TACHX_STATUS  -------------------------- */
#define TACH0_INST_TACHX_STATUS_TACH_OUT_OF_LIMIT_STATUS_Pos (0UL)      /*!< TACH0_INST TACHX_STATUS: TACH_OUT_OF_LIMIT_STATUS (Bit 0)   */
#define TACH0_INST_TACHX_STATUS_TACH_OUT_OF_LIMIT_STATUS_Msk (0x1UL)    /*!< TACH0_INST TACHX_STATUS: TACH_OUT_OF_LIMIT_STATUS (Bitfield-Mask: 0x01) */
#define TACH0_INST_TACHX_STATUS_TACH_PIN_STATUS_Pos (1UL)               /*!< TACH0_INST TACHX_STATUS: TACH_PIN_STATUS (Bit 1)            */
#define TACH0_INST_TACHX_STATUS_TACH_PIN_STATUS_Msk (0x2UL)             /*!< TACH0_INST TACHX_STATUS: TACH_PIN_STATUS (Bitfield-Mask: 0x01) */
#define TACH0_INST_TACHX_STATUS_TOGGLE_STATUS_Pos (2UL)                 /*!< TACH0_INST TACHX_STATUS: TOGGLE_STATUS (Bit 2)              */
#define TACH0_INST_TACHX_STATUS_TOGGLE_STATUS_Msk (0x4UL)               /*!< TACH0_INST TACHX_STATUS: TOGGLE_STATUS (Bitfield-Mask: 0x01) */
#define TACH0_INST_TACHX_STATUS_COUNT_READY_STATUS_Pos (3UL)            /*!< TACH0_INST TACHX_STATUS: COUNT_READY_STATUS (Bit 3)         */
#define TACH0_INST_TACHX_STATUS_COUNT_READY_STATUS_Msk (0x8UL)          /*!< TACH0_INST TACHX_STATUS: COUNT_READY_STATUS (Bitfield-Mask: 0x01) */

/* -------------------------  TACH0_INST_TACHX_HIGH_LIMIT  ------------------------ */
#define TACH0_INST_TACHX_HIGH_LIMIT_TACH_HIGH_LIMIT_Pos (0UL)           /*!< TACH0_INST TACHX_HIGH_LIMIT: TACH_HIGH_LIMIT (Bit 0)        */
#define TACH0_INST_TACHX_HIGH_LIMIT_TACH_HIGH_LIMIT_Msk (0xffffUL)      /*!< TACH0_INST TACHX_HIGH_LIMIT: TACH_HIGH_LIMIT (Bitfield-Mask: 0xffff) */

/* -------------------------  TACH0_INST_TACHX_LOW_LIMIT  ------------------------- */
#define TACH0_INST_TACHX_LOW_LIMIT_TACH_LOW_LIMIT_Pos (0UL)             /*!< TACH0_INST TACHX_LOW_LIMIT: TACH_LOW_LIMIT (Bit 0)          */
#define TACH0_INST_TACHX_LOW_LIMIT_TACH_LOW_LIMIT_Msk (0xffffUL)        /*!< TACH0_INST TACHX_LOW_LIMIT: TACH_LOW_LIMIT (Bitfield-Mask: 0xffff) */


/* ================================================================================ */
/* ================       struct 'TACH1_INST' Position & Mask      ================ */
/* ================================================================================ */


/* ---------------------------  TACH1_INST_TACH_CONTROL  -------------------------- */
#define TACH1_INST_TACH_CONTROL_TACH_OUT_OF_LIMIT_ENABLE_Pos (0UL)      /*!< TACH1_INST TACH_CONTROL: TACH_OUT_OF_LIMIT_ENABLE (Bit 0)   */
#define TACH1_INST_TACH_CONTROL_TACH_OUT_OF_LIMIT_ENABLE_Msk (0x1UL)    /*!< TACH1_INST TACH_CONTROL: TACH_OUT_OF_LIMIT_ENABLE (Bitfield-Mask: 0x01) */
#define TACH1_INST_TACH_CONTROL_TACH_ENABLE_Pos (1UL)                   /*!< TACH1_INST TACH_CONTROL: TACH_ENABLE (Bit 1)                */
#define TACH1_INST_TACH_CONTROL_TACH_ENABLE_Msk (0x2UL)                 /*!< TACH1_INST TACH_CONTROL: TACH_ENABLE (Bitfield-Mask: 0x01)  */
#define TACH1_INST_TACH_CONTROL_FILTER_ENABLE_Pos (8UL)                 /*!< TACH1_INST TACH_CONTROL: FILTER_ENABLE (Bit 8)              */
#define TACH1_INST_TACH_CONTROL_FILTER_ENABLE_Msk (0x100UL)             /*!< TACH1_INST TACH_CONTROL: FILTER_ENABLE (Bitfield-Mask: 0x01) */
#define TACH1_INST_TACH_CONTROL_TACH_READING_MODE_SELECT_Pos (10UL)     /*!< TACH1_INST TACH_CONTROL: TACH_READING_MODE_SELECT (Bit 10)  */
#define TACH1_INST_TACH_CONTROL_TACH_READING_MODE_SELECT_Msk (0x400UL)  /*!< TACH1_INST TACH_CONTROL: TACH_READING_MODE_SELECT (Bitfield-Mask: 0x01) */
#define TACH1_INST_TACH_CONTROL_TACH_EDGES_Pos (11UL)                   /*!< TACH1_INST TACH_CONTROL: TACH_EDGES (Bit 11)                */
#define TACH1_INST_TACH_CONTROL_TACH_EDGES_Msk (0x1800UL)               /*!< TACH1_INST TACH_CONTROL: TACH_EDGES (Bitfield-Mask: 0x03)   */
#define TACH1_INST_TACH_CONTROL_COUNT_READY_INT_EN_Pos (14UL)           /*!< TACH1_INST TACH_CONTROL: COUNT_READY_INT_EN (Bit 14)        */
#define TACH1_INST_TACH_CONTROL_COUNT_READY_INT_EN_Msk (0x4000UL)       /*!< TACH1_INST TACH_CONTROL: COUNT_READY_INT_EN (Bitfield-Mask: 0x01) */
#define TACH1_INST_TACH_CONTROL_TACH_INPUT_INT_EN_Pos (15UL)            /*!< TACH1_INST TACH_CONTROL: TACH_INPUT_INT_EN (Bit 15)         */
#define TACH1_INST_TACH_CONTROL_TACH_INPUT_INT_EN_Msk (0x8000UL)        /*!< TACH1_INST TACH_CONTROL: TACH_INPUT_INT_EN (Bitfield-Mask: 0x01) */
#define TACH1_INST_TACH_CONTROL_TACHX_COUNTER_Pos (16UL)                /*!< TACH1_INST TACH_CONTROL: TACHX_COUNTER (Bit 16)             */
#define TACH1_INST_TACH_CONTROL_TACHX_COUNTER_Msk (0xffff0000UL)        /*!< TACH1_INST TACH_CONTROL: TACHX_COUNTER (Bitfield-Mask: 0xffff) */

/* ---------------------------  TACH1_INST_TACHX_STATUS  -------------------------- */
#define TACH1_INST_TACHX_STATUS_TACH_OUT_OF_LIMIT_STATUS_Pos (0UL)      /*!< TACH1_INST TACHX_STATUS: TACH_OUT_OF_LIMIT_STATUS (Bit 0)   */
#define TACH1_INST_TACHX_STATUS_TACH_OUT_OF_LIMIT_STATUS_Msk (0x1UL)    /*!< TACH1_INST TACHX_STATUS: TACH_OUT_OF_LIMIT_STATUS (Bitfield-Mask: 0x01) */
#define TACH1_INST_TACHX_STATUS_TACH_PIN_STATUS_Pos (1UL)               /*!< TACH1_INST TACHX_STATUS: TACH_PIN_STATUS (Bit 1)            */
#define TACH1_INST_TACHX_STATUS_TACH_PIN_STATUS_Msk (0x2UL)             /*!< TACH1_INST TACHX_STATUS: TACH_PIN_STATUS (Bitfield-Mask: 0x01) */
#define TACH1_INST_TACHX_STATUS_TOGGLE_STATUS_Pos (2UL)                 /*!< TACH1_INST TACHX_STATUS: TOGGLE_STATUS (Bit 2)              */
#define TACH1_INST_TACHX_STATUS_TOGGLE_STATUS_Msk (0x4UL)               /*!< TACH1_INST TACHX_STATUS: TOGGLE_STATUS (Bitfield-Mask: 0x01) */
#define TACH1_INST_TACHX_STATUS_COUNT_READY_STATUS_Pos (3UL)            /*!< TACH1_INST TACHX_STATUS: COUNT_READY_STATUS (Bit 3)         */
#define TACH1_INST_TACHX_STATUS_COUNT_READY_STATUS_Msk (0x8UL)          /*!< TACH1_INST TACHX_STATUS: COUNT_READY_STATUS (Bitfield-Mask: 0x01) */

/* -------------------------  TACH1_INST_TACHX_HIGH_LIMIT  ------------------------ */
#define TACH1_INST_TACHX_HIGH_LIMIT_TACH_HIGH_LIMIT_Pos (0UL)           /*!< TACH1_INST TACHX_HIGH_LIMIT: TACH_HIGH_LIMIT (Bit 0)        */
#define TACH1_INST_TACHX_HIGH_LIMIT_TACH_HIGH_LIMIT_Msk (0xffffUL)      /*!< TACH1_INST TACHX_HIGH_LIMIT: TACH_HIGH_LIMIT (Bitfield-Mask: 0xffff) */

/* -------------------------  TACH1_INST_TACHX_LOW_LIMIT  ------------------------- */
#define TACH1_INST_TACHX_LOW_LIMIT_TACH_LOW_LIMIT_Pos (0UL)             /*!< TACH1_INST TACHX_LOW_LIMIT: TACH_LOW_LIMIT (Bit 0)          */
#define TACH1_INST_TACHX_LOW_LIMIT_TACH_LOW_LIMIT_Msk (0xffffUL)        /*!< TACH1_INST TACHX_LOW_LIMIT: TACH_LOW_LIMIT (Bitfield-Mask: 0xffff) */


/* ================================================================================ */
/* ================       struct 'TACH2_INST' Position & Mask      ================ */
/* ================================================================================ */


/* ---------------------------  TACH2_INST_TACH_CONTROL  -------------------------- */
#define TACH2_INST_TACH_CONTROL_TACH_OUT_OF_LIMIT_ENABLE_Pos (0UL)      /*!< TACH2_INST TACH_CONTROL: TACH_OUT_OF_LIMIT_ENABLE (Bit 0)   */
#define TACH2_INST_TACH_CONTROL_TACH_OUT_OF_LIMIT_ENABLE_Msk (0x1UL)    /*!< TACH2_INST TACH_CONTROL: TACH_OUT_OF_LIMIT_ENABLE (Bitfield-Mask: 0x01) */
#define TACH2_INST_TACH_CONTROL_TACH_ENABLE_Pos (1UL)                   /*!< TACH2_INST TACH_CONTROL: TACH_ENABLE (Bit 1)                */
#define TACH2_INST_TACH_CONTROL_TACH_ENABLE_Msk (0x2UL)                 /*!< TACH2_INST TACH_CONTROL: TACH_ENABLE (Bitfield-Mask: 0x01)  */
#define TACH2_INST_TACH_CONTROL_FILTER_ENABLE_Pos (8UL)                 /*!< TACH2_INST TACH_CONTROL: FILTER_ENABLE (Bit 8)              */
#define TACH2_INST_TACH_CONTROL_FILTER_ENABLE_Msk (0x100UL)             /*!< TACH2_INST TACH_CONTROL: FILTER_ENABLE (Bitfield-Mask: 0x01) */
#define TACH2_INST_TACH_CONTROL_TACH_READING_MODE_SELECT_Pos (10UL)     /*!< TACH2_INST TACH_CONTROL: TACH_READING_MODE_SELECT (Bit 10)  */
#define TACH2_INST_TACH_CONTROL_TACH_READING_MODE_SELECT_Msk (0x400UL)  /*!< TACH2_INST TACH_CONTROL: TACH_READING_MODE_SELECT (Bitfield-Mask: 0x01) */
#define TACH2_INST_TACH_CONTROL_TACH_EDGES_Pos (11UL)                   /*!< TACH2_INST TACH_CONTROL: TACH_EDGES (Bit 11)                */
#define TACH2_INST_TACH_CONTROL_TACH_EDGES_Msk (0x1800UL)               /*!< TACH2_INST TACH_CONTROL: TACH_EDGES (Bitfield-Mask: 0x03)   */
#define TACH2_INST_TACH_CONTROL_COUNT_READY_INT_EN_Pos (14UL)           /*!< TACH2_INST TACH_CONTROL: COUNT_READY_INT_EN (Bit 14)        */
#define TACH2_INST_TACH_CONTROL_COUNT_READY_INT_EN_Msk (0x4000UL)       /*!< TACH2_INST TACH_CONTROL: COUNT_READY_INT_EN (Bitfield-Mask: 0x01) */
#define TACH2_INST_TACH_CONTROL_TACH_INPUT_INT_EN_Pos (15UL)            /*!< TACH2_INST TACH_CONTROL: TACH_INPUT_INT_EN (Bit 15)         */
#define TACH2_INST_TACH_CONTROL_TACH_INPUT_INT_EN_Msk (0x8000UL)        /*!< TACH2_INST TACH_CONTROL: TACH_INPUT_INT_EN (Bitfield-Mask: 0x01) */
#define TACH2_INST_TACH_CONTROL_TACHX_COUNTER_Pos (16UL)                /*!< TACH2_INST TACH_CONTROL: TACHX_COUNTER (Bit 16)             */
#define TACH2_INST_TACH_CONTROL_TACHX_COUNTER_Msk (0xffff0000UL)        /*!< TACH2_INST TACH_CONTROL: TACHX_COUNTER (Bitfield-Mask: 0xffff) */

/* ---------------------------  TACH2_INST_TACHX_STATUS  -------------------------- */
#define TACH2_INST_TACHX_STATUS_TACH_OUT_OF_LIMIT_STATUS_Pos (0UL)      /*!< TACH2_INST TACHX_STATUS: TACH_OUT_OF_LIMIT_STATUS (Bit 0)   */
#define TACH2_INST_TACHX_STATUS_TACH_OUT_OF_LIMIT_STATUS_Msk (0x1UL)    /*!< TACH2_INST TACHX_STATUS: TACH_OUT_OF_LIMIT_STATUS (Bitfield-Mask: 0x01) */
#define TACH2_INST_TACHX_STATUS_TACH_PIN_STATUS_Pos (1UL)               /*!< TACH2_INST TACHX_STATUS: TACH_PIN_STATUS (Bit 1)            */
#define TACH2_INST_TACHX_STATUS_TACH_PIN_STATUS_Msk (0x2UL)             /*!< TACH2_INST TACHX_STATUS: TACH_PIN_STATUS (Bitfield-Mask: 0x01) */
#define TACH2_INST_TACHX_STATUS_TOGGLE_STATUS_Pos (2UL)                 /*!< TACH2_INST TACHX_STATUS: TOGGLE_STATUS (Bit 2)              */
#define TACH2_INST_TACHX_STATUS_TOGGLE_STATUS_Msk (0x4UL)               /*!< TACH2_INST TACHX_STATUS: TOGGLE_STATUS (Bitfield-Mask: 0x01) */
#define TACH2_INST_TACHX_STATUS_COUNT_READY_STATUS_Pos (3UL)            /*!< TACH2_INST TACHX_STATUS: COUNT_READY_STATUS (Bit 3)         */
#define TACH2_INST_TACHX_STATUS_COUNT_READY_STATUS_Msk (0x8UL)          /*!< TACH2_INST TACHX_STATUS: COUNT_READY_STATUS (Bitfield-Mask: 0x01) */

/* -------------------------  TACH2_INST_TACHX_HIGH_LIMIT  ------------------------ */
#define TACH2_INST_TACHX_HIGH_LIMIT_TACH_HIGH_LIMIT_Pos (0UL)           /*!< TACH2_INST TACHX_HIGH_LIMIT: TACH_HIGH_LIMIT (Bit 0)        */
#define TACH2_INST_TACHX_HIGH_LIMIT_TACH_HIGH_LIMIT_Msk (0xffffUL)      /*!< TACH2_INST TACHX_HIGH_LIMIT: TACH_HIGH_LIMIT (Bitfield-Mask: 0xffff) */

/* -------------------------  TACH2_INST_TACHX_LOW_LIMIT  ------------------------- */
#define TACH2_INST_TACHX_LOW_LIMIT_TACH_LOW_LIMIT_Pos (0UL)             /*!< TACH2_INST TACHX_LOW_LIMIT: TACH_LOW_LIMIT (Bit 0)          */
#define TACH2_INST_TACHX_LOW_LIMIT_TACH_LOW_LIMIT_Msk (0xffffUL)        /*!< TACH2_INST TACHX_LOW_LIMIT: TACH_LOW_LIMIT (Bitfield-Mask: 0xffff) */


/* ================================================================================ */
/* ================       struct 'PWM0_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ------------------------------  PWM0_INST_CONFIG  ------------------------------ */
#define PWM0_INST_CONFIG_PWM_ENABLE_Pos       (0UL)                     /*!< PWM0_INST CONFIG: PWM_ENABLE (Bit 0)                        */
#define PWM0_INST_CONFIG_PWM_ENABLE_Msk       (0x1UL)                   /*!< PWM0_INST CONFIG: PWM_ENABLE (Bitfield-Mask: 0x01)          */
#define PWM0_INST_CONFIG_CLK_SELECT_Pos       (1UL)                     /*!< PWM0_INST CONFIG: CLK_SELECT (Bit 1)                        */
#define PWM0_INST_CONFIG_CLK_SELECT_Msk       (0x2UL)                   /*!< PWM0_INST CONFIG: CLK_SELECT (Bitfield-Mask: 0x01)          */
#define PWM0_INST_CONFIG_INVERT_Pos           (2UL)                     /*!< PWM0_INST CONFIG: INVERT (Bit 2)                            */
#define PWM0_INST_CONFIG_INVERT_Msk           (0x4UL)                   /*!< PWM0_INST CONFIG: INVERT (Bitfield-Mask: 0x01)              */
#define PWM0_INST_CONFIG_CLK_PRE_DIVIDER_Pos  (3UL)                     /*!< PWM0_INST CONFIG: CLK_PRE_DIVIDER (Bit 3)                   */
#define PWM0_INST_CONFIG_CLK_PRE_DIVIDER_Msk  (0x78UL)                  /*!< PWM0_INST CONFIG: CLK_PRE_DIVIDER (Bitfield-Mask: 0x0f)     */


/* ================================================================================ */
/* ================       struct 'PWM1_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ------------------------------  PWM1_INST_CONFIG  ------------------------------ */
#define PWM1_INST_CONFIG_PWM_ENABLE_Pos       (0UL)                     /*!< PWM1_INST CONFIG: PWM_ENABLE (Bit 0)                        */
#define PWM1_INST_CONFIG_PWM_ENABLE_Msk       (0x1UL)                   /*!< PWM1_INST CONFIG: PWM_ENABLE (Bitfield-Mask: 0x01)          */
#define PWM1_INST_CONFIG_CLK_SELECT_Pos       (1UL)                     /*!< PWM1_INST CONFIG: CLK_SELECT (Bit 1)                        */
#define PWM1_INST_CONFIG_CLK_SELECT_Msk       (0x2UL)                   /*!< PWM1_INST CONFIG: CLK_SELECT (Bitfield-Mask: 0x01)          */
#define PWM1_INST_CONFIG_INVERT_Pos           (2UL)                     /*!< PWM1_INST CONFIG: INVERT (Bit 2)                            */
#define PWM1_INST_CONFIG_INVERT_Msk           (0x4UL)                   /*!< PWM1_INST CONFIG: INVERT (Bitfield-Mask: 0x01)              */
#define PWM1_INST_CONFIG_CLK_PRE_DIVIDER_Pos  (3UL)                     /*!< PWM1_INST CONFIG: CLK_PRE_DIVIDER (Bit 3)                   */
#define PWM1_INST_CONFIG_CLK_PRE_DIVIDER_Msk  (0x78UL)                  /*!< PWM1_INST CONFIG: CLK_PRE_DIVIDER (Bitfield-Mask: 0x0f)     */


/* ================================================================================ */
/* ================       struct 'PWM2_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ------------------------------  PWM2_INST_CONFIG  ------------------------------ */
#define PWM2_INST_CONFIG_PWM_ENABLE_Pos       (0UL)                     /*!< PWM2_INST CONFIG: PWM_ENABLE (Bit 0)                        */
#define PWM2_INST_CONFIG_PWM_ENABLE_Msk       (0x1UL)                   /*!< PWM2_INST CONFIG: PWM_ENABLE (Bitfield-Mask: 0x01)          */
#define PWM2_INST_CONFIG_CLK_SELECT_Pos       (1UL)                     /*!< PWM2_INST CONFIG: CLK_SELECT (Bit 1)                        */
#define PWM2_INST_CONFIG_CLK_SELECT_Msk       (0x2UL)                   /*!< PWM2_INST CONFIG: CLK_SELECT (Bitfield-Mask: 0x01)          */
#define PWM2_INST_CONFIG_INVERT_Pos           (2UL)                     /*!< PWM2_INST CONFIG: INVERT (Bit 2)                            */
#define PWM2_INST_CONFIG_INVERT_Msk           (0x4UL)                   /*!< PWM2_INST CONFIG: INVERT (Bitfield-Mask: 0x01)              */
#define PWM2_INST_CONFIG_CLK_PRE_DIVIDER_Pos  (3UL)                     /*!< PWM2_INST CONFIG: CLK_PRE_DIVIDER (Bit 3)                   */
#define PWM2_INST_CONFIG_CLK_PRE_DIVIDER_Msk  (0x78UL)                  /*!< PWM2_INST CONFIG: CLK_PRE_DIVIDER (Bitfield-Mask: 0x0f)     */


/* ================================================================================ */
/* ================       struct 'PWM3_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ------------------------------  PWM3_INST_CONFIG  ------------------------------ */
#define PWM3_INST_CONFIG_PWM_ENABLE_Pos       (0UL)                     /*!< PWM3_INST CONFIG: PWM_ENABLE (Bit 0)                        */
#define PWM3_INST_CONFIG_PWM_ENABLE_Msk       (0x1UL)                   /*!< PWM3_INST CONFIG: PWM_ENABLE (Bitfield-Mask: 0x01)          */
#define PWM3_INST_CONFIG_CLK_SELECT_Pos       (1UL)                     /*!< PWM3_INST CONFIG: CLK_SELECT (Bit 1)                        */
#define PWM3_INST_CONFIG_CLK_SELECT_Msk       (0x2UL)                   /*!< PWM3_INST CONFIG: CLK_SELECT (Bitfield-Mask: 0x01)          */
#define PWM3_INST_CONFIG_INVERT_Pos           (2UL)                     /*!< PWM3_INST CONFIG: INVERT (Bit 2)                            */
#define PWM3_INST_CONFIG_INVERT_Msk           (0x4UL)                   /*!< PWM3_INST CONFIG: INVERT (Bitfield-Mask: 0x01)              */
#define PWM3_INST_CONFIG_CLK_PRE_DIVIDER_Pos  (3UL)                     /*!< PWM3_INST CONFIG: CLK_PRE_DIVIDER (Bit 3)                   */
#define PWM3_INST_CONFIG_CLK_PRE_DIVIDER_Msk  (0x78UL)                  /*!< PWM3_INST CONFIG: CLK_PRE_DIVIDER (Bitfield-Mask: 0x0f)     */


/* ================================================================================ */
/* ================       struct 'PWM4_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ------------------------------  PWM4_INST_CONFIG  ------------------------------ */
#define PWM4_INST_CONFIG_PWM_ENABLE_Pos       (0UL)                     /*!< PWM4_INST CONFIG: PWM_ENABLE (Bit 0)                        */
#define PWM4_INST_CONFIG_PWM_ENABLE_Msk       (0x1UL)                   /*!< PWM4_INST CONFIG: PWM_ENABLE (Bitfield-Mask: 0x01)          */
#define PWM4_INST_CONFIG_CLK_SELECT_Pos       (1UL)                     /*!< PWM4_INST CONFIG: CLK_SELECT (Bit 1)                        */
#define PWM4_INST_CONFIG_CLK_SELECT_Msk       (0x2UL)                   /*!< PWM4_INST CONFIG: CLK_SELECT (Bitfield-Mask: 0x01)          */
#define PWM4_INST_CONFIG_INVERT_Pos           (2UL)                     /*!< PWM4_INST CONFIG: INVERT (Bit 2)                            */
#define PWM4_INST_CONFIG_INVERT_Msk           (0x4UL)                   /*!< PWM4_INST CONFIG: INVERT (Bitfield-Mask: 0x01)              */
#define PWM4_INST_CONFIG_CLK_PRE_DIVIDER_Pos  (3UL)                     /*!< PWM4_INST CONFIG: CLK_PRE_DIVIDER (Bit 3)                   */
#define PWM4_INST_CONFIG_CLK_PRE_DIVIDER_Msk  (0x78UL)                  /*!< PWM4_INST CONFIG: CLK_PRE_DIVIDER (Bitfield-Mask: 0x0f)     */


/* ================================================================================ */
/* ================       struct 'PWM5_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ------------------------------  PWM5_INST_CONFIG  ------------------------------ */
#define PWM5_INST_CONFIG_PWM_ENABLE_Pos       (0UL)                     /*!< PWM5_INST CONFIG: PWM_ENABLE (Bit 0)                        */
#define PWM5_INST_CONFIG_PWM_ENABLE_Msk       (0x1UL)                   /*!< PWM5_INST CONFIG: PWM_ENABLE (Bitfield-Mask: 0x01)          */
#define PWM5_INST_CONFIG_CLK_SELECT_Pos       (1UL)                     /*!< PWM5_INST CONFIG: CLK_SELECT (Bit 1)                        */
#define PWM5_INST_CONFIG_CLK_SELECT_Msk       (0x2UL)                   /*!< PWM5_INST CONFIG: CLK_SELECT (Bitfield-Mask: 0x01)          */
#define PWM5_INST_CONFIG_INVERT_Pos           (2UL)                     /*!< PWM5_INST CONFIG: INVERT (Bit 2)                            */
#define PWM5_INST_CONFIG_INVERT_Msk           (0x4UL)                   /*!< PWM5_INST CONFIG: INVERT (Bitfield-Mask: 0x01)              */
#define PWM5_INST_CONFIG_CLK_PRE_DIVIDER_Pos  (3UL)                     /*!< PWM5_INST CONFIG: CLK_PRE_DIVIDER (Bit 3)                   */
#define PWM5_INST_CONFIG_CLK_PRE_DIVIDER_Msk  (0x78UL)                  /*!< PWM5_INST CONFIG: CLK_PRE_DIVIDER (Bitfield-Mask: 0x0f)     */


/* ================================================================================ */
/* ================       struct 'PWM6_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ------------------------------  PWM6_INST_CONFIG  ------------------------------ */
#define PWM6_INST_CONFIG_PWM_ENABLE_Pos       (0UL)                     /*!< PWM6_INST CONFIG: PWM_ENABLE (Bit 0)                        */
#define PWM6_INST_CONFIG_PWM_ENABLE_Msk       (0x1UL)                   /*!< PWM6_INST CONFIG: PWM_ENABLE (Bitfield-Mask: 0x01)          */
#define PWM6_INST_CONFIG_CLK_SELECT_Pos       (1UL)                     /*!< PWM6_INST CONFIG: CLK_SELECT (Bit 1)                        */
#define PWM6_INST_CONFIG_CLK_SELECT_Msk       (0x2UL)                   /*!< PWM6_INST CONFIG: CLK_SELECT (Bitfield-Mask: 0x01)          */
#define PWM6_INST_CONFIG_INVERT_Pos           (2UL)                     /*!< PWM6_INST CONFIG: INVERT (Bit 2)                            */
#define PWM6_INST_CONFIG_INVERT_Msk           (0x4UL)                   /*!< PWM6_INST CONFIG: INVERT (Bitfield-Mask: 0x01)              */
#define PWM6_INST_CONFIG_CLK_PRE_DIVIDER_Pos  (3UL)                     /*!< PWM6_INST CONFIG: CLK_PRE_DIVIDER (Bit 3)                   */
#define PWM6_INST_CONFIG_CLK_PRE_DIVIDER_Msk  (0x78UL)                  /*!< PWM6_INST CONFIG: CLK_PRE_DIVIDER (Bitfield-Mask: 0x0f)     */


/* ================================================================================ */
/* ================       struct 'PWM7_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ------------------------------  PWM7_INST_CONFIG  ------------------------------ */
#define PWM7_INST_CONFIG_PWM_ENABLE_Pos       (0UL)                     /*!< PWM7_INST CONFIG: PWM_ENABLE (Bit 0)                        */
#define PWM7_INST_CONFIG_PWM_ENABLE_Msk       (0x1UL)                   /*!< PWM7_INST CONFIG: PWM_ENABLE (Bitfield-Mask: 0x01)          */
#define PWM7_INST_CONFIG_CLK_SELECT_Pos       (1UL)                     /*!< PWM7_INST CONFIG: CLK_SELECT (Bit 1)                        */
#define PWM7_INST_CONFIG_CLK_SELECT_Msk       (0x2UL)                   /*!< PWM7_INST CONFIG: CLK_SELECT (Bitfield-Mask: 0x01)          */
#define PWM7_INST_CONFIG_INVERT_Pos           (2UL)                     /*!< PWM7_INST CONFIG: INVERT (Bit 2)                            */
#define PWM7_INST_CONFIG_INVERT_Msk           (0x4UL)                   /*!< PWM7_INST CONFIG: INVERT (Bitfield-Mask: 0x01)              */
#define PWM7_INST_CONFIG_CLK_PRE_DIVIDER_Pos  (3UL)                     /*!< PWM7_INST CONFIG: CLK_PRE_DIVIDER (Bit 3)                   */
#define PWM7_INST_CONFIG_CLK_PRE_DIVIDER_Msk  (0x78UL)                  /*!< PWM7_INST CONFIG: CLK_PRE_DIVIDER (Bitfield-Mask: 0x0f)     */


/* ================================================================================ */
/* ================       struct 'PWM8_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ------------------------------  PWM8_INST_CONFIG  ------------------------------ */
#define PWM8_INST_CONFIG_PWM_ENABLE_Pos       (0UL)                     /*!< PWM8_INST CONFIG: PWM_ENABLE (Bit 0)                        */
#define PWM8_INST_CONFIG_PWM_ENABLE_Msk       (0x1UL)                   /*!< PWM8_INST CONFIG: PWM_ENABLE (Bitfield-Mask: 0x01)          */
#define PWM8_INST_CONFIG_CLK_SELECT_Pos       (1UL)                     /*!< PWM8_INST CONFIG: CLK_SELECT (Bit 1)                        */
#define PWM8_INST_CONFIG_CLK_SELECT_Msk       (0x2UL)                   /*!< PWM8_INST CONFIG: CLK_SELECT (Bitfield-Mask: 0x01)          */
#define PWM8_INST_CONFIG_INVERT_Pos           (2UL)                     /*!< PWM8_INST CONFIG: INVERT (Bit 2)                            */
#define PWM8_INST_CONFIG_INVERT_Msk           (0x4UL)                   /*!< PWM8_INST CONFIG: INVERT (Bitfield-Mask: 0x01)              */
#define PWM8_INST_CONFIG_CLK_PRE_DIVIDER_Pos  (3UL)                     /*!< PWM8_INST CONFIG: CLK_PRE_DIVIDER (Bit 3)                   */
#define PWM8_INST_CONFIG_CLK_PRE_DIVIDER_Msk  (0x78UL)                  /*!< PWM8_INST CONFIG: CLK_PRE_DIVIDER (Bitfield-Mask: 0x0f)     */


/* ================================================================================ */
/* ================       struct 'PWM9_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ------------------------------  PWM9_INST_CONFIG  ------------------------------ */
#define PWM9_INST_CONFIG_PWM_ENABLE_Pos       (0UL)                     /*!< PWM9_INST CONFIG: PWM_ENABLE (Bit 0)                        */
#define PWM9_INST_CONFIG_PWM_ENABLE_Msk       (0x1UL)                   /*!< PWM9_INST CONFIG: PWM_ENABLE (Bitfield-Mask: 0x01)          */
#define PWM9_INST_CONFIG_CLK_SELECT_Pos       (1UL)                     /*!< PWM9_INST CONFIG: CLK_SELECT (Bit 1)                        */
#define PWM9_INST_CONFIG_CLK_SELECT_Msk       (0x2UL)                   /*!< PWM9_INST CONFIG: CLK_SELECT (Bitfield-Mask: 0x01)          */
#define PWM9_INST_CONFIG_INVERT_Pos           (2UL)                     /*!< PWM9_INST CONFIG: INVERT (Bit 2)                            */
#define PWM9_INST_CONFIG_INVERT_Msk           (0x4UL)                   /*!< PWM9_INST CONFIG: INVERT (Bitfield-Mask: 0x01)              */
#define PWM9_INST_CONFIG_CLK_PRE_DIVIDER_Pos  (3UL)                     /*!< PWM9_INST CONFIG: CLK_PRE_DIVIDER (Bit 3)                   */
#define PWM9_INST_CONFIG_CLK_PRE_DIVIDER_Msk  (0x78UL)                  /*!< PWM9_INST CONFIG: CLK_PRE_DIVIDER (Bitfield-Mask: 0x0f)     */


/* ================================================================================ */
/* ================       struct 'PWM10_INST' Position & Mask      ================ */
/* ================================================================================ */


/* ------------------------------  PWM10_INST_CONFIG  ----------------------------- */
#define PWM10_INST_CONFIG_PWM_ENABLE_Pos      (0UL)                     /*!< PWM10_INST CONFIG: PWM_ENABLE (Bit 0)                       */
#define PWM10_INST_CONFIG_PWM_ENABLE_Msk      (0x1UL)                   /*!< PWM10_INST CONFIG: PWM_ENABLE (Bitfield-Mask: 0x01)         */
#define PWM10_INST_CONFIG_CLK_SELECT_Pos      (1UL)                     /*!< PWM10_INST CONFIG: CLK_SELECT (Bit 1)                       */
#define PWM10_INST_CONFIG_CLK_SELECT_Msk      (0x2UL)                   /*!< PWM10_INST CONFIG: CLK_SELECT (Bitfield-Mask: 0x01)         */
#define PWM10_INST_CONFIG_INVERT_Pos          (2UL)                     /*!< PWM10_INST CONFIG: INVERT (Bit 2)                           */
#define PWM10_INST_CONFIG_INVERT_Msk          (0x4UL)                   /*!< PWM10_INST CONFIG: INVERT (Bitfield-Mask: 0x01)             */
#define PWM10_INST_CONFIG_CLK_PRE_DIVIDER_Pos (3UL)                     /*!< PWM10_INST CONFIG: CLK_PRE_DIVIDER (Bit 3)                  */
#define PWM10_INST_CONFIG_CLK_PRE_DIVIDER_Msk (0x78UL)                  /*!< PWM10_INST CONFIG: CLK_PRE_DIVIDER (Bitfield-Mask: 0x0f)    */


/* ================================================================================ */
/* ================       struct 'PWM11_INST' Position & Mask      ================ */
/* ================================================================================ */


/* ------------------------------  PWM11_INST_CONFIG  ----------------------------- */
#define PWM11_INST_CONFIG_PWM_ENABLE_Pos      (0UL)                     /*!< PWM11_INST CONFIG: PWM_ENABLE (Bit 0)                       */
#define PWM11_INST_CONFIG_PWM_ENABLE_Msk      (0x1UL)                   /*!< PWM11_INST CONFIG: PWM_ENABLE (Bitfield-Mask: 0x01)         */
#define PWM11_INST_CONFIG_CLK_SELECT_Pos      (1UL)                     /*!< PWM11_INST CONFIG: CLK_SELECT (Bit 1)                       */
#define PWM11_INST_CONFIG_CLK_SELECT_Msk      (0x2UL)                   /*!< PWM11_INST CONFIG: CLK_SELECT (Bitfield-Mask: 0x01)         */
#define PWM11_INST_CONFIG_INVERT_Pos          (2UL)                     /*!< PWM11_INST CONFIG: INVERT (Bit 2)                           */
#define PWM11_INST_CONFIG_INVERT_Msk          (0x4UL)                   /*!< PWM11_INST CONFIG: INVERT (Bitfield-Mask: 0x01)             */
#define PWM11_INST_CONFIG_CLK_PRE_DIVIDER_Pos (3UL)                     /*!< PWM11_INST CONFIG: CLK_PRE_DIVIDER (Bit 3)                  */
#define PWM11_INST_CONFIG_CLK_PRE_DIVIDER_Msk (0x78UL)                  /*!< PWM11_INST CONFIG: CLK_PRE_DIVIDER (Bitfield-Mask: 0x0f)    */


/* ================================================================================ */
/* ================        struct 'ADC_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ------------------------------  ADC_INST_CONTROL  ------------------------------ */
#define ADC_INST_CONTROL_ACTIVATE_Pos         (0UL)                     /*!< ADC_INST CONTROL: ACTIVATE (Bit 0)                          */
#define ADC_INST_CONTROL_ACTIVATE_Msk         (0x1UL)                   /*!< ADC_INST CONTROL: ACTIVATE (Bitfield-Mask: 0x01)            */
#define ADC_INST_CONTROL_START_SINGLE_Pos     (1UL)                     /*!< ADC_INST CONTROL: START_SINGLE (Bit 1)                      */
#define ADC_INST_CONTROL_START_SINGLE_Msk     (0x2UL)                   /*!< ADC_INST CONTROL: START_SINGLE (Bitfield-Mask: 0x01)        */
#define ADC_INST_CONTROL_START_REPEAT_Pos     (2UL)                     /*!< ADC_INST CONTROL: START_REPEAT (Bit 2)                      */
#define ADC_INST_CONTROL_START_REPEAT_Msk     (0x4UL)                   /*!< ADC_INST CONTROL: START_REPEAT (Bitfield-Mask: 0x01)        */
#define ADC_INST_CONTROL_POWER_SAVER_DIS_Pos  (3UL)                     /*!< ADC_INST CONTROL: POWER_SAVER_DIS (Bit 3)                   */
#define ADC_INST_CONTROL_POWER_SAVER_DIS_Msk  (0x8UL)                   /*!< ADC_INST CONTROL: POWER_SAVER_DIS (Bitfield-Mask: 0x01)     */
#define ADC_INST_CONTROL_SOFT_RESET_Pos       (4UL)                     /*!< ADC_INST CONTROL: SOFT_RESET (Bit 4)                        */
#define ADC_INST_CONTROL_SOFT_RESET_Msk       (0x10UL)                  /*!< ADC_INST CONTROL: SOFT_RESET (Bitfield-Mask: 0x01)          */
#define ADC_INST_CONTROL_REPEAT_DONE_STAT_Pos (6UL)                     /*!< ADC_INST CONTROL: REPEAT_DONE_STAT (Bit 6)                  */
#define ADC_INST_CONTROL_REPEAT_DONE_STAT_Msk (0x40UL)                  /*!< ADC_INST CONTROL: REPEAT_DONE_STAT (Bitfield-Mask: 0x01)    */
#define ADC_INST_CONTROL_SINGLE_DONE_STAT_Pos (7UL)                     /*!< ADC_INST CONTROL: SINGLE_DONE_STAT (Bit 7)                  */
#define ADC_INST_CONTROL_SINGLE_DONE_STAT_Msk (0x80UL)                  /*!< ADC_INST CONTROL: SINGLE_DONE_STAT (Bitfield-Mask: 0x01)    */

/* -------------------------------  ADC_INST_DELAY  ------------------------------- */
#define ADC_INST_DELAY_START_DELAY_Pos        (0UL)                     /*!< ADC_INST DELAY: START_DELAY (Bit 0)                         */
#define ADC_INST_DELAY_START_DELAY_Msk        (0xffffUL)                /*!< ADC_INST DELAY: START_DELAY (Bitfield-Mask: 0xffff)         */
#define ADC_INST_DELAY_REPEAT_DELAY_Pos       (16UL)                    /*!< ADC_INST DELAY: REPEAT_DELAY (Bit 16)                       */
#define ADC_INST_DELAY_REPEAT_DELAY_Msk       (0xffff0000UL)            /*!< ADC_INST DELAY: REPEAT_DELAY (Bitfield-Mask: 0xffff)        */

/* -------------------------------  ADC_INST_STATUS  ------------------------------ */
#define ADC_INST_STATUS_ADC_CH_STATUS_Pos     (0UL)                     /*!< ADC_INST STATUS: ADC_CH_STATUS (Bit 0)                      */
#define ADC_INST_STATUS_ADC_CH_STATUS_Msk     (0xffffUL)                /*!< ADC_INST STATUS: ADC_CH_STATUS (Bitfield-Mask: 0xffff)      */

/* -----------------------------  ADC_INST_SINGLE_EN  ----------------------------- */
#define ADC_INST_SINGLE_EN_SINGLE_EN_Pos      (0UL)                     /*!< ADC_INST SINGLE_EN: SINGLE_EN (Bit 0)                       */
#define ADC_INST_SINGLE_EN_SINGLE_EN_Msk      (0xffffUL)                /*!< ADC_INST SINGLE_EN: SINGLE_EN (Bitfield-Mask: 0xffff)       */

/* -------------------------------  ADC_INST_REPEAT  ------------------------------ */
#define ADC_INST_REPEAT_RPT_EN_Pos            (0UL)                     /*!< ADC_INST REPEAT: RPT_EN (Bit 0)                             */
#define ADC_INST_REPEAT_RPT_EN_Msk            (0xffffUL)                /*!< ADC_INST REPEAT: RPT_EN (Bitfield-Mask: 0xffff)             */


/* ================================================================================ */
/* ================       struct 'FAN0_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ----------------------------  FAN0_INST_FAN_SETTING  --------------------------- */
#define FAN0_INST_FAN_SETTING_FAN_SETTING_Pos (6UL)                     /*!< FAN0_INST FAN_SETTING: FAN_SETTING (Bit 6)                  */
#define FAN0_INST_FAN_SETTING_FAN_SETTING_Msk (0xffc0UL)                /*!< FAN0_INST FAN_SETTING: FAN_SETTING (Bitfield-Mask: 0x3ff)   */

/* ---------------------------  FAN0_INST_CONFIGURATION  -------------------------- */
#define FAN0_INST_CONFIGURATION_UPDATE_Pos    (0UL)                     /*!< FAN0_INST CONFIGURATION: UPDATE (Bit 0)                     */
#define FAN0_INST_CONFIGURATION_UPDATE_Msk    (0x7UL)                   /*!< FAN0_INST CONFIGURATION: UPDATE (Bitfield-Mask: 0x07)       */
#define FAN0_INST_CONFIGURATION_EDGES_Pos     (3UL)                     /*!< FAN0_INST CONFIGURATION: EDGES (Bit 3)                      */
#define FAN0_INST_CONFIGURATION_EDGES_Msk     (0x18UL)                  /*!< FAN0_INST CONFIGURATION: EDGES (Bitfield-Mask: 0x03)        */
#define FAN0_INST_CONFIGURATION_RANGE_Pos     (5UL)                     /*!< FAN0_INST CONFIGURATION: RANGE (Bit 5)                      */
#define FAN0_INST_CONFIGURATION_RANGE_Msk     (0x60UL)                  /*!< FAN0_INST CONFIGURATION: RANGE (Bitfield-Mask: 0x03)        */
#define FAN0_INST_CONFIGURATION_EN_ALGO_Pos   (7UL)                     /*!< FAN0_INST CONFIGURATION: EN_ALGO (Bit 7)                    */
#define FAN0_INST_CONFIGURATION_EN_ALGO_Msk   (0x80UL)                  /*!< FAN0_INST CONFIGURATION: EN_ALGO (Bitfield-Mask: 0x01)      */
#define FAN0_INST_CONFIGURATION_POLARITY_Pos  (9UL)                     /*!< FAN0_INST CONFIGURATION: POLARITY (Bit 9)                   */
#define FAN0_INST_CONFIGURATION_POLARITY_Msk  (0x200UL)                 /*!< FAN0_INST CONFIGURATION: POLARITY (Bitfield-Mask: 0x01)     */
#define FAN0_INST_CONFIGURATION_ERR_RNG_Pos   (10UL)                    /*!< FAN0_INST CONFIGURATION: ERR_RNG (Bit 10)                   */
#define FAN0_INST_CONFIGURATION_ERR_RNG_Msk   (0xc00UL)                 /*!< FAN0_INST CONFIGURATION: ERR_RNG (Bitfield-Mask: 0x03)      */
#define FAN0_INST_CONFIGURATION_DER_OPT_Pos   (12UL)                    /*!< FAN0_INST CONFIGURATION: DER_OPT (Bit 12)                   */
#define FAN0_INST_CONFIGURATION_DER_OPT_Msk   (0x3000UL)                /*!< FAN0_INST CONFIGURATION: DER_OPT (Bitfield-Mask: 0x03)      */
#define FAN0_INST_CONFIGURATION_DIS_GLITCH_Pos (14UL)                   /*!< FAN0_INST CONFIGURATION: DIS_GLITCH (Bit 14)                */
#define FAN0_INST_CONFIGURATION_DIS_GLITCH_Msk (0x4000UL)               /*!< FAN0_INST CONFIGURATION: DIS_GLITCH (Bitfield-Mask: 0x01)   */
#define FAN0_INST_CONFIGURATION_EN_RRC_Pos    (15UL)                    /*!< FAN0_INST CONFIGURATION: EN_RRC (Bit 15)                    */
#define FAN0_INST_CONFIGURATION_EN_RRC_Msk    (0x8000UL)                /*!< FAN0_INST CONFIGURATION: EN_RRC (Bitfield-Mask: 0x01)       */

/* ----------------------------  FAN0_INST_PWM_DIVIDE  ---------------------------- */
#define FAN0_INST_PWM_DIVIDE_PWM_DIVIDE_Pos   (0UL)                     /*!< FAN0_INST PWM_DIVIDE: PWM_DIVIDE (Bit 0)                    */
#define FAN0_INST_PWM_DIVIDE_PWM_DIVIDE_Msk   (0xffUL)                  /*!< FAN0_INST PWM_DIVIDE: PWM_DIVIDE (Bitfield-Mask: 0xff)      */

/* -------------------------------  FAN0_INST_GAIN  ------------------------------- */
#define FAN0_INST_GAIN_GAINP_Pos              (0UL)                     /*!< FAN0_INST GAIN: GAINP (Bit 0)                               */
#define FAN0_INST_GAIN_GAINP_Msk              (0x3UL)                   /*!< FAN0_INST GAIN: GAINP (Bitfield-Mask: 0x03)                 */
#define FAN0_INST_GAIN_GAINI_Pos              (2UL)                     /*!< FAN0_INST GAIN: GAINI (Bit 2)                               */
#define FAN0_INST_GAIN_GAINI_Msk              (0xcUL)                   /*!< FAN0_INST GAIN: GAINI (Bitfield-Mask: 0x03)                 */
#define FAN0_INST_GAIN_GAIND_Pos              (4UL)                     /*!< FAN0_INST GAIN: GAIND (Bit 4)                               */
#define FAN0_INST_GAIN_GAIND_Msk              (0x30UL)                  /*!< FAN0_INST GAIN: GAIND (Bitfield-Mask: 0x03)                 */

/* -----------------------  FAN0_INST_SPIN_UP_CONFIGURATION  ---------------------- */
#define FAN0_INST_SPIN_UP_CONFIGURATION_SPINUP_TIME_Pos (0UL)           /*!< FAN0_INST SPIN_UP_CONFIGURATION: SPINUP_TIME (Bit 0)        */
#define FAN0_INST_SPIN_UP_CONFIGURATION_SPINUP_TIME_Msk (0x3UL)         /*!< FAN0_INST SPIN_UP_CONFIGURATION: SPINUP_TIME (Bitfield-Mask: 0x03) */
#define FAN0_INST_SPIN_UP_CONFIGURATION_SPIN_LVL_Pos (2UL)              /*!< FAN0_INST SPIN_UP_CONFIGURATION: SPIN_LVL (Bit 2)           */
#define FAN0_INST_SPIN_UP_CONFIGURATION_SPIN_LVL_Msk (0x1cUL)           /*!< FAN0_INST SPIN_UP_CONFIGURATION: SPIN_LVL (Bitfield-Mask: 0x07) */
#define FAN0_INST_SPIN_UP_CONFIGURATION_NOKICK_Pos (5UL)                /*!< FAN0_INST SPIN_UP_CONFIGURATION: NOKICK (Bit 5)             */
#define FAN0_INST_SPIN_UP_CONFIGURATION_NOKICK_Msk (0x20UL)             /*!< FAN0_INST SPIN_UP_CONFIGURATION: NOKICK (Bitfield-Mask: 0x01) */
#define FAN0_INST_SPIN_UP_CONFIGURATION_DRIVE_FAIL_CNT_Pos (6UL)        /*!< FAN0_INST SPIN_UP_CONFIGURATION: DRIVE_FAIL_CNT (Bit 6)     */
#define FAN0_INST_SPIN_UP_CONFIGURATION_DRIVE_FAIL_CNT_Msk (0xc0UL)     /*!< FAN0_INST SPIN_UP_CONFIGURATION: DRIVE_FAIL_CNT (Bitfield-Mask: 0x03) */

/* -----------------------------  FAN0_INST_FAN_STEP  ----------------------------- */
#define FAN0_INST_FAN_STEP_FAN_STEP_Pos       (0UL)                     /*!< FAN0_INST FAN_STEP: FAN_STEP (Bit 0)                        */
#define FAN0_INST_FAN_STEP_FAN_STEP_Msk       (0xffUL)                  /*!< FAN0_INST FAN_STEP: FAN_STEP (Bitfield-Mask: 0xff)          */

/* ---------------------------  FAN0_INST_MINIMUM_DRIVE  -------------------------- */
#define FAN0_INST_MINIMUM_DRIVE_MIN_DRIVE_Pos (0UL)                     /*!< FAN0_INST MINIMUM_DRIVE: MIN_DRIVE (Bit 0)                  */
#define FAN0_INST_MINIMUM_DRIVE_MIN_DRIVE_Msk (0xffUL)                  /*!< FAN0_INST MINIMUM_DRIVE: MIN_DRIVE (Bitfield-Mask: 0xff)    */

/* -------------------------  FAN0_INST_VALID_TACH_COUNT  ------------------------- */
#define FAN0_INST_VALID_TACH_COUNT_VALID_TACH_CNT_Pos (0UL)             /*!< FAN0_INST VALID_TACH_COUNT: VALID_TACH_CNT (Bit 0)          */
#define FAN0_INST_VALID_TACH_COUNT_VALID_TACH_CNT_Msk (0xffUL)          /*!< FAN0_INST VALID_TACH_COUNT: VALID_TACH_CNT (Bitfield-Mask: 0xff) */

/* ------------------------  FAN0_INST_FAN_DRIVE_FAIL_BAND  ----------------------- */
#define FAN0_INST_FAN_DRIVE_FAIL_BAND_FAN_DRIVE_FAIL_BAND_Pos (3UL)     /*!< FAN0_INST FAN_DRIVE_FAIL_BAND: FAN_DRIVE_FAIL_BAND (Bit 3)  */
#define FAN0_INST_FAN_DRIVE_FAIL_BAND_FAN_DRIVE_FAIL_BAND_Msk (0xfff8UL) /*!< FAN0_INST FAN_DRIVE_FAIL_BAND: FAN_DRIVE_FAIL_BAND (Bitfield-Mask: 0x1fff) */

/* ----------------------------  FAN0_INST_TACH_TARGET  --------------------------- */
#define FAN0_INST_TACH_TARGET_TACH_TARGET_Pos (3UL)                     /*!< FAN0_INST TACH_TARGET: TACH_TARGET (Bit 3)                  */
#define FAN0_INST_TACH_TARGET_TACH_TARGET_Msk (0xfff8UL)                /*!< FAN0_INST TACH_TARGET: TACH_TARGET (Bitfield-Mask: 0x1fff)  */

/* ---------------------------  FAN0_INST_TACH_READING  --------------------------- */
#define FAN0_INST_TACH_READING_TACH_READING_Pos (3UL)                   /*!< FAN0_INST TACH_READING: TACH_READING (Bit 3)                */
#define FAN0_INST_TACH_READING_TACH_READING_Msk (0xfff8UL)              /*!< FAN0_INST TACH_READING: TACH_READING (Bitfield-Mask: 0x1fff) */

/* -----------------------  FAN0_INST_DRIVER_BASE_FREQUENCY  ---------------------- */
#define FAN0_INST_DRIVER_BASE_FREQUENCY_PWM_BASE_Pos (0UL)              /*!< FAN0_INST DRIVER_BASE_FREQUENCY: PWM_BASE (Bit 0)           */
#define FAN0_INST_DRIVER_BASE_FREQUENCY_PWM_BASE_Msk (0x3UL)            /*!< FAN0_INST DRIVER_BASE_FREQUENCY: PWM_BASE (Bitfield-Mask: 0x03) */

/* ------------------------------  FAN0_INST_STATUS  ------------------------------ */
#define FAN0_INST_STATUS_FAN_STALL_Pos        (0UL)                     /*!< FAN0_INST STATUS: FAN_STALL (Bit 0)                         */
#define FAN0_INST_STATUS_FAN_STALL_Msk        (0x1UL)                   /*!< FAN0_INST STATUS: FAN_STALL (Bitfield-Mask: 0x01)           */
#define FAN0_INST_STATUS_FAN_SPIN_Pos         (1UL)                     /*!< FAN0_INST STATUS: FAN_SPIN (Bit 1)                          */
#define FAN0_INST_STATUS_FAN_SPIN_Msk         (0x2UL)                   /*!< FAN0_INST STATUS: FAN_SPIN (Bitfield-Mask: 0x01)            */
#define FAN0_INST_STATUS_DRIVE_FAIL_Pos       (5UL)                     /*!< FAN0_INST STATUS: DRIVE_FAIL (Bit 5)                        */
#define FAN0_INST_STATUS_DRIVE_FAIL_Msk       (0x20UL)                  /*!< FAN0_INST STATUS: DRIVE_FAIL (Bitfield-Mask: 0x01)          */


/* ================================================================================ */
/* ================       struct 'FAN1_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ----------------------------  FAN1_INST_FAN_SETTING  --------------------------- */
#define FAN1_INST_FAN_SETTING_FAN_SETTING_Pos (6UL)                     /*!< FAN1_INST FAN_SETTING: FAN_SETTING (Bit 6)                  */
#define FAN1_INST_FAN_SETTING_FAN_SETTING_Msk (0xffc0UL)                /*!< FAN1_INST FAN_SETTING: FAN_SETTING (Bitfield-Mask: 0x3ff)   */

/* ---------------------------  FAN1_INST_CONFIGURATION  -------------------------- */
#define FAN1_INST_CONFIGURATION_UPDATE_Pos    (0UL)                     /*!< FAN1_INST CONFIGURATION: UPDATE (Bit 0)                     */
#define FAN1_INST_CONFIGURATION_UPDATE_Msk    (0x7UL)                   /*!< FAN1_INST CONFIGURATION: UPDATE (Bitfield-Mask: 0x07)       */
#define FAN1_INST_CONFIGURATION_EDGES_Pos     (3UL)                     /*!< FAN1_INST CONFIGURATION: EDGES (Bit 3)                      */
#define FAN1_INST_CONFIGURATION_EDGES_Msk     (0x18UL)                  /*!< FAN1_INST CONFIGURATION: EDGES (Bitfield-Mask: 0x03)        */
#define FAN1_INST_CONFIGURATION_RANGE_Pos     (5UL)                     /*!< FAN1_INST CONFIGURATION: RANGE (Bit 5)                      */
#define FAN1_INST_CONFIGURATION_RANGE_Msk     (0x60UL)                  /*!< FAN1_INST CONFIGURATION: RANGE (Bitfield-Mask: 0x03)        */
#define FAN1_INST_CONFIGURATION_EN_ALGO_Pos   (7UL)                     /*!< FAN1_INST CONFIGURATION: EN_ALGO (Bit 7)                    */
#define FAN1_INST_CONFIGURATION_EN_ALGO_Msk   (0x80UL)                  /*!< FAN1_INST CONFIGURATION: EN_ALGO (Bitfield-Mask: 0x01)      */
#define FAN1_INST_CONFIGURATION_POLARITY_Pos  (9UL)                     /*!< FAN1_INST CONFIGURATION: POLARITY (Bit 9)                   */
#define FAN1_INST_CONFIGURATION_POLARITY_Msk  (0x200UL)                 /*!< FAN1_INST CONFIGURATION: POLARITY (Bitfield-Mask: 0x01)     */
#define FAN1_INST_CONFIGURATION_ERR_RNG_Pos   (10UL)                    /*!< FAN1_INST CONFIGURATION: ERR_RNG (Bit 10)                   */
#define FAN1_INST_CONFIGURATION_ERR_RNG_Msk   (0xc00UL)                 /*!< FAN1_INST CONFIGURATION: ERR_RNG (Bitfield-Mask: 0x03)      */
#define FAN1_INST_CONFIGURATION_DER_OPT_Pos   (12UL)                    /*!< FAN1_INST CONFIGURATION: DER_OPT (Bit 12)                   */
#define FAN1_INST_CONFIGURATION_DER_OPT_Msk   (0x3000UL)                /*!< FAN1_INST CONFIGURATION: DER_OPT (Bitfield-Mask: 0x03)      */
#define FAN1_INST_CONFIGURATION_DIS_GLITCH_Pos (14UL)                   /*!< FAN1_INST CONFIGURATION: DIS_GLITCH (Bit 14)                */
#define FAN1_INST_CONFIGURATION_DIS_GLITCH_Msk (0x4000UL)               /*!< FAN1_INST CONFIGURATION: DIS_GLITCH (Bitfield-Mask: 0x01)   */
#define FAN1_INST_CONFIGURATION_EN_RRC_Pos    (15UL)                    /*!< FAN1_INST CONFIGURATION: EN_RRC (Bit 15)                    */
#define FAN1_INST_CONFIGURATION_EN_RRC_Msk    (0x8000UL)                /*!< FAN1_INST CONFIGURATION: EN_RRC (Bitfield-Mask: 0x01)       */

/* ----------------------------  FAN1_INST_PWM_DIVIDE  ---------------------------- */
#define FAN1_INST_PWM_DIVIDE_PWM_DIVIDE_Pos   (0UL)                     /*!< FAN1_INST PWM_DIVIDE: PWM_DIVIDE (Bit 0)                    */
#define FAN1_INST_PWM_DIVIDE_PWM_DIVIDE_Msk   (0xffUL)                  /*!< FAN1_INST PWM_DIVIDE: PWM_DIVIDE (Bitfield-Mask: 0xff)      */

/* -------------------------------  FAN1_INST_GAIN  ------------------------------- */
#define FAN1_INST_GAIN_GAINP_Pos              (0UL)                     /*!< FAN1_INST GAIN: GAINP (Bit 0)                               */
#define FAN1_INST_GAIN_GAINP_Msk              (0x3UL)                   /*!< FAN1_INST GAIN: GAINP (Bitfield-Mask: 0x03)                 */
#define FAN1_INST_GAIN_GAINI_Pos              (2UL)                     /*!< FAN1_INST GAIN: GAINI (Bit 2)                               */
#define FAN1_INST_GAIN_GAINI_Msk              (0xcUL)                   /*!< FAN1_INST GAIN: GAINI (Bitfield-Mask: 0x03)                 */
#define FAN1_INST_GAIN_GAIND_Pos              (4UL)                     /*!< FAN1_INST GAIN: GAIND (Bit 4)                               */
#define FAN1_INST_GAIN_GAIND_Msk              (0x30UL)                  /*!< FAN1_INST GAIN: GAIND (Bitfield-Mask: 0x03)                 */

/* -----------------------  FAN1_INST_SPIN_UP_CONFIGURATION  ---------------------- */
#define FAN1_INST_SPIN_UP_CONFIGURATION_SPINUP_TIME_Pos (0UL)           /*!< FAN1_INST SPIN_UP_CONFIGURATION: SPINUP_TIME (Bit 0)        */
#define FAN1_INST_SPIN_UP_CONFIGURATION_SPINUP_TIME_Msk (0x3UL)         /*!< FAN1_INST SPIN_UP_CONFIGURATION: SPINUP_TIME (Bitfield-Mask: 0x03) */
#define FAN1_INST_SPIN_UP_CONFIGURATION_SPIN_LVL_Pos (2UL)              /*!< FAN1_INST SPIN_UP_CONFIGURATION: SPIN_LVL (Bit 2)           */
#define FAN1_INST_SPIN_UP_CONFIGURATION_SPIN_LVL_Msk (0x1cUL)           /*!< FAN1_INST SPIN_UP_CONFIGURATION: SPIN_LVL (Bitfield-Mask: 0x07) */
#define FAN1_INST_SPIN_UP_CONFIGURATION_NOKICK_Pos (5UL)                /*!< FAN1_INST SPIN_UP_CONFIGURATION: NOKICK (Bit 5)             */
#define FAN1_INST_SPIN_UP_CONFIGURATION_NOKICK_Msk (0x20UL)             /*!< FAN1_INST SPIN_UP_CONFIGURATION: NOKICK (Bitfield-Mask: 0x01) */
#define FAN1_INST_SPIN_UP_CONFIGURATION_DRIVE_FAIL_CNT_Pos (6UL)        /*!< FAN1_INST SPIN_UP_CONFIGURATION: DRIVE_FAIL_CNT (Bit 6)     */
#define FAN1_INST_SPIN_UP_CONFIGURATION_DRIVE_FAIL_CNT_Msk (0xc0UL)     /*!< FAN1_INST SPIN_UP_CONFIGURATION: DRIVE_FAIL_CNT (Bitfield-Mask: 0x03) */

/* -----------------------------  FAN1_INST_FAN_STEP  ----------------------------- */
#define FAN1_INST_FAN_STEP_FAN_STEP_Pos       (0UL)                     /*!< FAN1_INST FAN_STEP: FAN_STEP (Bit 0)                        */
#define FAN1_INST_FAN_STEP_FAN_STEP_Msk       (0xffUL)                  /*!< FAN1_INST FAN_STEP: FAN_STEP (Bitfield-Mask: 0xff)          */

/* ---------------------------  FAN1_INST_MINIMUM_DRIVE  -------------------------- */
#define FAN1_INST_MINIMUM_DRIVE_MIN_DRIVE_Pos (0UL)                     /*!< FAN1_INST MINIMUM_DRIVE: MIN_DRIVE (Bit 0)                  */
#define FAN1_INST_MINIMUM_DRIVE_MIN_DRIVE_Msk (0xffUL)                  /*!< FAN1_INST MINIMUM_DRIVE: MIN_DRIVE (Bitfield-Mask: 0xff)    */

/* -------------------------  FAN1_INST_VALID_TACH_COUNT  ------------------------- */
#define FAN1_INST_VALID_TACH_COUNT_VALID_TACH_CNT_Pos (0UL)             /*!< FAN1_INST VALID_TACH_COUNT: VALID_TACH_CNT (Bit 0)          */
#define FAN1_INST_VALID_TACH_COUNT_VALID_TACH_CNT_Msk (0xffUL)          /*!< FAN1_INST VALID_TACH_COUNT: VALID_TACH_CNT (Bitfield-Mask: 0xff) */

/* ------------------------  FAN1_INST_FAN_DRIVE_FAIL_BAND  ----------------------- */
#define FAN1_INST_FAN_DRIVE_FAIL_BAND_FAN_DRIVE_FAIL_BAND_Pos (3UL)     /*!< FAN1_INST FAN_DRIVE_FAIL_BAND: FAN_DRIVE_FAIL_BAND (Bit 3)  */
#define FAN1_INST_FAN_DRIVE_FAIL_BAND_FAN_DRIVE_FAIL_BAND_Msk (0xfff8UL) /*!< FAN1_INST FAN_DRIVE_FAIL_BAND: FAN_DRIVE_FAIL_BAND (Bitfield-Mask: 0x1fff) */

/* ----------------------------  FAN1_INST_TACH_TARGET  --------------------------- */
#define FAN1_INST_TACH_TARGET_TACH_TARGET_Pos (3UL)                     /*!< FAN1_INST TACH_TARGET: TACH_TARGET (Bit 3)                  */
#define FAN1_INST_TACH_TARGET_TACH_TARGET_Msk (0xfff8UL)                /*!< FAN1_INST TACH_TARGET: TACH_TARGET (Bitfield-Mask: 0x1fff)  */

/* ---------------------------  FAN1_INST_TACH_READING  --------------------------- */
#define FAN1_INST_TACH_READING_TACH_READING_Pos (3UL)                   /*!< FAN1_INST TACH_READING: TACH_READING (Bit 3)                */
#define FAN1_INST_TACH_READING_TACH_READING_Msk (0xfff8UL)              /*!< FAN1_INST TACH_READING: TACH_READING (Bitfield-Mask: 0x1fff) */

/* -----------------------  FAN1_INST_DRIVER_BASE_FREQUENCY  ---------------------- */
#define FAN1_INST_DRIVER_BASE_FREQUENCY_PWM_BASE_Pos (0UL)              /*!< FAN1_INST DRIVER_BASE_FREQUENCY: PWM_BASE (Bit 0)           */
#define FAN1_INST_DRIVER_BASE_FREQUENCY_PWM_BASE_Msk (0x3UL)            /*!< FAN1_INST DRIVER_BASE_FREQUENCY: PWM_BASE (Bitfield-Mask: 0x03) */

/* ------------------------------  FAN1_INST_STATUS  ------------------------------ */
#define FAN1_INST_STATUS_FAN_STALL_Pos        (0UL)                     /*!< FAN1_INST STATUS: FAN_STALL (Bit 0)                         */
#define FAN1_INST_STATUS_FAN_STALL_Msk        (0x1UL)                   /*!< FAN1_INST STATUS: FAN_STALL (Bitfield-Mask: 0x01)           */
#define FAN1_INST_STATUS_FAN_SPIN_Pos         (1UL)                     /*!< FAN1_INST STATUS: FAN_SPIN (Bit 1)                          */
#define FAN1_INST_STATUS_FAN_SPIN_Msk         (0x2UL)                   /*!< FAN1_INST STATUS: FAN_SPIN (Bitfield-Mask: 0x01)            */
#define FAN1_INST_STATUS_DRIVE_FAIL_Pos       (5UL)                     /*!< FAN1_INST STATUS: DRIVE_FAIL (Bit 5)                        */
#define FAN1_INST_STATUS_DRIVE_FAIL_Msk       (0x20UL)                  /*!< FAN1_INST STATUS: DRIVE_FAIL (Bitfield-Mask: 0x01)          */


/* ================================================================================ */
/* ================       struct 'LED0_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ------------------------------  LED0_INST_CONFIG  ------------------------------ */
#define LED0_INST_CONFIG_CONTROL_Pos          (0UL)                     /*!< LED0_INST CONFIG: CONTROL (Bit 0)                           */
#define LED0_INST_CONFIG_CONTROL_Msk          (0x3UL)                   /*!< LED0_INST CONFIG: CONTROL (Bitfield-Mask: 0x03)             */
#define LED0_INST_CONFIG_CLOCK_SOURCE_Pos     (2UL)                     /*!< LED0_INST CONFIG: CLOCK_SOURCE (Bit 2)                      */
#define LED0_INST_CONFIG_CLOCK_SOURCE_Msk     (0x4UL)                   /*!< LED0_INST CONFIG: CLOCK_SOURCE (Bitfield-Mask: 0x01)        */
#define LED0_INST_CONFIG_SYNCHRONIZE_Pos      (3UL)                     /*!< LED0_INST CONFIG: SYNCHRONIZE (Bit 3)                       */
#define LED0_INST_CONFIG_SYNCHRONIZE_Msk      (0x8UL)                   /*!< LED0_INST CONFIG: SYNCHRONIZE (Bitfield-Mask: 0x01)         */
#define LED0_INST_CONFIG_PWM_SIZE_Pos         (4UL)                     /*!< LED0_INST CONFIG: PWM_SIZE (Bit 4)                          */
#define LED0_INST_CONFIG_PWM_SIZE_Msk         (0x30UL)                  /*!< LED0_INST CONFIG: PWM_SIZE (Bitfield-Mask: 0x03)            */
#define LED0_INST_CONFIG_ENABLE_UPDATE_Pos    (6UL)                     /*!< LED0_INST CONFIG: ENABLE_UPDATE (Bit 6)                     */
#define LED0_INST_CONFIG_ENABLE_UPDATE_Msk    (0x40UL)                  /*!< LED0_INST CONFIG: ENABLE_UPDATE (Bitfield-Mask: 0x01)       */
#define LED0_INST_CONFIG_RESET_Pos            (7UL)                     /*!< LED0_INST CONFIG: RESET (Bit 7)                             */
#define LED0_INST_CONFIG_RESET_Msk            (0x80UL)                  /*!< LED0_INST CONFIG: RESET (Bitfield-Mask: 0x01)               */
#define LED0_INST_CONFIG_WDT_RELOAD_Pos       (8UL)                     /*!< LED0_INST CONFIG: WDT_RELOAD (Bit 8)                        */
#define LED0_INST_CONFIG_WDT_RELOAD_Msk       (0xff00UL)                /*!< LED0_INST CONFIG: WDT_RELOAD (Bitfield-Mask: 0xff)          */
#define LED0_INST_CONFIG_SYMMETRY_Pos         (16UL)                    /*!< LED0_INST CONFIG: SYMMETRY (Bit 16)                         */
#define LED0_INST_CONFIG_SYMMETRY_Msk         (0x10000UL)               /*!< LED0_INST CONFIG: SYMMETRY (Bitfield-Mask: 0x01)            */

/* ------------------------------  LED0_INST_LIMITS  ------------------------------ */
#define LED0_INST_LIMITS_MINIMUM_Pos          (0UL)                     /*!< LED0_INST LIMITS: MINIMUM (Bit 0)                           */
#define LED0_INST_LIMITS_MINIMUM_Msk          (0xffUL)                  /*!< LED0_INST LIMITS: MINIMUM (Bitfield-Mask: 0xff)             */
#define LED0_INST_LIMITS_MAXIMUM_Pos          (8UL)                     /*!< LED0_INST LIMITS: MAXIMUM (Bit 8)                           */
#define LED0_INST_LIMITS_MAXIMUM_Msk          (0xff00UL)                /*!< LED0_INST LIMITS: MAXIMUM (Bitfield-Mask: 0xff)             */

/* -------------------------------  LED0_INST_DELAY  ------------------------------ */
#define LED0_INST_DELAY_LOW_PULSE_Pos         (0UL)                     /*!< LED0_INST DELAY: LOW_PULSE (Bit 0)                          */
#define LED0_INST_DELAY_LOW_PULSE_Msk         (0xfffUL)                 /*!< LED0_INST DELAY: LOW_PULSE (Bitfield-Mask: 0xfff)           */
#define LED0_INST_DELAY_HIGH_PULSE_Pos        (12UL)                    /*!< LED0_INST DELAY: HIGH_PULSE (Bit 12)                        */
#define LED0_INST_DELAY_HIGH_PULSE_Msk        (0xfff000UL)              /*!< LED0_INST DELAY: HIGH_PULSE (Bitfield-Mask: 0xfff)          */

/* --------------------------  LED0_INST_UPDATE_STEPSIZE  ------------------------- */
#define LED0_INST_UPDATE_STEPSIZE_STEP0_Pos   (0UL)                     /*!< LED0_INST UPDATE_STEPSIZE: STEP0 (Bit 0)                    */
#define LED0_INST_UPDATE_STEPSIZE_STEP0_Msk   (0xfUL)                   /*!< LED0_INST UPDATE_STEPSIZE: STEP0 (Bitfield-Mask: 0x0f)      */
#define LED0_INST_UPDATE_STEPSIZE_STEP1_Pos   (4UL)                     /*!< LED0_INST UPDATE_STEPSIZE: STEP1 (Bit 4)                    */
#define LED0_INST_UPDATE_STEPSIZE_STEP1_Msk   (0xf0UL)                  /*!< LED0_INST UPDATE_STEPSIZE: STEP1 (Bitfield-Mask: 0x0f)      */
#define LED0_INST_UPDATE_STEPSIZE_STEP2_Pos   (8UL)                     /*!< LED0_INST UPDATE_STEPSIZE: STEP2 (Bit 8)                    */
#define LED0_INST_UPDATE_STEPSIZE_STEP2_Msk   (0xf00UL)                 /*!< LED0_INST UPDATE_STEPSIZE: STEP2 (Bitfield-Mask: 0x0f)      */
#define LED0_INST_UPDATE_STEPSIZE_STEP3_Pos   (12UL)                    /*!< LED0_INST UPDATE_STEPSIZE: STEP3 (Bit 12)                   */
#define LED0_INST_UPDATE_STEPSIZE_STEP3_Msk   (0xf000UL)                /*!< LED0_INST UPDATE_STEPSIZE: STEP3 (Bitfield-Mask: 0x0f)      */
#define LED0_INST_UPDATE_STEPSIZE_STEP4_Pos   (16UL)                    /*!< LED0_INST UPDATE_STEPSIZE: STEP4 (Bit 16)                   */
#define LED0_INST_UPDATE_STEPSIZE_STEP4_Msk   (0xf0000UL)               /*!< LED0_INST UPDATE_STEPSIZE: STEP4 (Bitfield-Mask: 0x0f)      */
#define LED0_INST_UPDATE_STEPSIZE_STEP5_Pos   (20UL)                    /*!< LED0_INST UPDATE_STEPSIZE: STEP5 (Bit 20)                   */
#define LED0_INST_UPDATE_STEPSIZE_STEP5_Msk   (0xf00000UL)              /*!< LED0_INST UPDATE_STEPSIZE: STEP5 (Bitfield-Mask: 0x0f)      */
#define LED0_INST_UPDATE_STEPSIZE_STEP6_Pos   (24UL)                    /*!< LED0_INST UPDATE_STEPSIZE: STEP6 (Bit 24)                   */
#define LED0_INST_UPDATE_STEPSIZE_STEP6_Msk   (0xf000000UL)             /*!< LED0_INST UPDATE_STEPSIZE: STEP6 (Bitfield-Mask: 0x0f)      */
#define LED0_INST_UPDATE_STEPSIZE_STEP7_Pos   (28UL)                    /*!< LED0_INST UPDATE_STEPSIZE: STEP7 (Bit 28)                   */
#define LED0_INST_UPDATE_STEPSIZE_STEP7_Msk   (0xf0000000UL)            /*!< LED0_INST UPDATE_STEPSIZE: STEP7 (Bitfield-Mask: 0x0f)      */

/* --------------------------  LED0_INST_UPDATE_INTERVAL  ------------------------- */
#define LED0_INST_UPDATE_INTERVAL_INTERVAL0_Pos (0UL)                   /*!< LED0_INST UPDATE_INTERVAL: INTERVAL0 (Bit 0)                */
#define LED0_INST_UPDATE_INTERVAL_INTERVAL0_Msk (0xfUL)                 /*!< LED0_INST UPDATE_INTERVAL: INTERVAL0 (Bitfield-Mask: 0x0f)  */
#define LED0_INST_UPDATE_INTERVAL_INTERVAL1_Pos (4UL)                   /*!< LED0_INST UPDATE_INTERVAL: INTERVAL1 (Bit 4)                */
#define LED0_INST_UPDATE_INTERVAL_INTERVAL1_Msk (0xf0UL)                /*!< LED0_INST UPDATE_INTERVAL: INTERVAL1 (Bitfield-Mask: 0x0f)  */
#define LED0_INST_UPDATE_INTERVAL_INTERVAL2_Pos (8UL)                   /*!< LED0_INST UPDATE_INTERVAL: INTERVAL2 (Bit 8)                */
#define LED0_INST_UPDATE_INTERVAL_INTERVAL2_Msk (0xf00UL)               /*!< LED0_INST UPDATE_INTERVAL: INTERVAL2 (Bitfield-Mask: 0x0f)  */
#define LED0_INST_UPDATE_INTERVAL_INTERVAL3_Pos (12UL)                  /*!< LED0_INST UPDATE_INTERVAL: INTERVAL3 (Bit 12)               */
#define LED0_INST_UPDATE_INTERVAL_INTERVAL3_Msk (0xf000UL)              /*!< LED0_INST UPDATE_INTERVAL: INTERVAL3 (Bitfield-Mask: 0x0f)  */
#define LED0_INST_UPDATE_INTERVAL_INTERVAL4_Pos (16UL)                  /*!< LED0_INST UPDATE_INTERVAL: INTERVAL4 (Bit 16)               */
#define LED0_INST_UPDATE_INTERVAL_INTERVAL4_Msk (0xf0000UL)             /*!< LED0_INST UPDATE_INTERVAL: INTERVAL4 (Bitfield-Mask: 0x0f)  */
#define LED0_INST_UPDATE_INTERVAL_INTERVAL5_Pos (20UL)                  /*!< LED0_INST UPDATE_INTERVAL: INTERVAL5 (Bit 20)               */
#define LED0_INST_UPDATE_INTERVAL_INTERVAL5_Msk (0xf00000UL)            /*!< LED0_INST UPDATE_INTERVAL: INTERVAL5 (Bitfield-Mask: 0x0f)  */
#define LED0_INST_UPDATE_INTERVAL_INTERVAL6_Pos (24UL)                  /*!< LED0_INST UPDATE_INTERVAL: INTERVAL6 (Bit 24)               */
#define LED0_INST_UPDATE_INTERVAL_INTERVAL6_Msk (0xf000000UL)           /*!< LED0_INST UPDATE_INTERVAL: INTERVAL6 (Bitfield-Mask: 0x0f)  */
#define LED0_INST_UPDATE_INTERVAL_INTERVAL7_Pos (28UL)                  /*!< LED0_INST UPDATE_INTERVAL: INTERVAL7 (Bit 28)               */
#define LED0_INST_UPDATE_INTERVAL_INTERVAL7_Msk (0xf0000000UL)          /*!< LED0_INST UPDATE_INTERVAL: INTERVAL7 (Bitfield-Mask: 0x0f)  */

/* -------------------------  LED0_INST_LED_OUTPUT_DELAY  ------------------------- */
#define LED0_INST_LED_OUTPUT_DELAY_OUTPUT_DELAY_Pos (0UL)               /*!< LED0_INST LED_OUTPUT_DELAY: OUTPUT_DELAY (Bit 0)            */
#define LED0_INST_LED_OUTPUT_DELAY_OUTPUT_DELAY_Msk (0xffUL)            /*!< LED0_INST LED_OUTPUT_DELAY: OUTPUT_DELAY (Bitfield-Mask: 0xff) */


/* ================================================================================ */
/* ================       struct 'LED1_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ------------------------------  LED1_INST_CONFIG  ------------------------------ */
#define LED1_INST_CONFIG_CONTROL_Pos          (0UL)                     /*!< LED1_INST CONFIG: CONTROL (Bit 0)                           */
#define LED1_INST_CONFIG_CONTROL_Msk          (0x3UL)                   /*!< LED1_INST CONFIG: CONTROL (Bitfield-Mask: 0x03)             */
#define LED1_INST_CONFIG_CLOCK_SOURCE_Pos     (2UL)                     /*!< LED1_INST CONFIG: CLOCK_SOURCE (Bit 2)                      */
#define LED1_INST_CONFIG_CLOCK_SOURCE_Msk     (0x4UL)                   /*!< LED1_INST CONFIG: CLOCK_SOURCE (Bitfield-Mask: 0x01)        */
#define LED1_INST_CONFIG_SYNCHRONIZE_Pos      (3UL)                     /*!< LED1_INST CONFIG: SYNCHRONIZE (Bit 3)                       */
#define LED1_INST_CONFIG_SYNCHRONIZE_Msk      (0x8UL)                   /*!< LED1_INST CONFIG: SYNCHRONIZE (Bitfield-Mask: 0x01)         */
#define LED1_INST_CONFIG_PWM_SIZE_Pos         (4UL)                     /*!< LED1_INST CONFIG: PWM_SIZE (Bit 4)                          */
#define LED1_INST_CONFIG_PWM_SIZE_Msk         (0x30UL)                  /*!< LED1_INST CONFIG: PWM_SIZE (Bitfield-Mask: 0x03)            */
#define LED1_INST_CONFIG_ENABLE_UPDATE_Pos    (6UL)                     /*!< LED1_INST CONFIG: ENABLE_UPDATE (Bit 6)                     */
#define LED1_INST_CONFIG_ENABLE_UPDATE_Msk    (0x40UL)                  /*!< LED1_INST CONFIG: ENABLE_UPDATE (Bitfield-Mask: 0x01)       */
#define LED1_INST_CONFIG_RESET_Pos            (7UL)                     /*!< LED1_INST CONFIG: RESET (Bit 7)                             */
#define LED1_INST_CONFIG_RESET_Msk            (0x80UL)                  /*!< LED1_INST CONFIG: RESET (Bitfield-Mask: 0x01)               */
#define LED1_INST_CONFIG_WDT_RELOAD_Pos       (8UL)                     /*!< LED1_INST CONFIG: WDT_RELOAD (Bit 8)                        */
#define LED1_INST_CONFIG_WDT_RELOAD_Msk       (0xff00UL)                /*!< LED1_INST CONFIG: WDT_RELOAD (Bitfield-Mask: 0xff)          */
#define LED1_INST_CONFIG_SYMMETRY_Pos         (16UL)                    /*!< LED1_INST CONFIG: SYMMETRY (Bit 16)                         */
#define LED1_INST_CONFIG_SYMMETRY_Msk         (0x10000UL)               /*!< LED1_INST CONFIG: SYMMETRY (Bitfield-Mask: 0x01)            */

/* ------------------------------  LED1_INST_LIMITS  ------------------------------ */
#define LED1_INST_LIMITS_MINIMUM_Pos          (0UL)                     /*!< LED1_INST LIMITS: MINIMUM (Bit 0)                           */
#define LED1_INST_LIMITS_MINIMUM_Msk          (0xffUL)                  /*!< LED1_INST LIMITS: MINIMUM (Bitfield-Mask: 0xff)             */
#define LED1_INST_LIMITS_MAXIMUM_Pos          (8UL)                     /*!< LED1_INST LIMITS: MAXIMUM (Bit 8)                           */
#define LED1_INST_LIMITS_MAXIMUM_Msk          (0xff00UL)                /*!< LED1_INST LIMITS: MAXIMUM (Bitfield-Mask: 0xff)             */

/* -------------------------------  LED1_INST_DELAY  ------------------------------ */
#define LED1_INST_DELAY_LOW_PULSE_Pos         (0UL)                     /*!< LED1_INST DELAY: LOW_PULSE (Bit 0)                          */
#define LED1_INST_DELAY_LOW_PULSE_Msk         (0xfffUL)                 /*!< LED1_INST DELAY: LOW_PULSE (Bitfield-Mask: 0xfff)           */
#define LED1_INST_DELAY_HIGH_PULSE_Pos        (12UL)                    /*!< LED1_INST DELAY: HIGH_PULSE (Bit 12)                        */
#define LED1_INST_DELAY_HIGH_PULSE_Msk        (0xfff000UL)              /*!< LED1_INST DELAY: HIGH_PULSE (Bitfield-Mask: 0xfff)          */

/* --------------------------  LED1_INST_UPDATE_STEPSIZE  ------------------------- */
#define LED1_INST_UPDATE_STEPSIZE_STEP0_Pos   (0UL)                     /*!< LED1_INST UPDATE_STEPSIZE: STEP0 (Bit 0)                    */
#define LED1_INST_UPDATE_STEPSIZE_STEP0_Msk   (0xfUL)                   /*!< LED1_INST UPDATE_STEPSIZE: STEP0 (Bitfield-Mask: 0x0f)      */
#define LED1_INST_UPDATE_STEPSIZE_STEP1_Pos   (4UL)                     /*!< LED1_INST UPDATE_STEPSIZE: STEP1 (Bit 4)                    */
#define LED1_INST_UPDATE_STEPSIZE_STEP1_Msk   (0xf0UL)                  /*!< LED1_INST UPDATE_STEPSIZE: STEP1 (Bitfield-Mask: 0x0f)      */
#define LED1_INST_UPDATE_STEPSIZE_STEP2_Pos   (8UL)                     /*!< LED1_INST UPDATE_STEPSIZE: STEP2 (Bit 8)                    */
#define LED1_INST_UPDATE_STEPSIZE_STEP2_Msk   (0xf00UL)                 /*!< LED1_INST UPDATE_STEPSIZE: STEP2 (Bitfield-Mask: 0x0f)      */
#define LED1_INST_UPDATE_STEPSIZE_STEP3_Pos   (12UL)                    /*!< LED1_INST UPDATE_STEPSIZE: STEP3 (Bit 12)                   */
#define LED1_INST_UPDATE_STEPSIZE_STEP3_Msk   (0xf000UL)                /*!< LED1_INST UPDATE_STEPSIZE: STEP3 (Bitfield-Mask: 0x0f)      */
#define LED1_INST_UPDATE_STEPSIZE_STEP4_Pos   (16UL)                    /*!< LED1_INST UPDATE_STEPSIZE: STEP4 (Bit 16)                   */
#define LED1_INST_UPDATE_STEPSIZE_STEP4_Msk   (0xf0000UL)               /*!< LED1_INST UPDATE_STEPSIZE: STEP4 (Bitfield-Mask: 0x0f)      */
#define LED1_INST_UPDATE_STEPSIZE_STEP5_Pos   (20UL)                    /*!< LED1_INST UPDATE_STEPSIZE: STEP5 (Bit 20)                   */
#define LED1_INST_UPDATE_STEPSIZE_STEP5_Msk   (0xf00000UL)              /*!< LED1_INST UPDATE_STEPSIZE: STEP5 (Bitfield-Mask: 0x0f)      */
#define LED1_INST_UPDATE_STEPSIZE_STEP6_Pos   (24UL)                    /*!< LED1_INST UPDATE_STEPSIZE: STEP6 (Bit 24)                   */
#define LED1_INST_UPDATE_STEPSIZE_STEP6_Msk   (0xf000000UL)             /*!< LED1_INST UPDATE_STEPSIZE: STEP6 (Bitfield-Mask: 0x0f)      */
#define LED1_INST_UPDATE_STEPSIZE_STEP7_Pos   (28UL)                    /*!< LED1_INST UPDATE_STEPSIZE: STEP7 (Bit 28)                   */
#define LED1_INST_UPDATE_STEPSIZE_STEP7_Msk   (0xf0000000UL)            /*!< LED1_INST UPDATE_STEPSIZE: STEP7 (Bitfield-Mask: 0x0f)      */

/* --------------------------  LED1_INST_UPDATE_INTERVAL  ------------------------- */
#define LED1_INST_UPDATE_INTERVAL_INTERVAL0_Pos (0UL)                   /*!< LED1_INST UPDATE_INTERVAL: INTERVAL0 (Bit 0)                */
#define LED1_INST_UPDATE_INTERVAL_INTERVAL0_Msk (0xfUL)                 /*!< LED1_INST UPDATE_INTERVAL: INTERVAL0 (Bitfield-Mask: 0x0f)  */
#define LED1_INST_UPDATE_INTERVAL_INTERVAL1_Pos (4UL)                   /*!< LED1_INST UPDATE_INTERVAL: INTERVAL1 (Bit 4)                */
#define LED1_INST_UPDATE_INTERVAL_INTERVAL1_Msk (0xf0UL)                /*!< LED1_INST UPDATE_INTERVAL: INTERVAL1 (Bitfield-Mask: 0x0f)  */
#define LED1_INST_UPDATE_INTERVAL_INTERVAL2_Pos (8UL)                   /*!< LED1_INST UPDATE_INTERVAL: INTERVAL2 (Bit 8)                */
#define LED1_INST_UPDATE_INTERVAL_INTERVAL2_Msk (0xf00UL)               /*!< LED1_INST UPDATE_INTERVAL: INTERVAL2 (Bitfield-Mask: 0x0f)  */
#define LED1_INST_UPDATE_INTERVAL_INTERVAL3_Pos (12UL)                  /*!< LED1_INST UPDATE_INTERVAL: INTERVAL3 (Bit 12)               */
#define LED1_INST_UPDATE_INTERVAL_INTERVAL3_Msk (0xf000UL)              /*!< LED1_INST UPDATE_INTERVAL: INTERVAL3 (Bitfield-Mask: 0x0f)  */
#define LED1_INST_UPDATE_INTERVAL_INTERVAL4_Pos (16UL)                  /*!< LED1_INST UPDATE_INTERVAL: INTERVAL4 (Bit 16)               */
#define LED1_INST_UPDATE_INTERVAL_INTERVAL4_Msk (0xf0000UL)             /*!< LED1_INST UPDATE_INTERVAL: INTERVAL4 (Bitfield-Mask: 0x0f)  */
#define LED1_INST_UPDATE_INTERVAL_INTERVAL5_Pos (20UL)                  /*!< LED1_INST UPDATE_INTERVAL: INTERVAL5 (Bit 20)               */
#define LED1_INST_UPDATE_INTERVAL_INTERVAL5_Msk (0xf00000UL)            /*!< LED1_INST UPDATE_INTERVAL: INTERVAL5 (Bitfield-Mask: 0x0f)  */
#define LED1_INST_UPDATE_INTERVAL_INTERVAL6_Pos (24UL)                  /*!< LED1_INST UPDATE_INTERVAL: INTERVAL6 (Bit 24)               */
#define LED1_INST_UPDATE_INTERVAL_INTERVAL6_Msk (0xf000000UL)           /*!< LED1_INST UPDATE_INTERVAL: INTERVAL6 (Bitfield-Mask: 0x0f)  */
#define LED1_INST_UPDATE_INTERVAL_INTERVAL7_Pos (28UL)                  /*!< LED1_INST UPDATE_INTERVAL: INTERVAL7 (Bit 28)               */
#define LED1_INST_UPDATE_INTERVAL_INTERVAL7_Msk (0xf0000000UL)          /*!< LED1_INST UPDATE_INTERVAL: INTERVAL7 (Bitfield-Mask: 0x0f)  */

/* -------------------------  LED1_INST_LED_OUTPUT_DELAY  ------------------------- */
#define LED1_INST_LED_OUTPUT_DELAY_OUTPUT_DELAY_Pos (0UL)               /*!< LED1_INST LED_OUTPUT_DELAY: OUTPUT_DELAY (Bit 0)            */
#define LED1_INST_LED_OUTPUT_DELAY_OUTPUT_DELAY_Msk (0xffUL)            /*!< LED1_INST LED_OUTPUT_DELAY: OUTPUT_DELAY (Bitfield-Mask: 0xff) */


/* ================================================================================ */
/* ================       struct 'LED2_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ------------------------------  LED2_INST_CONFIG  ------------------------------ */
#define LED2_INST_CONFIG_CONTROL_Pos          (0UL)                     /*!< LED2_INST CONFIG: CONTROL (Bit 0)                           */
#define LED2_INST_CONFIG_CONTROL_Msk          (0x3UL)                   /*!< LED2_INST CONFIG: CONTROL (Bitfield-Mask: 0x03)             */
#define LED2_INST_CONFIG_CLOCK_SOURCE_Pos     (2UL)                     /*!< LED2_INST CONFIG: CLOCK_SOURCE (Bit 2)                      */
#define LED2_INST_CONFIG_CLOCK_SOURCE_Msk     (0x4UL)                   /*!< LED2_INST CONFIG: CLOCK_SOURCE (Bitfield-Mask: 0x01)        */
#define LED2_INST_CONFIG_SYNCHRONIZE_Pos      (3UL)                     /*!< LED2_INST CONFIG: SYNCHRONIZE (Bit 3)                       */
#define LED2_INST_CONFIG_SYNCHRONIZE_Msk      (0x8UL)                   /*!< LED2_INST CONFIG: SYNCHRONIZE (Bitfield-Mask: 0x01)         */
#define LED2_INST_CONFIG_PWM_SIZE_Pos         (4UL)                     /*!< LED2_INST CONFIG: PWM_SIZE (Bit 4)                          */
#define LED2_INST_CONFIG_PWM_SIZE_Msk         (0x30UL)                  /*!< LED2_INST CONFIG: PWM_SIZE (Bitfield-Mask: 0x03)            */
#define LED2_INST_CONFIG_ENABLE_UPDATE_Pos    (6UL)                     /*!< LED2_INST CONFIG: ENABLE_UPDATE (Bit 6)                     */
#define LED2_INST_CONFIG_ENABLE_UPDATE_Msk    (0x40UL)                  /*!< LED2_INST CONFIG: ENABLE_UPDATE (Bitfield-Mask: 0x01)       */
#define LED2_INST_CONFIG_RESET_Pos            (7UL)                     /*!< LED2_INST CONFIG: RESET (Bit 7)                             */
#define LED2_INST_CONFIG_RESET_Msk            (0x80UL)                  /*!< LED2_INST CONFIG: RESET (Bitfield-Mask: 0x01)               */
#define LED2_INST_CONFIG_WDT_RELOAD_Pos       (8UL)                     /*!< LED2_INST CONFIG: WDT_RELOAD (Bit 8)                        */
#define LED2_INST_CONFIG_WDT_RELOAD_Msk       (0xff00UL)                /*!< LED2_INST CONFIG: WDT_RELOAD (Bitfield-Mask: 0xff)          */
#define LED2_INST_CONFIG_SYMMETRY_Pos         (16UL)                    /*!< LED2_INST CONFIG: SYMMETRY (Bit 16)                         */
#define LED2_INST_CONFIG_SYMMETRY_Msk         (0x10000UL)               /*!< LED2_INST CONFIG: SYMMETRY (Bitfield-Mask: 0x01)            */

/* ------------------------------  LED2_INST_LIMITS  ------------------------------ */
#define LED2_INST_LIMITS_MINIMUM_Pos          (0UL)                     /*!< LED2_INST LIMITS: MINIMUM (Bit 0)                           */
#define LED2_INST_LIMITS_MINIMUM_Msk          (0xffUL)                  /*!< LED2_INST LIMITS: MINIMUM (Bitfield-Mask: 0xff)             */
#define LED2_INST_LIMITS_MAXIMUM_Pos          (8UL)                     /*!< LED2_INST LIMITS: MAXIMUM (Bit 8)                           */
#define LED2_INST_LIMITS_MAXIMUM_Msk          (0xff00UL)                /*!< LED2_INST LIMITS: MAXIMUM (Bitfield-Mask: 0xff)             */

/* -------------------------------  LED2_INST_DELAY  ------------------------------ */
#define LED2_INST_DELAY_LOW_PULSE_Pos         (0UL)                     /*!< LED2_INST DELAY: LOW_PULSE (Bit 0)                          */
#define LED2_INST_DELAY_LOW_PULSE_Msk         (0xfffUL)                 /*!< LED2_INST DELAY: LOW_PULSE (Bitfield-Mask: 0xfff)           */
#define LED2_INST_DELAY_HIGH_PULSE_Pos        (12UL)                    /*!< LED2_INST DELAY: HIGH_PULSE (Bit 12)                        */
#define LED2_INST_DELAY_HIGH_PULSE_Msk        (0xfff000UL)              /*!< LED2_INST DELAY: HIGH_PULSE (Bitfield-Mask: 0xfff)          */

/* --------------------------  LED2_INST_UPDATE_STEPSIZE  ------------------------- */
#define LED2_INST_UPDATE_STEPSIZE_STEP0_Pos   (0UL)                     /*!< LED2_INST UPDATE_STEPSIZE: STEP0 (Bit 0)                    */
#define LED2_INST_UPDATE_STEPSIZE_STEP0_Msk   (0xfUL)                   /*!< LED2_INST UPDATE_STEPSIZE: STEP0 (Bitfield-Mask: 0x0f)      */
#define LED2_INST_UPDATE_STEPSIZE_STEP1_Pos   (4UL)                     /*!< LED2_INST UPDATE_STEPSIZE: STEP1 (Bit 4)                    */
#define LED2_INST_UPDATE_STEPSIZE_STEP1_Msk   (0xf0UL)                  /*!< LED2_INST UPDATE_STEPSIZE: STEP1 (Bitfield-Mask: 0x0f)      */
#define LED2_INST_UPDATE_STEPSIZE_STEP2_Pos   (8UL)                     /*!< LED2_INST UPDATE_STEPSIZE: STEP2 (Bit 8)                    */
#define LED2_INST_UPDATE_STEPSIZE_STEP2_Msk   (0xf00UL)                 /*!< LED2_INST UPDATE_STEPSIZE: STEP2 (Bitfield-Mask: 0x0f)      */
#define LED2_INST_UPDATE_STEPSIZE_STEP3_Pos   (12UL)                    /*!< LED2_INST UPDATE_STEPSIZE: STEP3 (Bit 12)                   */
#define LED2_INST_UPDATE_STEPSIZE_STEP3_Msk   (0xf000UL)                /*!< LED2_INST UPDATE_STEPSIZE: STEP3 (Bitfield-Mask: 0x0f)      */
#define LED2_INST_UPDATE_STEPSIZE_STEP4_Pos   (16UL)                    /*!< LED2_INST UPDATE_STEPSIZE: STEP4 (Bit 16)                   */
#define LED2_INST_UPDATE_STEPSIZE_STEP4_Msk   (0xf0000UL)               /*!< LED2_INST UPDATE_STEPSIZE: STEP4 (Bitfield-Mask: 0x0f)      */
#define LED2_INST_UPDATE_STEPSIZE_STEP5_Pos   (20UL)                    /*!< LED2_INST UPDATE_STEPSIZE: STEP5 (Bit 20)                   */
#define LED2_INST_UPDATE_STEPSIZE_STEP5_Msk   (0xf00000UL)              /*!< LED2_INST UPDATE_STEPSIZE: STEP5 (Bitfield-Mask: 0x0f)      */
#define LED2_INST_UPDATE_STEPSIZE_STEP6_Pos   (24UL)                    /*!< LED2_INST UPDATE_STEPSIZE: STEP6 (Bit 24)                   */
#define LED2_INST_UPDATE_STEPSIZE_STEP6_Msk   (0xf000000UL)             /*!< LED2_INST UPDATE_STEPSIZE: STEP6 (Bitfield-Mask: 0x0f)      */
#define LED2_INST_UPDATE_STEPSIZE_STEP7_Pos   (28UL)                    /*!< LED2_INST UPDATE_STEPSIZE: STEP7 (Bit 28)                   */
#define LED2_INST_UPDATE_STEPSIZE_STEP7_Msk   (0xf0000000UL)            /*!< LED2_INST UPDATE_STEPSIZE: STEP7 (Bitfield-Mask: 0x0f)      */

/* --------------------------  LED2_INST_UPDATE_INTERVAL  ------------------------- */
#define LED2_INST_UPDATE_INTERVAL_INTERVAL0_Pos (0UL)                   /*!< LED2_INST UPDATE_INTERVAL: INTERVAL0 (Bit 0)                */
#define LED2_INST_UPDATE_INTERVAL_INTERVAL0_Msk (0xfUL)                 /*!< LED2_INST UPDATE_INTERVAL: INTERVAL0 (Bitfield-Mask: 0x0f)  */
#define LED2_INST_UPDATE_INTERVAL_INTERVAL1_Pos (4UL)                   /*!< LED2_INST UPDATE_INTERVAL: INTERVAL1 (Bit 4)                */
#define LED2_INST_UPDATE_INTERVAL_INTERVAL1_Msk (0xf0UL)                /*!< LED2_INST UPDATE_INTERVAL: INTERVAL1 (Bitfield-Mask: 0x0f)  */
#define LED2_INST_UPDATE_INTERVAL_INTERVAL2_Pos (8UL)                   /*!< LED2_INST UPDATE_INTERVAL: INTERVAL2 (Bit 8)                */
#define LED2_INST_UPDATE_INTERVAL_INTERVAL2_Msk (0xf00UL)               /*!< LED2_INST UPDATE_INTERVAL: INTERVAL2 (Bitfield-Mask: 0x0f)  */
#define LED2_INST_UPDATE_INTERVAL_INTERVAL3_Pos (12UL)                  /*!< LED2_INST UPDATE_INTERVAL: INTERVAL3 (Bit 12)               */
#define LED2_INST_UPDATE_INTERVAL_INTERVAL3_Msk (0xf000UL)              /*!< LED2_INST UPDATE_INTERVAL: INTERVAL3 (Bitfield-Mask: 0x0f)  */
#define LED2_INST_UPDATE_INTERVAL_INTERVAL4_Pos (16UL)                  /*!< LED2_INST UPDATE_INTERVAL: INTERVAL4 (Bit 16)               */
#define LED2_INST_UPDATE_INTERVAL_INTERVAL4_Msk (0xf0000UL)             /*!< LED2_INST UPDATE_INTERVAL: INTERVAL4 (Bitfield-Mask: 0x0f)  */
#define LED2_INST_UPDATE_INTERVAL_INTERVAL5_Pos (20UL)                  /*!< LED2_INST UPDATE_INTERVAL: INTERVAL5 (Bit 20)               */
#define LED2_INST_UPDATE_INTERVAL_INTERVAL5_Msk (0xf00000UL)            /*!< LED2_INST UPDATE_INTERVAL: INTERVAL5 (Bitfield-Mask: 0x0f)  */
#define LED2_INST_UPDATE_INTERVAL_INTERVAL6_Pos (24UL)                  /*!< LED2_INST UPDATE_INTERVAL: INTERVAL6 (Bit 24)               */
#define LED2_INST_UPDATE_INTERVAL_INTERVAL6_Msk (0xf000000UL)           /*!< LED2_INST UPDATE_INTERVAL: INTERVAL6 (Bitfield-Mask: 0x0f)  */
#define LED2_INST_UPDATE_INTERVAL_INTERVAL7_Pos (28UL)                  /*!< LED2_INST UPDATE_INTERVAL: INTERVAL7 (Bit 28)               */
#define LED2_INST_UPDATE_INTERVAL_INTERVAL7_Msk (0xf0000000UL)          /*!< LED2_INST UPDATE_INTERVAL: INTERVAL7 (Bitfield-Mask: 0x0f)  */

/* -------------------------  LED2_INST_LED_OUTPUT_DELAY  ------------------------- */
#define LED2_INST_LED_OUTPUT_DELAY_OUTPUT_DELAY_Pos (0UL)               /*!< LED2_INST LED_OUTPUT_DELAY: OUTPUT_DELAY (Bit 0)            */
#define LED2_INST_LED_OUTPUT_DELAY_OUTPUT_DELAY_Msk (0xffUL)            /*!< LED2_INST LED_OUTPUT_DELAY: OUTPUT_DELAY (Bitfield-Mask: 0xff) */


/* ================================================================================ */
/* ================       struct 'LED3_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ------------------------------  LED3_INST_CONFIG  ------------------------------ */
#define LED3_INST_CONFIG_CONTROL_Pos          (0UL)                     /*!< LED3_INST CONFIG: CONTROL (Bit 0)                           */
#define LED3_INST_CONFIG_CONTROL_Msk          (0x3UL)                   /*!< LED3_INST CONFIG: CONTROL (Bitfield-Mask: 0x03)             */
#define LED3_INST_CONFIG_CLOCK_SOURCE_Pos     (2UL)                     /*!< LED3_INST CONFIG: CLOCK_SOURCE (Bit 2)                      */
#define LED3_INST_CONFIG_CLOCK_SOURCE_Msk     (0x4UL)                   /*!< LED3_INST CONFIG: CLOCK_SOURCE (Bitfield-Mask: 0x01)        */
#define LED3_INST_CONFIG_SYNCHRONIZE_Pos      (3UL)                     /*!< LED3_INST CONFIG: SYNCHRONIZE (Bit 3)                       */
#define LED3_INST_CONFIG_SYNCHRONIZE_Msk      (0x8UL)                   /*!< LED3_INST CONFIG: SYNCHRONIZE (Bitfield-Mask: 0x01)         */
#define LED3_INST_CONFIG_PWM_SIZE_Pos         (4UL)                     /*!< LED3_INST CONFIG: PWM_SIZE (Bit 4)                          */
#define LED3_INST_CONFIG_PWM_SIZE_Msk         (0x30UL)                  /*!< LED3_INST CONFIG: PWM_SIZE (Bitfield-Mask: 0x03)            */
#define LED3_INST_CONFIG_ENABLE_UPDATE_Pos    (6UL)                     /*!< LED3_INST CONFIG: ENABLE_UPDATE (Bit 6)                     */
#define LED3_INST_CONFIG_ENABLE_UPDATE_Msk    (0x40UL)                  /*!< LED3_INST CONFIG: ENABLE_UPDATE (Bitfield-Mask: 0x01)       */
#define LED3_INST_CONFIG_RESET_Pos            (7UL)                     /*!< LED3_INST CONFIG: RESET (Bit 7)                             */
#define LED3_INST_CONFIG_RESET_Msk            (0x80UL)                  /*!< LED3_INST CONFIG: RESET (Bitfield-Mask: 0x01)               */
#define LED3_INST_CONFIG_WDT_RELOAD_Pos       (8UL)                     /*!< LED3_INST CONFIG: WDT_RELOAD (Bit 8)                        */
#define LED3_INST_CONFIG_WDT_RELOAD_Msk       (0xff00UL)                /*!< LED3_INST CONFIG: WDT_RELOAD (Bitfield-Mask: 0xff)          */
#define LED3_INST_CONFIG_SYMMETRY_Pos         (16UL)                    /*!< LED3_INST CONFIG: SYMMETRY (Bit 16)                         */
#define LED3_INST_CONFIG_SYMMETRY_Msk         (0x10000UL)               /*!< LED3_INST CONFIG: SYMMETRY (Bitfield-Mask: 0x01)            */

/* ------------------------------  LED3_INST_LIMITS  ------------------------------ */
#define LED3_INST_LIMITS_MINIMUM_Pos          (0UL)                     /*!< LED3_INST LIMITS: MINIMUM (Bit 0)                           */
#define LED3_INST_LIMITS_MINIMUM_Msk          (0xffUL)                  /*!< LED3_INST LIMITS: MINIMUM (Bitfield-Mask: 0xff)             */
#define LED3_INST_LIMITS_MAXIMUM_Pos          (8UL)                     /*!< LED3_INST LIMITS: MAXIMUM (Bit 8)                           */
#define LED3_INST_LIMITS_MAXIMUM_Msk          (0xff00UL)                /*!< LED3_INST LIMITS: MAXIMUM (Bitfield-Mask: 0xff)             */

/* -------------------------------  LED3_INST_DELAY  ------------------------------ */
#define LED3_INST_DELAY_LOW_PULSE_Pos         (0UL)                     /*!< LED3_INST DELAY: LOW_PULSE (Bit 0)                          */
#define LED3_INST_DELAY_LOW_PULSE_Msk         (0xfffUL)                 /*!< LED3_INST DELAY: LOW_PULSE (Bitfield-Mask: 0xfff)           */
#define LED3_INST_DELAY_HIGH_PULSE_Pos        (12UL)                    /*!< LED3_INST DELAY: HIGH_PULSE (Bit 12)                        */
#define LED3_INST_DELAY_HIGH_PULSE_Msk        (0xfff000UL)              /*!< LED3_INST DELAY: HIGH_PULSE (Bitfield-Mask: 0xfff)          */

/* --------------------------  LED3_INST_UPDATE_STEPSIZE  ------------------------- */
#define LED3_INST_UPDATE_STEPSIZE_STEP0_Pos   (0UL)                     /*!< LED3_INST UPDATE_STEPSIZE: STEP0 (Bit 0)                    */
#define LED3_INST_UPDATE_STEPSIZE_STEP0_Msk   (0xfUL)                   /*!< LED3_INST UPDATE_STEPSIZE: STEP0 (Bitfield-Mask: 0x0f)      */
#define LED3_INST_UPDATE_STEPSIZE_STEP1_Pos   (4UL)                     /*!< LED3_INST UPDATE_STEPSIZE: STEP1 (Bit 4)                    */
#define LED3_INST_UPDATE_STEPSIZE_STEP1_Msk   (0xf0UL)                  /*!< LED3_INST UPDATE_STEPSIZE: STEP1 (Bitfield-Mask: 0x0f)      */
#define LED3_INST_UPDATE_STEPSIZE_STEP2_Pos   (8UL)                     /*!< LED3_INST UPDATE_STEPSIZE: STEP2 (Bit 8)                    */
#define LED3_INST_UPDATE_STEPSIZE_STEP2_Msk   (0xf00UL)                 /*!< LED3_INST UPDATE_STEPSIZE: STEP2 (Bitfield-Mask: 0x0f)      */
#define LED3_INST_UPDATE_STEPSIZE_STEP3_Pos   (12UL)                    /*!< LED3_INST UPDATE_STEPSIZE: STEP3 (Bit 12)                   */
#define LED3_INST_UPDATE_STEPSIZE_STEP3_Msk   (0xf000UL)                /*!< LED3_INST UPDATE_STEPSIZE: STEP3 (Bitfield-Mask: 0x0f)      */
#define LED3_INST_UPDATE_STEPSIZE_STEP4_Pos   (16UL)                    /*!< LED3_INST UPDATE_STEPSIZE: STEP4 (Bit 16)                   */
#define LED3_INST_UPDATE_STEPSIZE_STEP4_Msk   (0xf0000UL)               /*!< LED3_INST UPDATE_STEPSIZE: STEP4 (Bitfield-Mask: 0x0f)      */
#define LED3_INST_UPDATE_STEPSIZE_STEP5_Pos   (20UL)                    /*!< LED3_INST UPDATE_STEPSIZE: STEP5 (Bit 20)                   */
#define LED3_INST_UPDATE_STEPSIZE_STEP5_Msk   (0xf00000UL)              /*!< LED3_INST UPDATE_STEPSIZE: STEP5 (Bitfield-Mask: 0x0f)      */
#define LED3_INST_UPDATE_STEPSIZE_STEP6_Pos   (24UL)                    /*!< LED3_INST UPDATE_STEPSIZE: STEP6 (Bit 24)                   */
#define LED3_INST_UPDATE_STEPSIZE_STEP6_Msk   (0xf000000UL)             /*!< LED3_INST UPDATE_STEPSIZE: STEP6 (Bitfield-Mask: 0x0f)      */
#define LED3_INST_UPDATE_STEPSIZE_STEP7_Pos   (28UL)                    /*!< LED3_INST UPDATE_STEPSIZE: STEP7 (Bit 28)                   */
#define LED3_INST_UPDATE_STEPSIZE_STEP7_Msk   (0xf0000000UL)            /*!< LED3_INST UPDATE_STEPSIZE: STEP7 (Bitfield-Mask: 0x0f)      */

/* --------------------------  LED3_INST_UPDATE_INTERVAL  ------------------------- */
#define LED3_INST_UPDATE_INTERVAL_INTERVAL0_Pos (0UL)                   /*!< LED3_INST UPDATE_INTERVAL: INTERVAL0 (Bit 0)                */
#define LED3_INST_UPDATE_INTERVAL_INTERVAL0_Msk (0xfUL)                 /*!< LED3_INST UPDATE_INTERVAL: INTERVAL0 (Bitfield-Mask: 0x0f)  */
#define LED3_INST_UPDATE_INTERVAL_INTERVAL1_Pos (4UL)                   /*!< LED3_INST UPDATE_INTERVAL: INTERVAL1 (Bit 4)                */
#define LED3_INST_UPDATE_INTERVAL_INTERVAL1_Msk (0xf0UL)                /*!< LED3_INST UPDATE_INTERVAL: INTERVAL1 (Bitfield-Mask: 0x0f)  */
#define LED3_INST_UPDATE_INTERVAL_INTERVAL2_Pos (8UL)                   /*!< LED3_INST UPDATE_INTERVAL: INTERVAL2 (Bit 8)                */
#define LED3_INST_UPDATE_INTERVAL_INTERVAL2_Msk (0xf00UL)               /*!< LED3_INST UPDATE_INTERVAL: INTERVAL2 (Bitfield-Mask: 0x0f)  */
#define LED3_INST_UPDATE_INTERVAL_INTERVAL3_Pos (12UL)                  /*!< LED3_INST UPDATE_INTERVAL: INTERVAL3 (Bit 12)               */
#define LED3_INST_UPDATE_INTERVAL_INTERVAL3_Msk (0xf000UL)              /*!< LED3_INST UPDATE_INTERVAL: INTERVAL3 (Bitfield-Mask: 0x0f)  */
#define LED3_INST_UPDATE_INTERVAL_INTERVAL4_Pos (16UL)                  /*!< LED3_INST UPDATE_INTERVAL: INTERVAL4 (Bit 16)               */
#define LED3_INST_UPDATE_INTERVAL_INTERVAL4_Msk (0xf0000UL)             /*!< LED3_INST UPDATE_INTERVAL: INTERVAL4 (Bitfield-Mask: 0x0f)  */
#define LED3_INST_UPDATE_INTERVAL_INTERVAL5_Pos (20UL)                  /*!< LED3_INST UPDATE_INTERVAL: INTERVAL5 (Bit 20)               */
#define LED3_INST_UPDATE_INTERVAL_INTERVAL5_Msk (0xf00000UL)            /*!< LED3_INST UPDATE_INTERVAL: INTERVAL5 (Bitfield-Mask: 0x0f)  */
#define LED3_INST_UPDATE_INTERVAL_INTERVAL6_Pos (24UL)                  /*!< LED3_INST UPDATE_INTERVAL: INTERVAL6 (Bit 24)               */
#define LED3_INST_UPDATE_INTERVAL_INTERVAL6_Msk (0xf000000UL)           /*!< LED3_INST UPDATE_INTERVAL: INTERVAL6 (Bitfield-Mask: 0x0f)  */
#define LED3_INST_UPDATE_INTERVAL_INTERVAL7_Pos (28UL)                  /*!< LED3_INST UPDATE_INTERVAL: INTERVAL7 (Bit 28)               */
#define LED3_INST_UPDATE_INTERVAL_INTERVAL7_Msk (0xf0000000UL)          /*!< LED3_INST UPDATE_INTERVAL: INTERVAL7 (Bitfield-Mask: 0x0f)  */

/* -------------------------  LED3_INST_LED_OUTPUT_DELAY  ------------------------- */
#define LED3_INST_LED_OUTPUT_DELAY_OUTPUT_DELAY_Pos (0UL)               /*!< LED3_INST LED_OUTPUT_DELAY: OUTPUT_DELAY (Bit 0)            */
#define LED3_INST_LED_OUTPUT_DELAY_OUTPUT_DELAY_Msk (0xffUL)            /*!< LED3_INST LED_OUTPUT_DELAY: OUTPUT_DELAY (Bitfield-Mask: 0xff) */


/* ================================================================================ */
/* ================      struct 'RC_ID0_INST' Position & Mask      ================ */
/* ================================================================================ */


/* --------------------------  RC_ID0_INST_RC_ID_CONTROL  ------------------------- */
#define RC_ID0_INST_RC_ID_CONTROL_DONE_Pos    (0UL)                     /*!< RC_ID0_INST RC_ID_CONTROL: DONE (Bit 0)                     */
#define RC_ID0_INST_RC_ID_CONTROL_DONE_Msk    (0x1UL)                   /*!< RC_ID0_INST RC_ID_CONTROL: DONE (Bitfield-Mask: 0x01)       */
#define RC_ID0_INST_RC_ID_CONTROL_TC_Pos      (1UL)                     /*!< RC_ID0_INST RC_ID_CONTROL: TC (Bit 1)                       */
#define RC_ID0_INST_RC_ID_CONTROL_TC_Msk      (0x2UL)                   /*!< RC_ID0_INST RC_ID_CONTROL: TC (Bitfield-Mask: 0x01)         */
#define RC_ID0_INST_RC_ID_CONTROL_CY_ER_Pos   (2UL)                     /*!< RC_ID0_INST RC_ID_CONTROL: CY_ER (Bit 2)                    */
#define RC_ID0_INST_RC_ID_CONTROL_CY_ER_Msk   (0x4UL)                   /*!< RC_ID0_INST RC_ID_CONTROL: CY_ER (Bitfield-Mask: 0x01)      */
#define RC_ID0_INST_RC_ID_CONTROL_START_Pos   (6UL)                     /*!< RC_ID0_INST RC_ID_CONTROL: START (Bit 6)                    */
#define RC_ID0_INST_RC_ID_CONTROL_START_Msk   (0x40UL)                  /*!< RC_ID0_INST RC_ID_CONTROL: START (Bitfield-Mask: 0x01)      */
#define RC_ID0_INST_RC_ID_CONTROL_ENABLE_Pos  (7UL)                     /*!< RC_ID0_INST RC_ID_CONTROL: ENABLE (Bit 7)                   */
#define RC_ID0_INST_RC_ID_CONTROL_ENABLE_Msk  (0x80UL)                  /*!< RC_ID0_INST RC_ID_CONTROL: ENABLE (Bitfield-Mask: 0x01)     */
#define RC_ID0_INST_RC_ID_CONTROL_CLOCK_SET_Pos (8UL)                   /*!< RC_ID0_INST RC_ID_CONTROL: CLOCK_SET (Bit 8)                */
#define RC_ID0_INST_RC_ID_CONTROL_CLOCK_SET_Msk (0x300UL)               /*!< RC_ID0_INST RC_ID_CONTROL: CLOCK_SET (Bitfield-Mask: 0x03)  */

/* ---------------------------  RC_ID0_INST_RC_ID_DATA  --------------------------- */
#define RC_ID0_INST_RC_ID_DATA_RCID_DATA_Pos  (0UL)                     /*!< RC_ID0_INST RC_ID_DATA: RCID_DATA (Bit 0)                   */
#define RC_ID0_INST_RC_ID_DATA_RCID_DATA_Msk  (0xffffUL)                /*!< RC_ID0_INST RC_ID_DATA: RCID_DATA (Bitfield-Mask: 0xffff)   */


/* ================================================================================ */
/* ================      struct 'RC_ID1_INST' Position & Mask      ================ */
/* ================================================================================ */


/* --------------------------  RC_ID1_INST_RC_ID_CONTROL  ------------------------- */
#define RC_ID1_INST_RC_ID_CONTROL_DONE_Pos    (0UL)                     /*!< RC_ID1_INST RC_ID_CONTROL: DONE (Bit 0)                     */
#define RC_ID1_INST_RC_ID_CONTROL_DONE_Msk    (0x1UL)                   /*!< RC_ID1_INST RC_ID_CONTROL: DONE (Bitfield-Mask: 0x01)       */
#define RC_ID1_INST_RC_ID_CONTROL_TC_Pos      (1UL)                     /*!< RC_ID1_INST RC_ID_CONTROL: TC (Bit 1)                       */
#define RC_ID1_INST_RC_ID_CONTROL_TC_Msk      (0x2UL)                   /*!< RC_ID1_INST RC_ID_CONTROL: TC (Bitfield-Mask: 0x01)         */
#define RC_ID1_INST_RC_ID_CONTROL_CY_ER_Pos   (2UL)                     /*!< RC_ID1_INST RC_ID_CONTROL: CY_ER (Bit 2)                    */
#define RC_ID1_INST_RC_ID_CONTROL_CY_ER_Msk   (0x4UL)                   /*!< RC_ID1_INST RC_ID_CONTROL: CY_ER (Bitfield-Mask: 0x01)      */
#define RC_ID1_INST_RC_ID_CONTROL_START_Pos   (6UL)                     /*!< RC_ID1_INST RC_ID_CONTROL: START (Bit 6)                    */
#define RC_ID1_INST_RC_ID_CONTROL_START_Msk   (0x40UL)                  /*!< RC_ID1_INST RC_ID_CONTROL: START (Bitfield-Mask: 0x01)      */
#define RC_ID1_INST_RC_ID_CONTROL_ENABLE_Pos  (7UL)                     /*!< RC_ID1_INST RC_ID_CONTROL: ENABLE (Bit 7)                   */
#define RC_ID1_INST_RC_ID_CONTROL_ENABLE_Msk  (0x80UL)                  /*!< RC_ID1_INST RC_ID_CONTROL: ENABLE (Bitfield-Mask: 0x01)     */
#define RC_ID1_INST_RC_ID_CONTROL_CLOCK_SET_Pos (8UL)                   /*!< RC_ID1_INST RC_ID_CONTROL: CLOCK_SET (Bit 8)                */
#define RC_ID1_INST_RC_ID_CONTROL_CLOCK_SET_Msk (0x300UL)               /*!< RC_ID1_INST RC_ID_CONTROL: CLOCK_SET (Bitfield-Mask: 0x03)  */

/* ---------------------------  RC_ID1_INST_RC_ID_DATA  --------------------------- */
#define RC_ID1_INST_RC_ID_DATA_RCID_DATA_Pos  (0UL)                     /*!< RC_ID1_INST RC_ID_DATA: RCID_DATA (Bit 0)                   */
#define RC_ID1_INST_RC_ID_DATA_RCID_DATA_Msk  (0xffffUL)                /*!< RC_ID1_INST RC_ID_DATA: RCID_DATA (Bitfield-Mask: 0xffff)   */


/* ================================================================================ */
/* ================      struct 'RC_ID2_INST' Position & Mask      ================ */
/* ================================================================================ */


/* --------------------------  RC_ID2_INST_RC_ID_CONTROL  ------------------------- */
#define RC_ID2_INST_RC_ID_CONTROL_DONE_Pos    (0UL)                     /*!< RC_ID2_INST RC_ID_CONTROL: DONE (Bit 0)                     */
#define RC_ID2_INST_RC_ID_CONTROL_DONE_Msk    (0x1UL)                   /*!< RC_ID2_INST RC_ID_CONTROL: DONE (Bitfield-Mask: 0x01)       */
#define RC_ID2_INST_RC_ID_CONTROL_TC_Pos      (1UL)                     /*!< RC_ID2_INST RC_ID_CONTROL: TC (Bit 1)                       */
#define RC_ID2_INST_RC_ID_CONTROL_TC_Msk      (0x2UL)                   /*!< RC_ID2_INST RC_ID_CONTROL: TC (Bitfield-Mask: 0x01)         */
#define RC_ID2_INST_RC_ID_CONTROL_CY_ER_Pos   (2UL)                     /*!< RC_ID2_INST RC_ID_CONTROL: CY_ER (Bit 2)                    */
#define RC_ID2_INST_RC_ID_CONTROL_CY_ER_Msk   (0x4UL)                   /*!< RC_ID2_INST RC_ID_CONTROL: CY_ER (Bitfield-Mask: 0x01)      */
#define RC_ID2_INST_RC_ID_CONTROL_START_Pos   (6UL)                     /*!< RC_ID2_INST RC_ID_CONTROL: START (Bit 6)                    */
#define RC_ID2_INST_RC_ID_CONTROL_START_Msk   (0x40UL)                  /*!< RC_ID2_INST RC_ID_CONTROL: START (Bitfield-Mask: 0x01)      */
#define RC_ID2_INST_RC_ID_CONTROL_ENABLE_Pos  (7UL)                     /*!< RC_ID2_INST RC_ID_CONTROL: ENABLE (Bit 7)                   */
#define RC_ID2_INST_RC_ID_CONTROL_ENABLE_Msk  (0x80UL)                  /*!< RC_ID2_INST RC_ID_CONTROL: ENABLE (Bitfield-Mask: 0x01)     */
#define RC_ID2_INST_RC_ID_CONTROL_CLOCK_SET_Pos (8UL)                   /*!< RC_ID2_INST RC_ID_CONTROL: CLOCK_SET (Bit 8)                */
#define RC_ID2_INST_RC_ID_CONTROL_CLOCK_SET_Msk (0x300UL)               /*!< RC_ID2_INST RC_ID_CONTROL: CLOCK_SET (Bitfield-Mask: 0x03)  */

/* ---------------------------  RC_ID2_INST_RC_ID_DATA  --------------------------- */
#define RC_ID2_INST_RC_ID_DATA_RCID_DATA_Pos  (0UL)                     /*!< RC_ID2_INST RC_ID_DATA: RCID_DATA (Bit 0)                   */
#define RC_ID2_INST_RC_ID_DATA_RCID_DATA_Msk  (0xffffUL)                /*!< RC_ID2_INST RC_ID_DATA: RCID_DATA (Bitfield-Mask: 0xffff)   */


/* ================================================================================ */
/* ================        struct 'KMS_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ----------------------------  KMS_INST_KSO_CONTROL  ---------------------------- */
#define KMS_INST_KSO_CONTROL_SELECT_Pos       (0UL)                     /*!< KMS_INST KSO_CONTROL: SELECT (Bit 0)                        */
#define KMS_INST_KSO_CONTROL_SELECT_Msk       (0x1fUL)                  /*!< KMS_INST KSO_CONTROL: SELECT (Bitfield-Mask: 0x1f)          */
#define KMS_INST_KSO_CONTROL_ALL_Pos          (5UL)                     /*!< KMS_INST KSO_CONTROL: ALL (Bit 5)                           */
#define KMS_INST_KSO_CONTROL_ALL_Msk          (0x20UL)                  /*!< KMS_INST KSO_CONTROL: ALL (Bitfield-Mask: 0x01)             */
#define KMS_INST_KSO_CONTROL_KSEN_Pos         (6UL)                     /*!< KMS_INST KSO_CONTROL: KSEN (Bit 6)                          */
#define KMS_INST_KSO_CONTROL_KSEN_Msk         (0x40UL)                  /*!< KMS_INST KSO_CONTROL: KSEN (Bitfield-Mask: 0x01)            */
#define KMS_INST_KSO_CONTROL_INVERT_Pos       (7UL)                     /*!< KMS_INST KSO_CONTROL: INVERT (Bit 7)                        */
#define KMS_INST_KSO_CONTROL_INVERT_Msk       (0x80UL)                  /*!< KMS_INST KSO_CONTROL: INVERT (Bitfield-Mask: 0x01)          */


/* ================================================================================ */
/* ================       struct 'SMB0_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ------------------------------  SMB0_INST_CONTROL  ----------------------------- */
#define SMB0_INST_CONTROL_ACK_Pos             (0UL)                     /*!< SMB0_INST CONTROL: ACK (Bit 0)                              */
#define SMB0_INST_CONTROL_ACK_Msk             (0x1UL)                   /*!< SMB0_INST CONTROL: ACK (Bitfield-Mask: 0x01)                */
#define SMB0_INST_CONTROL_STO_Pos             (1UL)                     /*!< SMB0_INST CONTROL: STO (Bit 1)                              */
#define SMB0_INST_CONTROL_STO_Msk             (0x2UL)                   /*!< SMB0_INST CONTROL: STO (Bitfield-Mask: 0x01)                */
#define SMB0_INST_CONTROL_STA_Pos             (2UL)                     /*!< SMB0_INST CONTROL: STA (Bit 2)                              */
#define SMB0_INST_CONTROL_STA_Msk             (0x4UL)                   /*!< SMB0_INST CONTROL: STA (Bitfield-Mask: 0x01)                */
#define SMB0_INST_CONTROL_ENI_Pos             (3UL)                     /*!< SMB0_INST CONTROL: ENI (Bit 3)                              */
#define SMB0_INST_CONTROL_ENI_Msk             (0x8UL)                   /*!< SMB0_INST CONTROL: ENI (Bitfield-Mask: 0x01)                */
#define SMB0_INST_CONTROL_ESO_Pos             (6UL)                     /*!< SMB0_INST CONTROL: ESO (Bit 6)                              */
#define SMB0_INST_CONTROL_ESO_Msk             (0x40UL)                  /*!< SMB0_INST CONTROL: ESO (Bitfield-Mask: 0x01)                */
#define SMB0_INST_CONTROL_PIN_Pos             (7UL)                     /*!< SMB0_INST CONTROL: PIN (Bit 7)                              */
#define SMB0_INST_CONTROL_PIN_Msk             (0x80UL)                  /*!< SMB0_INST CONTROL: PIN (Bitfield-Mask: 0x01)                */

/* ------------------------------  SMB0_INST_STATUS  ------------------------------ */
#define SMB0_INST_STATUS_NBB_Pos              (0UL)                     /*!< SMB0_INST STATUS: NBB (Bit 0)                               */
#define SMB0_INST_STATUS_NBB_Msk              (0x1UL)                   /*!< SMB0_INST STATUS: NBB (Bitfield-Mask: 0x01)                 */
#define SMB0_INST_STATUS_LAB_Pos              (1UL)                     /*!< SMB0_INST STATUS: LAB (Bit 1)                               */
#define SMB0_INST_STATUS_LAB_Msk              (0x2UL)                   /*!< SMB0_INST STATUS: LAB (Bitfield-Mask: 0x01)                 */
#define SMB0_INST_STATUS_AAS_Pos              (2UL)                     /*!< SMB0_INST STATUS: AAS (Bit 2)                               */
#define SMB0_INST_STATUS_AAS_Msk              (0x4UL)                   /*!< SMB0_INST STATUS: AAS (Bitfield-Mask: 0x01)                 */
#define SMB0_INST_STATUS_LRB_AD0_Pos          (3UL)                     /*!< SMB0_INST STATUS: LRB_AD0 (Bit 3)                           */
#define SMB0_INST_STATUS_LRB_AD0_Msk          (0x8UL)                   /*!< SMB0_INST STATUS: LRB_AD0 (Bitfield-Mask: 0x01)             */
#define SMB0_INST_STATUS_BER_Pos              (4UL)                     /*!< SMB0_INST STATUS: BER (Bit 4)                               */
#define SMB0_INST_STATUS_BER_Msk              (0x10UL)                  /*!< SMB0_INST STATUS: BER (Bitfield-Mask: 0x01)                 */
#define SMB0_INST_STATUS_STS_Pos              (5UL)                     /*!< SMB0_INST STATUS: STS (Bit 5)                               */
#define SMB0_INST_STATUS_STS_Msk              (0x20UL)                  /*!< SMB0_INST STATUS: STS (Bitfield-Mask: 0x01)                 */
#define SMB0_INST_STATUS_SAD_Pos              (6UL)                     /*!< SMB0_INST STATUS: SAD (Bit 6)                               */
#define SMB0_INST_STATUS_SAD_Msk              (0x40UL)                  /*!< SMB0_INST STATUS: SAD (Bitfield-Mask: 0x01)                 */
#define SMB0_INST_STATUS_PIN_Pos              (7UL)                     /*!< SMB0_INST STATUS: PIN (Bit 7)                               */
#define SMB0_INST_STATUS_PIN_Msk              (0x80UL)                  /*!< SMB0_INST STATUS: PIN (Bitfield-Mask: 0x01)                 */

/* --------------------------------  SMB0_INST_OWN  ------------------------------- */
#define SMB0_INST_OWN_OWN_ADDRESS_1_Pos       (0UL)                     /*!< SMB0_INST OWN: OWN_ADDRESS_1 (Bit 0)                        */
#define SMB0_INST_OWN_OWN_ADDRESS_1_Msk       (0x7fUL)                  /*!< SMB0_INST OWN: OWN_ADDRESS_1 (Bitfield-Mask: 0x7f)          */
#define SMB0_INST_OWN_OWN_ADDRESS_2_Pos       (8UL)                     /*!< SMB0_INST OWN: OWN_ADDRESS_2 (Bit 8)                        */
#define SMB0_INST_OWN_OWN_ADDRESS_2_Msk       (0x7f00UL)                /*!< SMB0_INST OWN: OWN_ADDRESS_2 (Bitfield-Mask: 0x7f)          */

/* --------------------------  SMB0_INST_MASTER_COMMAND  -------------------------- */
#define SMB0_INST_MASTER_COMMAND_MRUN_Pos     (0UL)                     /*!< SMB0_INST MASTER_COMMAND: MRUN (Bit 0)                      */
#define SMB0_INST_MASTER_COMMAND_MRUN_Msk     (0x1UL)                   /*!< SMB0_INST MASTER_COMMAND: MRUN (Bitfield-Mask: 0x01)        */
#define SMB0_INST_MASTER_COMMAND_MPROCEED_Pos (1UL)                     /*!< SMB0_INST MASTER_COMMAND: MPROCEED (Bit 1)                  */
#define SMB0_INST_MASTER_COMMAND_MPROCEED_Msk (0x2UL)                   /*!< SMB0_INST MASTER_COMMAND: MPROCEED (Bitfield-Mask: 0x01)    */
#define SMB0_INST_MASTER_COMMAND_START0_Pos   (8UL)                     /*!< SMB0_INST MASTER_COMMAND: START0 (Bit 8)                    */
#define SMB0_INST_MASTER_COMMAND_START0_Msk   (0x100UL)                 /*!< SMB0_INST MASTER_COMMAND: START0 (Bitfield-Mask: 0x01)      */
#define SMB0_INST_MASTER_COMMAND_STARTN_Pos   (9UL)                     /*!< SMB0_INST MASTER_COMMAND: STARTN (Bit 9)                    */
#define SMB0_INST_MASTER_COMMAND_STARTN_Msk   (0x200UL)                 /*!< SMB0_INST MASTER_COMMAND: STARTN (Bitfield-Mask: 0x01)      */
#define SMB0_INST_MASTER_COMMAND_STOP_Pos     (10UL)                    /*!< SMB0_INST MASTER_COMMAND: STOP (Bit 10)                     */
#define SMB0_INST_MASTER_COMMAND_STOP_Msk     (0x400UL)                 /*!< SMB0_INST MASTER_COMMAND: STOP (Bitfield-Mask: 0x01)        */
#define SMB0_INST_MASTER_COMMAND_PEC_TERM_Pos (11UL)                    /*!< SMB0_INST MASTER_COMMAND: PEC_TERM (Bit 11)                 */
#define SMB0_INST_MASTER_COMMAND_PEC_TERM_Msk (0x800UL)                 /*!< SMB0_INST MASTER_COMMAND: PEC_TERM (Bitfield-Mask: 0x01)    */
#define SMB0_INST_MASTER_COMMAND_READM_Pos    (12UL)                    /*!< SMB0_INST MASTER_COMMAND: READM (Bit 12)                    */
#define SMB0_INST_MASTER_COMMAND_READM_Msk    (0x1000UL)                /*!< SMB0_INST MASTER_COMMAND: READM (Bitfield-Mask: 0x01)       */
#define SMB0_INST_MASTER_COMMAND_READ_PEC_Pos (13UL)                    /*!< SMB0_INST MASTER_COMMAND: READ_PEC (Bit 13)                 */
#define SMB0_INST_MASTER_COMMAND_READ_PEC_Msk (0x2000UL)                /*!< SMB0_INST MASTER_COMMAND: READ_PEC (Bitfield-Mask: 0x01)    */
#define SMB0_INST_MASTER_COMMAND_WRITE_COUNT_Pos (16UL)                 /*!< SMB0_INST MASTER_COMMAND: WRITE_COUNT (Bit 16)              */
#define SMB0_INST_MASTER_COMMAND_WRITE_COUNT_Msk (0xff0000UL)           /*!< SMB0_INST MASTER_COMMAND: WRITE_COUNT (Bitfield-Mask: 0xff) */
#define SMB0_INST_MASTER_COMMAND_READ_COUNT_Pos (24UL)                  /*!< SMB0_INST MASTER_COMMAND: READ_COUNT (Bit 24)               */
#define SMB0_INST_MASTER_COMMAND_READ_COUNT_Msk (0xff000000UL)          /*!< SMB0_INST MASTER_COMMAND: READ_COUNT (Bitfield-Mask: 0xff)  */

/* ---------------------------  SMB0_INST_SLAVE_COMMAND  -------------------------- */
#define SMB0_INST_SLAVE_COMMAND_SRUN_Pos      (0UL)                     /*!< SMB0_INST SLAVE_COMMAND: SRUN (Bit 0)                       */
#define SMB0_INST_SLAVE_COMMAND_SRUN_Msk      (0x1UL)                   /*!< SMB0_INST SLAVE_COMMAND: SRUN (Bitfield-Mask: 0x01)         */
#define SMB0_INST_SLAVE_COMMAND_SPROCEED_Pos  (1UL)                     /*!< SMB0_INST SLAVE_COMMAND: SPROCEED (Bit 1)                   */
#define SMB0_INST_SLAVE_COMMAND_SPROCEED_Msk  (0x2UL)                   /*!< SMB0_INST SLAVE_COMMAND: SPROCEED (Bitfield-Mask: 0x01)     */
#define SMB0_INST_SLAVE_COMMAND_SLAVE_PEC_Pos (2UL)                     /*!< SMB0_INST SLAVE_COMMAND: SLAVE_PEC (Bit 2)                  */
#define SMB0_INST_SLAVE_COMMAND_SLAVE_PEC_Msk (0x4UL)                   /*!< SMB0_INST SLAVE_COMMAND: SLAVE_PEC (Bitfield-Mask: 0x01)    */
#define SMB0_INST_SLAVE_COMMAND_SLAVE_WRITECOUNT_Pos (8UL)              /*!< SMB0_INST SLAVE_COMMAND: SLAVE_WRITECOUNT (Bit 8)           */
#define SMB0_INST_SLAVE_COMMAND_SLAVE_WRITECOUNT_Msk (0xff00UL)         /*!< SMB0_INST SLAVE_COMMAND: SLAVE_WRITECOUNT (Bitfield-Mask: 0xff) */
#define SMB0_INST_SLAVE_COMMAND_SLAVE_READCOUNT_Pos (16UL)              /*!< SMB0_INST SLAVE_COMMAND: SLAVE_READCOUNT (Bit 16)           */
#define SMB0_INST_SLAVE_COMMAND_SLAVE_READCOUNT_Msk (0xff0000UL)        /*!< SMB0_INST SLAVE_COMMAND: SLAVE_READCOUNT (Bitfield-Mask: 0xff) */

/* --------------------------------  SMB0_INST_PEC  ------------------------------- */
#define SMB0_INST_PEC_PEC_Pos                 (0UL)                     /*!< SMB0_INST PEC: PEC (Bit 0)                                  */
#define SMB0_INST_PEC_PEC_Msk                 (0xffUL)                  /*!< SMB0_INST PEC: PEC (Bitfield-Mask: 0xff)                    */

/* ---------------------  SMB0_INST_REPEATED_START_HOLD_TIME  --------------------- */
#define SMB0_INST_REPEATED_START_HOLD_TIME_RPT_START_HOLD_TIME_Pos (0UL) /*!< SMB0_INST REPEATED_START_HOLD_TIME: RPT_START_HOLD_TIME (Bit 0) */
#define SMB0_INST_REPEATED_START_HOLD_TIME_RPT_START_HOLD_TIME_Msk (0xffUL) /*!< SMB0_INST REPEATED_START_HOLD_TIME: RPT_START_HOLD_TIME (Bitfield-Mask: 0xff) */

/* ----------------------------  SMB0_INST_COMPLETION  ---------------------------- */
#define SMB0_INST_COMPLETION_DTEN_Pos         (2UL)                     /*!< SMB0_INST COMPLETION: DTEN (Bit 2)                          */
#define SMB0_INST_COMPLETION_DTEN_Msk         (0x4UL)                   /*!< SMB0_INST COMPLETION: DTEN (Bitfield-Mask: 0x01)            */
#define SMB0_INST_COMPLETION_MCEN_Pos         (3UL)                     /*!< SMB0_INST COMPLETION: MCEN (Bit 3)                          */
#define SMB0_INST_COMPLETION_MCEN_Msk         (0x8UL)                   /*!< SMB0_INST COMPLETION: MCEN (Bitfield-Mask: 0x01)            */
#define SMB0_INST_COMPLETION_SCEN_Pos         (4UL)                     /*!< SMB0_INST COMPLETION: SCEN (Bit 4)                          */
#define SMB0_INST_COMPLETION_SCEN_Msk         (0x10UL)                  /*!< SMB0_INST COMPLETION: SCEN (Bitfield-Mask: 0x01)            */
#define SMB0_INST_COMPLETION_BIDEN_Pos        (5UL)                     /*!< SMB0_INST COMPLETION: BIDEN (Bit 5)                         */
#define SMB0_INST_COMPLETION_BIDEN_Msk        (0x20UL)                  /*!< SMB0_INST COMPLETION: BIDEN (Bitfield-Mask: 0x01)           */
#define SMB0_INST_COMPLETION_TIMERR_Pos       (6UL)                     /*!< SMB0_INST COMPLETION: TIMERR (Bit 6)                        */
#define SMB0_INST_COMPLETION_TIMERR_Msk       (0x40UL)                  /*!< SMB0_INST COMPLETION: TIMERR (Bitfield-Mask: 0x01)          */
#define SMB0_INST_COMPLETION_DTO_Pos          (8UL)                     /*!< SMB0_INST COMPLETION: DTO (Bit 8)                           */
#define SMB0_INST_COMPLETION_DTO_Msk          (0x100UL)                 /*!< SMB0_INST COMPLETION: DTO (Bitfield-Mask: 0x01)             */
#define SMB0_INST_COMPLETION_MCTO_Pos         (9UL)                     /*!< SMB0_INST COMPLETION: MCTO (Bit 9)                          */
#define SMB0_INST_COMPLETION_MCTO_Msk         (0x200UL)                 /*!< SMB0_INST COMPLETION: MCTO (Bitfield-Mask: 0x01)            */
#define SMB0_INST_COMPLETION_SCTO_Pos         (10UL)                    /*!< SMB0_INST COMPLETION: SCTO (Bit 10)                         */
#define SMB0_INST_COMPLETION_SCTO_Msk         (0x400UL)                 /*!< SMB0_INST COMPLETION: SCTO (Bitfield-Mask: 0x01)            */
#define SMB0_INST_COMPLETION_CHDL_Pos         (11UL)                    /*!< SMB0_INST COMPLETION: CHDL (Bit 11)                         */
#define SMB0_INST_COMPLETION_CHDL_Msk         (0x800UL)                 /*!< SMB0_INST COMPLETION: CHDL (Bitfield-Mask: 0x01)            */
#define SMB0_INST_COMPLETION_CHDH_Pos         (12UL)                    /*!< SMB0_INST COMPLETION: CHDH (Bit 12)                         */
#define SMB0_INST_COMPLETION_CHDH_Msk         (0x1000UL)                /*!< SMB0_INST COMPLETION: CHDH (Bitfield-Mask: 0x01)            */
#define SMB0_INST_COMPLETION_BER_Pos          (13UL)                    /*!< SMB0_INST COMPLETION: BER (Bit 13)                          */
#define SMB0_INST_COMPLETION_BER_Msk          (0x2000UL)                /*!< SMB0_INST COMPLETION: BER (Bitfield-Mask: 0x01)             */
#define SMB0_INST_COMPLETION_LAB_Pos          (14UL)                    /*!< SMB0_INST COMPLETION: LAB (Bit 14)                          */
#define SMB0_INST_COMPLETION_LAB_Msk          (0x4000UL)                /*!< SMB0_INST COMPLETION: LAB (Bitfield-Mask: 0x01)             */
#define SMB0_INST_COMPLETION_SNAKR_Pos        (16UL)                    /*!< SMB0_INST COMPLETION: SNAKR (Bit 16)                        */
#define SMB0_INST_COMPLETION_SNAKR_Msk        (0x10000UL)               /*!< SMB0_INST COMPLETION: SNAKR (Bitfield-Mask: 0x01)           */
#define SMB0_INST_COMPLETION_STR_Pos          (17UL)                    /*!< SMB0_INST COMPLETION: STR (Bit 17)                          */
#define SMB0_INST_COMPLETION_STR_Msk          (0x20000UL)               /*!< SMB0_INST COMPLETION: STR (Bitfield-Mask: 0x01)             */
#define SMB0_INST_COMPLETION_SPROT_Pos        (19UL)                    /*!< SMB0_INST COMPLETION: SPROT (Bit 19)                        */
#define SMB0_INST_COMPLETION_SPROT_Msk        (0x80000UL)               /*!< SMB0_INST COMPLETION: SPROT (Bitfield-Mask: 0x01)           */
#define SMB0_INST_COMPLETION_REPEAT_READ_Pos  (20UL)                    /*!< SMB0_INST COMPLETION: REPEAT_READ (Bit 20)                  */
#define SMB0_INST_COMPLETION_REPEAT_READ_Msk  (0x100000UL)              /*!< SMB0_INST COMPLETION: REPEAT_READ (Bitfield-Mask: 0x01)     */
#define SMB0_INST_COMPLETION_REPEAT_WRITE_Pos (21UL)                    /*!< SMB0_INST COMPLETION: REPEAT_WRITE (Bit 21)                 */
#define SMB0_INST_COMPLETION_REPEAT_WRITE_Msk (0x200000UL)              /*!< SMB0_INST COMPLETION: REPEAT_WRITE (Bitfield-Mask: 0x01)    */
#define SMB0_INST_COMPLETION_MNAKX_Pos        (24UL)                    /*!< SMB0_INST COMPLETION: MNAKX (Bit 24)                        */
#define SMB0_INST_COMPLETION_MNAKX_Msk        (0x1000000UL)             /*!< SMB0_INST COMPLETION: MNAKX (Bitfield-Mask: 0x01)           */
#define SMB0_INST_COMPLETION_MTR_Pos          (25UL)                    /*!< SMB0_INST COMPLETION: MTR (Bit 25)                          */
#define SMB0_INST_COMPLETION_MTR_Msk          (0x2000000UL)             /*!< SMB0_INST COMPLETION: MTR (Bitfield-Mask: 0x01)             */
#define SMB0_INST_COMPLETION_IDLE_Pos         (29UL)                    /*!< SMB0_INST COMPLETION: IDLE (Bit 29)                         */
#define SMB0_INST_COMPLETION_IDLE_Msk         (0x20000000UL)            /*!< SMB0_INST COMPLETION: IDLE (Bitfield-Mask: 0x01)            */
#define SMB0_INST_COMPLETION_MDONE_Pos        (30UL)                    /*!< SMB0_INST COMPLETION: MDONE (Bit 30)                        */
#define SMB0_INST_COMPLETION_MDONE_Msk        (0x40000000UL)            /*!< SMB0_INST COMPLETION: MDONE (Bitfield-Mask: 0x01)           */
#define SMB0_INST_COMPLETION_SDONE_Pos        (31UL)                    /*!< SMB0_INST COMPLETION: SDONE (Bit 31)                        */
#define SMB0_INST_COMPLETION_SDONE_Msk        (0x80000000UL)            /*!< SMB0_INST COMPLETION: SDONE (Bitfield-Mask: 0x01)           */

/* ---------------------------  SMB0_INST_IDLE_SCALING  --------------------------- */
#define SMB0_INST_IDLE_SCALING_FAIR_BUS_IDLE_MIN_Pos (0UL)              /*!< SMB0_INST IDLE_SCALING: FAIR_BUS_IDLE_MIN (Bit 0)           */
#define SMB0_INST_IDLE_SCALING_FAIR_BUS_IDLE_MIN_Msk (0xfffUL)          /*!< SMB0_INST IDLE_SCALING: FAIR_BUS_IDLE_MIN (Bitfield-Mask: 0xfff) */
#define SMB0_INST_IDLE_SCALING_FAIR_IDLE_DELAY_Pos (16UL)               /*!< SMB0_INST IDLE_SCALING: FAIR_IDLE_DELAY (Bit 16)            */
#define SMB0_INST_IDLE_SCALING_FAIR_IDLE_DELAY_Msk (0xfff0000UL)        /*!< SMB0_INST IDLE_SCALING: FAIR_IDLE_DELAY (Bitfield-Mask: 0xfff) */

/* ---------------------------  SMB0_INST_CONFIGURATION  -------------------------- */
#define SMB0_INST_CONFIGURATION_PORT_SEL_Pos  (0UL)                     /*!< SMB0_INST CONFIGURATION: PORT_SEL (Bit 0)                   */
#define SMB0_INST_CONFIGURATION_PORT_SEL_Msk  (0xfUL)                   /*!< SMB0_INST CONFIGURATION: PORT_SEL (Bitfield-Mask: 0x0f)     */
#define SMB0_INST_CONFIGURATION_TCEN_Pos      (4UL)                     /*!< SMB0_INST CONFIGURATION: TCEN (Bit 4)                       */
#define SMB0_INST_CONFIGURATION_TCEN_Msk      (0x10UL)                  /*!< SMB0_INST CONFIGURATION: TCEN (Bitfield-Mask: 0x01)         */
#define SMB0_INST_CONFIGURATION_SLOW_CLOCK_Pos (5UL)                    /*!< SMB0_INST CONFIGURATION: SLOW_CLOCK (Bit 5)                 */
#define SMB0_INST_CONFIGURATION_SLOW_CLOCK_Msk (0x20UL)                 /*!< SMB0_INST CONFIGURATION: SLOW_CLOCK (Bitfield-Mask: 0x01)   */
#define SMB0_INST_CONFIGURATION_TEST_Pos      (6UL)                     /*!< SMB0_INST CONFIGURATION: TEST (Bit 6)                       */
#define SMB0_INST_CONFIGURATION_TEST_Msk      (0x40UL)                  /*!< SMB0_INST CONFIGURATION: TEST (Bitfield-Mask: 0x01)         */
#define SMB0_INST_CONFIGURATION_PECEN_Pos     (7UL)                     /*!< SMB0_INST CONFIGURATION: PECEN (Bit 7)                      */
#define SMB0_INST_CONFIGURATION_PECEN_Msk     (0x80UL)                  /*!< SMB0_INST CONFIGURATION: PECEN (Bitfield-Mask: 0x01)        */
#define SMB0_INST_CONFIGURATION_FEN_Pos       (8UL)                     /*!< SMB0_INST CONFIGURATION: FEN (Bit 8)                        */
#define SMB0_INST_CONFIGURATION_FEN_Msk       (0x100UL)                 /*!< SMB0_INST CONFIGURATION: FEN (Bitfield-Mask: 0x01)          */
#define SMB0_INST_CONFIGURATION_RESET_Pos     (9UL)                     /*!< SMB0_INST CONFIGURATION: RESET (Bit 9)                      */
#define SMB0_INST_CONFIGURATION_RESET_Msk     (0x200UL)                 /*!< SMB0_INST CONFIGURATION: RESET (Bitfield-Mask: 0x01)        */
#define SMB0_INST_CONFIGURATION_ENAB_Pos      (10UL)                    /*!< SMB0_INST CONFIGURATION: ENAB (Bit 10)                      */
#define SMB0_INST_CONFIGURATION_ENAB_Msk      (0x400UL)                 /*!< SMB0_INST CONFIGURATION: ENAB (Bitfield-Mask: 0x01)         */
#define SMB0_INST_CONFIGURATION_DSA_Pos       (11UL)                    /*!< SMB0_INST CONFIGURATION: DSA (Bit 11)                       */
#define SMB0_INST_CONFIGURATION_DSA_Msk       (0x800UL)                 /*!< SMB0_INST CONFIGURATION: DSA (Bitfield-Mask: 0x01)          */
#define SMB0_INST_CONFIGURATION_FAIR_Pos      (12UL)                    /*!< SMB0_INST CONFIGURATION: FAIR (Bit 12)                      */
#define SMB0_INST_CONFIGURATION_FAIR_Msk      (0x1000UL)                /*!< SMB0_INST CONFIGURATION: FAIR (Bitfield-Mask: 0x01)         */
#define SMB0_INST_CONFIGURATION_TEST0_Pos     (13UL)                    /*!< SMB0_INST CONFIGURATION: TEST0 (Bit 13)                     */
#define SMB0_INST_CONFIGURATION_TEST0_Msk     (0x2000UL)                /*!< SMB0_INST CONFIGURATION: TEST0 (Bitfield-Mask: 0x01)        */
#define SMB0_INST_CONFIGURATION_GC_DIS_Pos    (14UL)                    /*!< SMB0_INST CONFIGURATION: GC_DIS (Bit 14)                    */
#define SMB0_INST_CONFIGURATION_GC_DIS_Msk    (0x4000UL)                /*!< SMB0_INST CONFIGURATION: GC_DIS (Bitfield-Mask: 0x01)       */
#define SMB0_INST_CONFIGURATION_FLUSH_SXBUF_Pos (16UL)                  /*!< SMB0_INST CONFIGURATION: FLUSH_SXBUF (Bit 16)               */
#define SMB0_INST_CONFIGURATION_FLUSH_SXBUF_Msk (0x10000UL)             /*!< SMB0_INST CONFIGURATION: FLUSH_SXBUF (Bitfield-Mask: 0x01)  */
#define SMB0_INST_CONFIGURATION_FLUSH_SRBUF_Pos (17UL)                  /*!< SMB0_INST CONFIGURATION: FLUSH_SRBUF (Bit 17)               */
#define SMB0_INST_CONFIGURATION_FLUSH_SRBUF_Msk (0x20000UL)             /*!< SMB0_INST CONFIGURATION: FLUSH_SRBUF (Bitfield-Mask: 0x01)  */
#define SMB0_INST_CONFIGURATION_FLUSH_MXBUF_Pos (18UL)                  /*!< SMB0_INST CONFIGURATION: FLUSH_MXBUF (Bit 18)               */
#define SMB0_INST_CONFIGURATION_FLUSH_MXBUF_Msk (0x40000UL)             /*!< SMB0_INST CONFIGURATION: FLUSH_MXBUF (Bitfield-Mask: 0x01)  */
#define SMB0_INST_CONFIGURATION_FLUSH_MRBUF_Pos (19UL)                  /*!< SMB0_INST CONFIGURATION: FLUSH_MRBUF (Bit 19)               */
#define SMB0_INST_CONFIGURATION_FLUSH_MRBUF_Msk (0x80000UL)             /*!< SMB0_INST CONFIGURATION: FLUSH_MRBUF (Bitfield-Mask: 0x01)  */
#define SMB0_INST_CONFIGURATION_EN_AAS_Pos    (28UL)                    /*!< SMB0_INST CONFIGURATION: EN_AAS (Bit 28)                    */
#define SMB0_INST_CONFIGURATION_EN_AAS_Msk    (0x10000000UL)            /*!< SMB0_INST CONFIGURATION: EN_AAS (Bitfield-Mask: 0x01)       */
#define SMB0_INST_CONFIGURATION_ENIDI_Pos     (29UL)                    /*!< SMB0_INST CONFIGURATION: ENIDI (Bit 29)                     */
#define SMB0_INST_CONFIGURATION_ENIDI_Msk     (0x20000000UL)            /*!< SMB0_INST CONFIGURATION: ENIDI (Bitfield-Mask: 0x01)        */
#define SMB0_INST_CONFIGURATION_ENMI_Pos      (30UL)                    /*!< SMB0_INST CONFIGURATION: ENMI (Bit 30)                      */
#define SMB0_INST_CONFIGURATION_ENMI_Msk      (0x40000000UL)            /*!< SMB0_INST CONFIGURATION: ENMI (Bitfield-Mask: 0x01)         */
#define SMB0_INST_CONFIGURATION_ENSI_Pos      (31UL)                    /*!< SMB0_INST CONFIGURATION: ENSI (Bit 31)                      */
#define SMB0_INST_CONFIGURATION_ENSI_Msk      (0x80000000UL)            /*!< SMB0_INST CONFIGURATION: ENSI (Bitfield-Mask: 0x01)         */

/* -----------------------------  SMB0_INST_BUS_CLOCK  ---------------------------- */
#define SMB0_INST_BUS_CLOCK_LOW_PERIOD_Pos    (0UL)                     /*!< SMB0_INST BUS_CLOCK: LOW_PERIOD (Bit 0)                     */
#define SMB0_INST_BUS_CLOCK_LOW_PERIOD_Msk    (0xffUL)                  /*!< SMB0_INST BUS_CLOCK: LOW_PERIOD (Bitfield-Mask: 0xff)       */
#define SMB0_INST_BUS_CLOCK_HIGH_PERIOD_Pos   (8UL)                     /*!< SMB0_INST BUS_CLOCK: HIGH_PERIOD (Bit 8)                    */
#define SMB0_INST_BUS_CLOCK_HIGH_PERIOD_Msk   (0xff00UL)                /*!< SMB0_INST BUS_CLOCK: HIGH_PERIOD (Bitfield-Mask: 0xff)      */

/* -----------------------------  SMB0_INST_BLOCK_ID  ----------------------------- */
#define SMB0_INST_BLOCK_ID_ID_Pos             (0UL)                     /*!< SMB0_INST BLOCK_ID: ID (Bit 0)                              */
#define SMB0_INST_BLOCK_ID_ID_Msk             (0xffUL)                  /*!< SMB0_INST BLOCK_ID: ID (Bitfield-Mask: 0xff)                */

/* -----------------------------  SMB0_INST_REVISION  ----------------------------- */
#define SMB0_INST_REVISION_REVISION_Pos       (0UL)                     /*!< SMB0_INST REVISION: REVISION (Bit 0)                        */
#define SMB0_INST_REVISION_REVISION_Msk       (0xffUL)                  /*!< SMB0_INST REVISION: REVISION (Bitfield-Mask: 0xff)          */

/* -------------------------  SMB0_INST_BIT_BANG_CONTROL  ------------------------- */
#define SMB0_INST_BIT_BANG_CONTROL_BBEN_Pos   (0UL)                     /*!< SMB0_INST BIT_BANG_CONTROL: BBEN (Bit 0)                    */
#define SMB0_INST_BIT_BANG_CONTROL_BBEN_Msk   (0x1UL)                   /*!< SMB0_INST BIT_BANG_CONTROL: BBEN (Bitfield-Mask: 0x01)      */
#define SMB0_INST_BIT_BANG_CONTROL_CLDIR_Pos  (1UL)                     /*!< SMB0_INST BIT_BANG_CONTROL: CLDIR (Bit 1)                   */
#define SMB0_INST_BIT_BANG_CONTROL_CLDIR_Msk  (0x2UL)                   /*!< SMB0_INST BIT_BANG_CONTROL: CLDIR (Bitfield-Mask: 0x01)     */
#define SMB0_INST_BIT_BANG_CONTROL_DADIR_Pos  (2UL)                     /*!< SMB0_INST BIT_BANG_CONTROL: DADIR (Bit 2)                   */
#define SMB0_INST_BIT_BANG_CONTROL_DADIR_Msk  (0x4UL)                   /*!< SMB0_INST BIT_BANG_CONTROL: DADIR (Bitfield-Mask: 0x01)     */
#define SMB0_INST_BIT_BANG_CONTROL_BBCLK_Pos  (3UL)                     /*!< SMB0_INST BIT_BANG_CONTROL: BBCLK (Bit 3)                   */
#define SMB0_INST_BIT_BANG_CONTROL_BBCLK_Msk  (0x8UL)                   /*!< SMB0_INST BIT_BANG_CONTROL: BBCLK (Bitfield-Mask: 0x01)     */
#define SMB0_INST_BIT_BANG_CONTROL_BBDAT_Pos  (4UL)                     /*!< SMB0_INST BIT_BANG_CONTROL: BBDAT (Bit 4)                   */
#define SMB0_INST_BIT_BANG_CONTROL_BBDAT_Msk  (0x10UL)                  /*!< SMB0_INST BIT_BANG_CONTROL: BBDAT (Bitfield-Mask: 0x01)     */
#define SMB0_INST_BIT_BANG_CONTROL_BBCLKI_Pos (5UL)                     /*!< SMB0_INST BIT_BANG_CONTROL: BBCLKI (Bit 5)                  */
#define SMB0_INST_BIT_BANG_CONTROL_BBCLKI_Msk (0x20UL)                  /*!< SMB0_INST BIT_BANG_CONTROL: BBCLKI (Bitfield-Mask: 0x01)    */
#define SMB0_INST_BIT_BANG_CONTROL_BBDATI_Pos (6UL)                     /*!< SMB0_INST BIT_BANG_CONTROL: BBDATI (Bit 6)                  */
#define SMB0_INST_BIT_BANG_CONTROL_BBDATI_Msk (0x40UL)                  /*!< SMB0_INST BIT_BANG_CONTROL: BBDATI (Bitfield-Mask: 0x01)    */

/* -------------------------------  SMB0_INST_TEST  ------------------------------- */
#define SMB0_INST_TEST_TEST_Pos               (0UL)                     /*!< SMB0_INST TEST: TEST (Bit 0)                                */
#define SMB0_INST_TEST_TEST_Msk               (0xffUL)                  /*!< SMB0_INST TEST: TEST (Bitfield-Mask: 0xff)                  */

/* ----------------------------  SMB0_INST_DATA_TIMING  --------------------------- */
#define SMB0_INST_DATA_TIMING_DATA_HOLD_Pos   (0UL)                     /*!< SMB0_INST DATA_TIMING: DATA_HOLD (Bit 0)                    */
#define SMB0_INST_DATA_TIMING_DATA_HOLD_Msk   (0xffUL)                  /*!< SMB0_INST DATA_TIMING: DATA_HOLD (Bitfield-Mask: 0xff)      */
#define SMB0_INST_DATA_TIMING_RESTART_SETUP_Pos (8UL)                   /*!< SMB0_INST DATA_TIMING: RESTART_SETUP (Bit 8)                */
#define SMB0_INST_DATA_TIMING_RESTART_SETUP_Msk (0xff00UL)              /*!< SMB0_INST DATA_TIMING: RESTART_SETUP (Bitfield-Mask: 0xff)  */
#define SMB0_INST_DATA_TIMING_STOP_SETUP_Pos  (16UL)                    /*!< SMB0_INST DATA_TIMING: STOP_SETUP (Bit 16)                  */
#define SMB0_INST_DATA_TIMING_STOP_SETUP_Msk  (0xff0000UL)              /*!< SMB0_INST DATA_TIMING: STOP_SETUP (Bitfield-Mask: 0xff)     */
#define SMB0_INST_DATA_TIMING_FIRST_START_HOLD_Pos (24UL)               /*!< SMB0_INST DATA_TIMING: FIRST_START_HOLD (Bit 24)            */
#define SMB0_INST_DATA_TIMING_FIRST_START_HOLD_Msk (0xff000000UL)       /*!< SMB0_INST DATA_TIMING: FIRST_START_HOLD (Bitfield-Mask: 0xff) */

/* -------------------------  SMB0_INST_TIME_OUT_SCALING  ------------------------- */
#define SMB0_INST_TIME_OUT_SCALING_CLOCK_HIGH_TIME_OUT_Pos (0UL)        /*!< SMB0_INST TIME_OUT_SCALING: CLOCK_HIGH_TIME_OUT (Bit 0)     */
#define SMB0_INST_TIME_OUT_SCALING_CLOCK_HIGH_TIME_OUT_Msk (0xffUL)     /*!< SMB0_INST TIME_OUT_SCALING: CLOCK_HIGH_TIME_OUT (Bitfield-Mask: 0xff) */
#define SMB0_INST_TIME_OUT_SCALING_SLAVE_CUM_TIME_OUT_Pos (8UL)         /*!< SMB0_INST TIME_OUT_SCALING: SLAVE_CUM_TIME_OUT (Bit 8)      */
#define SMB0_INST_TIME_OUT_SCALING_SLAVE_CUM_TIME_OUT_Msk (0xff00UL)    /*!< SMB0_INST TIME_OUT_SCALING: SLAVE_CUM_TIME_OUT (Bitfield-Mask: 0xff) */
#define SMB0_INST_TIME_OUT_SCALING_MASTER_CUM_TIME_OUT_Pos (16UL)       /*!< SMB0_INST TIME_OUT_SCALING: MASTER_CUM_TIME_OUT (Bit 16)    */
#define SMB0_INST_TIME_OUT_SCALING_MASTER_CUM_TIME_OUT_Msk (0xff0000UL) /*!< SMB0_INST TIME_OUT_SCALING: MASTER_CUM_TIME_OUT (Bitfield-Mask: 0xff) */
#define SMB0_INST_TIME_OUT_SCALING_BUS_IDLE_MIN_Pos (24UL)              /*!< SMB0_INST TIME_OUT_SCALING: BUS_IDLE_MIN (Bit 24)           */
#define SMB0_INST_TIME_OUT_SCALING_BUS_IDLE_MIN_Msk (0xff000000UL)      /*!< SMB0_INST TIME_OUT_SCALING: BUS_IDLE_MIN (Bitfield-Mask: 0xff) */

/* -----------------------  SMB0_INST_SLAVE_TRANSMIT_BUFFER  ---------------------- */
#define SMB0_INST_SLAVE_TRANSMIT_BUFFER_SLAVE_TRANSMIT_BUFFER_Pos (0UL) /*!< SMB0_INST SLAVE_TRANSMIT_BUFFER: SLAVE_TRANSMIT_BUFFER (Bit 0) */
#define SMB0_INST_SLAVE_TRANSMIT_BUFFER_SLAVE_TRANSMIT_BUFFER_Msk (0xffUL) /*!< SMB0_INST SLAVE_TRANSMIT_BUFFER: SLAVE_TRANSMIT_BUFFER (Bitfield-Mask: 0xff) */

/* -----------------------  SMB0_INST_SLAVE_RECEIVE_BUFFER  ----------------------- */
#define SMB0_INST_SLAVE_RECEIVE_BUFFER_SLAVE_RECEIVE_BUFFER_Pos (0UL)   /*!< SMB0_INST SLAVE_RECEIVE_BUFFER: SLAVE_RECEIVE_BUFFER (Bit 0) */
#define SMB0_INST_SLAVE_RECEIVE_BUFFER_SLAVE_RECEIVE_BUFFER_Msk (0xffUL) /*!< SMB0_INST SLAVE_RECEIVE_BUFFER: SLAVE_RECEIVE_BUFFER (Bitfield-Mask: 0xff) */

/* -----------------------  SMB0_INST_MASTER_TRANSMIT_BUFER  ---------------------- */
#define SMB0_INST_MASTER_TRANSMIT_BUFER_MASTER_TRANSMIT_BUFFER_Pos (0UL) /*!< SMB0_INST MASTER_TRANSMIT_BUFER: MASTER_TRANSMIT_BUFFER (Bit 0) */
#define SMB0_INST_MASTER_TRANSMIT_BUFER_MASTER_TRANSMIT_BUFFER_Msk (0xffUL) /*!< SMB0_INST MASTER_TRANSMIT_BUFER: MASTER_TRANSMIT_BUFFER (Bitfield-Mask: 0xff) */

/* -----------------------  SMB0_INST_MASTER_RECEIVE_BUFFER  ---------------------- */
#define SMB0_INST_MASTER_RECEIVE_BUFFER_MASTER_RECEIVE_BUFFER_Pos (0UL) /*!< SMB0_INST MASTER_RECEIVE_BUFFER: MASTER_RECEIVE_BUFFER (Bit 0) */
#define SMB0_INST_MASTER_RECEIVE_BUFFER_MASTER_RECEIVE_BUFFER_Msk (0xffUL) /*!< SMB0_INST MASTER_RECEIVE_BUFFER: MASTER_RECEIVE_BUFFER (Bitfield-Mask: 0xff) */

/* ----------------------------  SMB0_INST_WAKE_STATUS  --------------------------- */
#define SMB0_INST_WAKE_STATUS_START_BIT_DETECTION_Pos (0UL)             /*!< SMB0_INST WAKE_STATUS: START_BIT_DETECTION (Bit 0)          */
#define SMB0_INST_WAKE_STATUS_START_BIT_DETECTION_Msk (0x1UL)           /*!< SMB0_INST WAKE_STATUS: START_BIT_DETECTION (Bitfield-Mask: 0x01) */

/* ----------------------------  SMB0_INST_WAKE_ENABLE  --------------------------- */
#define SMB0_INST_WAKE_ENABLE_START_DETECT_INT_EN_Pos (0UL)             /*!< SMB0_INST WAKE_ENABLE: START_DETECT_INT_EN (Bit 0)          */
#define SMB0_INST_WAKE_ENABLE_START_DETECT_INT_EN_Msk (0x1UL)           /*!< SMB0_INST WAKE_ENABLE: START_DETECT_INT_EN (Bitfield-Mask: 0x01) */


/* ================================================================================ */
/* ================       struct 'SMB1_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ------------------------------  SMB1_INST_STATUS  ------------------------------ */
#define SMB1_INST_STATUS_NBB_Pos              (0UL)                     /*!< SMB1_INST STATUS: NBB (Bit 0)                               */
#define SMB1_INST_STATUS_NBB_Msk              (0x1UL)                   /*!< SMB1_INST STATUS: NBB (Bitfield-Mask: 0x01)                 */
#define SMB1_INST_STATUS_LAB_Pos              (1UL)                     /*!< SMB1_INST STATUS: LAB (Bit 1)                               */
#define SMB1_INST_STATUS_LAB_Msk              (0x2UL)                   /*!< SMB1_INST STATUS: LAB (Bitfield-Mask: 0x01)                 */
#define SMB1_INST_STATUS_AAS_Pos              (2UL)                     /*!< SMB1_INST STATUS: AAS (Bit 2)                               */
#define SMB1_INST_STATUS_AAS_Msk              (0x4UL)                   /*!< SMB1_INST STATUS: AAS (Bitfield-Mask: 0x01)                 */
#define SMB1_INST_STATUS_LRB_AD0_Pos          (3UL)                     /*!< SMB1_INST STATUS: LRB_AD0 (Bit 3)                           */
#define SMB1_INST_STATUS_LRB_AD0_Msk          (0x8UL)                   /*!< SMB1_INST STATUS: LRB_AD0 (Bitfield-Mask: 0x01)             */
#define SMB1_INST_STATUS_BER_Pos              (4UL)                     /*!< SMB1_INST STATUS: BER (Bit 4)                               */
#define SMB1_INST_STATUS_BER_Msk              (0x10UL)                  /*!< SMB1_INST STATUS: BER (Bitfield-Mask: 0x01)                 */
#define SMB1_INST_STATUS_STS_Pos              (5UL)                     /*!< SMB1_INST STATUS: STS (Bit 5)                               */
#define SMB1_INST_STATUS_STS_Msk              (0x20UL)                  /*!< SMB1_INST STATUS: STS (Bitfield-Mask: 0x01)                 */
#define SMB1_INST_STATUS_SAD_Pos              (6UL)                     /*!< SMB1_INST STATUS: SAD (Bit 6)                               */
#define SMB1_INST_STATUS_SAD_Msk              (0x40UL)                  /*!< SMB1_INST STATUS: SAD (Bitfield-Mask: 0x01)                 */
#define SMB1_INST_STATUS_PIN_Pos              (7UL)                     /*!< SMB1_INST STATUS: PIN (Bit 7)                               */
#define SMB1_INST_STATUS_PIN_Msk              (0x80UL)                  /*!< SMB1_INST STATUS: PIN (Bitfield-Mask: 0x01)                 */

/* ------------------------------  SMB1_INST_CONTROL  ----------------------------- */
#define SMB1_INST_CONTROL_ACK_Pos             (0UL)                     /*!< SMB1_INST CONTROL: ACK (Bit 0)                              */
#define SMB1_INST_CONTROL_ACK_Msk             (0x1UL)                   /*!< SMB1_INST CONTROL: ACK (Bitfield-Mask: 0x01)                */
#define SMB1_INST_CONTROL_STO_Pos             (1UL)                     /*!< SMB1_INST CONTROL: STO (Bit 1)                              */
#define SMB1_INST_CONTROL_STO_Msk             (0x2UL)                   /*!< SMB1_INST CONTROL: STO (Bitfield-Mask: 0x01)                */
#define SMB1_INST_CONTROL_STA_Pos             (2UL)                     /*!< SMB1_INST CONTROL: STA (Bit 2)                              */
#define SMB1_INST_CONTROL_STA_Msk             (0x4UL)                   /*!< SMB1_INST CONTROL: STA (Bitfield-Mask: 0x01)                */
#define SMB1_INST_CONTROL_ENI_Pos             (3UL)                     /*!< SMB1_INST CONTROL: ENI (Bit 3)                              */
#define SMB1_INST_CONTROL_ENI_Msk             (0x8UL)                   /*!< SMB1_INST CONTROL: ENI (Bitfield-Mask: 0x01)                */
#define SMB1_INST_CONTROL_ESO_Pos             (6UL)                     /*!< SMB1_INST CONTROL: ESO (Bit 6)                              */
#define SMB1_INST_CONTROL_ESO_Msk             (0x40UL)                  /*!< SMB1_INST CONTROL: ESO (Bitfield-Mask: 0x01)                */
#define SMB1_INST_CONTROL_PIN_Pos             (7UL)                     /*!< SMB1_INST CONTROL: PIN (Bit 7)                              */
#define SMB1_INST_CONTROL_PIN_Msk             (0x80UL)                  /*!< SMB1_INST CONTROL: PIN (Bitfield-Mask: 0x01)                */

/* --------------------------------  SMB1_INST_OWN  ------------------------------- */
#define SMB1_INST_OWN_OWN_ADDRESS_1_Pos       (0UL)                     /*!< SMB1_INST OWN: OWN_ADDRESS_1 (Bit 0)                        */
#define SMB1_INST_OWN_OWN_ADDRESS_1_Msk       (0x7fUL)                  /*!< SMB1_INST OWN: OWN_ADDRESS_1 (Bitfield-Mask: 0x7f)          */
#define SMB1_INST_OWN_OWN_ADDRESS_2_Pos       (8UL)                     /*!< SMB1_INST OWN: OWN_ADDRESS_2 (Bit 8)                        */
#define SMB1_INST_OWN_OWN_ADDRESS_2_Msk       (0x7f00UL)                /*!< SMB1_INST OWN: OWN_ADDRESS_2 (Bitfield-Mask: 0x7f)          */

/* --------------------------  SMB1_INST_MASTER_COMMAND  -------------------------- */
#define SMB1_INST_MASTER_COMMAND_MRUN_Pos     (0UL)                     /*!< SMB1_INST MASTER_COMMAND: MRUN (Bit 0)                      */
#define SMB1_INST_MASTER_COMMAND_MRUN_Msk     (0x1UL)                   /*!< SMB1_INST MASTER_COMMAND: MRUN (Bitfield-Mask: 0x01)        */
#define SMB1_INST_MASTER_COMMAND_MPROCEED_Pos (1UL)                     /*!< SMB1_INST MASTER_COMMAND: MPROCEED (Bit 1)                  */
#define SMB1_INST_MASTER_COMMAND_MPROCEED_Msk (0x2UL)                   /*!< SMB1_INST MASTER_COMMAND: MPROCEED (Bitfield-Mask: 0x01)    */
#define SMB1_INST_MASTER_COMMAND_START0_Pos   (8UL)                     /*!< SMB1_INST MASTER_COMMAND: START0 (Bit 8)                    */
#define SMB1_INST_MASTER_COMMAND_START0_Msk   (0x100UL)                 /*!< SMB1_INST MASTER_COMMAND: START0 (Bitfield-Mask: 0x01)      */
#define SMB1_INST_MASTER_COMMAND_STARTN_Pos   (9UL)                     /*!< SMB1_INST MASTER_COMMAND: STARTN (Bit 9)                    */
#define SMB1_INST_MASTER_COMMAND_STARTN_Msk   (0x200UL)                 /*!< SMB1_INST MASTER_COMMAND: STARTN (Bitfield-Mask: 0x01)      */
#define SMB1_INST_MASTER_COMMAND_STOP_Pos     (10UL)                    /*!< SMB1_INST MASTER_COMMAND: STOP (Bit 10)                     */
#define SMB1_INST_MASTER_COMMAND_STOP_Msk     (0x400UL)                 /*!< SMB1_INST MASTER_COMMAND: STOP (Bitfield-Mask: 0x01)        */
#define SMB1_INST_MASTER_COMMAND_PEC_TERM_Pos (11UL)                    /*!< SMB1_INST MASTER_COMMAND: PEC_TERM (Bit 11)                 */
#define SMB1_INST_MASTER_COMMAND_PEC_TERM_Msk (0x800UL)                 /*!< SMB1_INST MASTER_COMMAND: PEC_TERM (Bitfield-Mask: 0x01)    */
#define SMB1_INST_MASTER_COMMAND_READM_Pos    (12UL)                    /*!< SMB1_INST MASTER_COMMAND: READM (Bit 12)                    */
#define SMB1_INST_MASTER_COMMAND_READM_Msk    (0x1000UL)                /*!< SMB1_INST MASTER_COMMAND: READM (Bitfield-Mask: 0x01)       */
#define SMB1_INST_MASTER_COMMAND_READ_PEC_Pos (13UL)                    /*!< SMB1_INST MASTER_COMMAND: READ_PEC (Bit 13)                 */
#define SMB1_INST_MASTER_COMMAND_READ_PEC_Msk (0x2000UL)                /*!< SMB1_INST MASTER_COMMAND: READ_PEC (Bitfield-Mask: 0x01)    */
#define SMB1_INST_MASTER_COMMAND_WRITE_COUNT_Pos (16UL)                 /*!< SMB1_INST MASTER_COMMAND: WRITE_COUNT (Bit 16)              */
#define SMB1_INST_MASTER_COMMAND_WRITE_COUNT_Msk (0xff0000UL)           /*!< SMB1_INST MASTER_COMMAND: WRITE_COUNT (Bitfield-Mask: 0xff) */
#define SMB1_INST_MASTER_COMMAND_READ_COUNT_Pos (24UL)                  /*!< SMB1_INST MASTER_COMMAND: READ_COUNT (Bit 24)               */
#define SMB1_INST_MASTER_COMMAND_READ_COUNT_Msk (0xff000000UL)          /*!< SMB1_INST MASTER_COMMAND: READ_COUNT (Bitfield-Mask: 0xff)  */

/* ---------------------------  SMB1_INST_SLAVE_COMMAND  -------------------------- */
#define SMB1_INST_SLAVE_COMMAND_SRUN_Pos      (0UL)                     /*!< SMB1_INST SLAVE_COMMAND: SRUN (Bit 0)                       */
#define SMB1_INST_SLAVE_COMMAND_SRUN_Msk      (0x1UL)                   /*!< SMB1_INST SLAVE_COMMAND: SRUN (Bitfield-Mask: 0x01)         */
#define SMB1_INST_SLAVE_COMMAND_SPROCEED_Pos  (1UL)                     /*!< SMB1_INST SLAVE_COMMAND: SPROCEED (Bit 1)                   */
#define SMB1_INST_SLAVE_COMMAND_SPROCEED_Msk  (0x2UL)                   /*!< SMB1_INST SLAVE_COMMAND: SPROCEED (Bitfield-Mask: 0x01)     */
#define SMB1_INST_SLAVE_COMMAND_SLAVE_PEC_Pos (2UL)                     /*!< SMB1_INST SLAVE_COMMAND: SLAVE_PEC (Bit 2)                  */
#define SMB1_INST_SLAVE_COMMAND_SLAVE_PEC_Msk (0x4UL)                   /*!< SMB1_INST SLAVE_COMMAND: SLAVE_PEC (Bitfield-Mask: 0x01)    */
#define SMB1_INST_SLAVE_COMMAND_SLAVE_WRITECOUNT_Pos (8UL)              /*!< SMB1_INST SLAVE_COMMAND: SLAVE_WRITECOUNT (Bit 8)           */
#define SMB1_INST_SLAVE_COMMAND_SLAVE_WRITECOUNT_Msk (0xff00UL)         /*!< SMB1_INST SLAVE_COMMAND: SLAVE_WRITECOUNT (Bitfield-Mask: 0xff) */
#define SMB1_INST_SLAVE_COMMAND_SLAVE_READCOUNT_Pos (16UL)              /*!< SMB1_INST SLAVE_COMMAND: SLAVE_READCOUNT (Bit 16)           */
#define SMB1_INST_SLAVE_COMMAND_SLAVE_READCOUNT_Msk (0xff0000UL)        /*!< SMB1_INST SLAVE_COMMAND: SLAVE_READCOUNT (Bitfield-Mask: 0xff) */

/* --------------------------------  SMB1_INST_PEC  ------------------------------- */
#define SMB1_INST_PEC_PEC_Pos                 (0UL)                     /*!< SMB1_INST PEC: PEC (Bit 0)                                  */
#define SMB1_INST_PEC_PEC_Msk                 (0xffUL)                  /*!< SMB1_INST PEC: PEC (Bitfield-Mask: 0xff)                    */

/* ---------------------  SMB1_INST_REPEATED_START_HOLD_TIME  --------------------- */
#define SMB1_INST_REPEATED_START_HOLD_TIME_RPT_START_HOLD_TIME_Pos (0UL) /*!< SMB1_INST REPEATED_START_HOLD_TIME: RPT_START_HOLD_TIME (Bit 0) */
#define SMB1_INST_REPEATED_START_HOLD_TIME_RPT_START_HOLD_TIME_Msk (0xffUL) /*!< SMB1_INST REPEATED_START_HOLD_TIME: RPT_START_HOLD_TIME (Bitfield-Mask: 0xff) */

/* ----------------------------  SMB1_INST_COMPLETION  ---------------------------- */
#define SMB1_INST_COMPLETION_DTEN_Pos         (2UL)                     /*!< SMB1_INST COMPLETION: DTEN (Bit 2)                          */
#define SMB1_INST_COMPLETION_DTEN_Msk         (0x4UL)                   /*!< SMB1_INST COMPLETION: DTEN (Bitfield-Mask: 0x01)            */
#define SMB1_INST_COMPLETION_MCEN_Pos         (3UL)                     /*!< SMB1_INST COMPLETION: MCEN (Bit 3)                          */
#define SMB1_INST_COMPLETION_MCEN_Msk         (0x8UL)                   /*!< SMB1_INST COMPLETION: MCEN (Bitfield-Mask: 0x01)            */
#define SMB1_INST_COMPLETION_SCEN_Pos         (4UL)                     /*!< SMB1_INST COMPLETION: SCEN (Bit 4)                          */
#define SMB1_INST_COMPLETION_SCEN_Msk         (0x10UL)                  /*!< SMB1_INST COMPLETION: SCEN (Bitfield-Mask: 0x01)            */
#define SMB1_INST_COMPLETION_BIDEN_Pos        (5UL)                     /*!< SMB1_INST COMPLETION: BIDEN (Bit 5)                         */
#define SMB1_INST_COMPLETION_BIDEN_Msk        (0x20UL)                  /*!< SMB1_INST COMPLETION: BIDEN (Bitfield-Mask: 0x01)           */
#define SMB1_INST_COMPLETION_TIMERR_Pos       (6UL)                     /*!< SMB1_INST COMPLETION: TIMERR (Bit 6)                        */
#define SMB1_INST_COMPLETION_TIMERR_Msk       (0x40UL)                  /*!< SMB1_INST COMPLETION: TIMERR (Bitfield-Mask: 0x01)          */
#define SMB1_INST_COMPLETION_DTO_Pos          (8UL)                     /*!< SMB1_INST COMPLETION: DTO (Bit 8)                           */
#define SMB1_INST_COMPLETION_DTO_Msk          (0x100UL)                 /*!< SMB1_INST COMPLETION: DTO (Bitfield-Mask: 0x01)             */
#define SMB1_INST_COMPLETION_MCTO_Pos         (9UL)                     /*!< SMB1_INST COMPLETION: MCTO (Bit 9)                          */
#define SMB1_INST_COMPLETION_MCTO_Msk         (0x200UL)                 /*!< SMB1_INST COMPLETION: MCTO (Bitfield-Mask: 0x01)            */
#define SMB1_INST_COMPLETION_SCTO_Pos         (10UL)                    /*!< SMB1_INST COMPLETION: SCTO (Bit 10)                         */
#define SMB1_INST_COMPLETION_SCTO_Msk         (0x400UL)                 /*!< SMB1_INST COMPLETION: SCTO (Bitfield-Mask: 0x01)            */
#define SMB1_INST_COMPLETION_CHDL_Pos         (11UL)                    /*!< SMB1_INST COMPLETION: CHDL (Bit 11)                         */
#define SMB1_INST_COMPLETION_CHDL_Msk         (0x800UL)                 /*!< SMB1_INST COMPLETION: CHDL (Bitfield-Mask: 0x01)            */
#define SMB1_INST_COMPLETION_CHDH_Pos         (12UL)                    /*!< SMB1_INST COMPLETION: CHDH (Bit 12)                         */
#define SMB1_INST_COMPLETION_CHDH_Msk         (0x1000UL)                /*!< SMB1_INST COMPLETION: CHDH (Bitfield-Mask: 0x01)            */
#define SMB1_INST_COMPLETION_BER_Pos          (13UL)                    /*!< SMB1_INST COMPLETION: BER (Bit 13)                          */
#define SMB1_INST_COMPLETION_BER_Msk          (0x2000UL)                /*!< SMB1_INST COMPLETION: BER (Bitfield-Mask: 0x01)             */
#define SMB1_INST_COMPLETION_LAB_Pos          (14UL)                    /*!< SMB1_INST COMPLETION: LAB (Bit 14)                          */
#define SMB1_INST_COMPLETION_LAB_Msk          (0x4000UL)                /*!< SMB1_INST COMPLETION: LAB (Bitfield-Mask: 0x01)             */
#define SMB1_INST_COMPLETION_SNAKR_Pos        (16UL)                    /*!< SMB1_INST COMPLETION: SNAKR (Bit 16)                        */
#define SMB1_INST_COMPLETION_SNAKR_Msk        (0x10000UL)               /*!< SMB1_INST COMPLETION: SNAKR (Bitfield-Mask: 0x01)           */
#define SMB1_INST_COMPLETION_STR_Pos          (17UL)                    /*!< SMB1_INST COMPLETION: STR (Bit 17)                          */
#define SMB1_INST_COMPLETION_STR_Msk          (0x20000UL)               /*!< SMB1_INST COMPLETION: STR (Bitfield-Mask: 0x01)             */
#define SMB1_INST_COMPLETION_SPROT_Pos        (19UL)                    /*!< SMB1_INST COMPLETION: SPROT (Bit 19)                        */
#define SMB1_INST_COMPLETION_SPROT_Msk        (0x80000UL)               /*!< SMB1_INST COMPLETION: SPROT (Bitfield-Mask: 0x01)           */
#define SMB1_INST_COMPLETION_REPEAT_READ_Pos  (20UL)                    /*!< SMB1_INST COMPLETION: REPEAT_READ (Bit 20)                  */
#define SMB1_INST_COMPLETION_REPEAT_READ_Msk  (0x100000UL)              /*!< SMB1_INST COMPLETION: REPEAT_READ (Bitfield-Mask: 0x01)     */
#define SMB1_INST_COMPLETION_REPEAT_WRITE_Pos (21UL)                    /*!< SMB1_INST COMPLETION: REPEAT_WRITE (Bit 21)                 */
#define SMB1_INST_COMPLETION_REPEAT_WRITE_Msk (0x200000UL)              /*!< SMB1_INST COMPLETION: REPEAT_WRITE (Bitfield-Mask: 0x01)    */
#define SMB1_INST_COMPLETION_MNAKX_Pos        (24UL)                    /*!< SMB1_INST COMPLETION: MNAKX (Bit 24)                        */
#define SMB1_INST_COMPLETION_MNAKX_Msk        (0x1000000UL)             /*!< SMB1_INST COMPLETION: MNAKX (Bitfield-Mask: 0x01)           */
#define SMB1_INST_COMPLETION_MTR_Pos          (25UL)                    /*!< SMB1_INST COMPLETION: MTR (Bit 25)                          */
#define SMB1_INST_COMPLETION_MTR_Msk          (0x2000000UL)             /*!< SMB1_INST COMPLETION: MTR (Bitfield-Mask: 0x01)             */
#define SMB1_INST_COMPLETION_IDLE_Pos         (29UL)                    /*!< SMB1_INST COMPLETION: IDLE (Bit 29)                         */
#define SMB1_INST_COMPLETION_IDLE_Msk         (0x20000000UL)            /*!< SMB1_INST COMPLETION: IDLE (Bitfield-Mask: 0x01)            */
#define SMB1_INST_COMPLETION_MDONE_Pos        (30UL)                    /*!< SMB1_INST COMPLETION: MDONE (Bit 30)                        */
#define SMB1_INST_COMPLETION_MDONE_Msk        (0x40000000UL)            /*!< SMB1_INST COMPLETION: MDONE (Bitfield-Mask: 0x01)           */
#define SMB1_INST_COMPLETION_SDONE_Pos        (31UL)                    /*!< SMB1_INST COMPLETION: SDONE (Bit 31)                        */
#define SMB1_INST_COMPLETION_SDONE_Msk        (0x80000000UL)            /*!< SMB1_INST COMPLETION: SDONE (Bitfield-Mask: 0x01)           */

/* ---------------------------  SMB1_INST_IDLE_SCALING  --------------------------- */
#define SMB1_INST_IDLE_SCALING_FAIR_BUS_IDLE_MIN_Pos (0UL)              /*!< SMB1_INST IDLE_SCALING: FAIR_BUS_IDLE_MIN (Bit 0)           */
#define SMB1_INST_IDLE_SCALING_FAIR_BUS_IDLE_MIN_Msk (0xfffUL)          /*!< SMB1_INST IDLE_SCALING: FAIR_BUS_IDLE_MIN (Bitfield-Mask: 0xfff) */
#define SMB1_INST_IDLE_SCALING_FAIR_IDLE_DELAY_Pos (16UL)               /*!< SMB1_INST IDLE_SCALING: FAIR_IDLE_DELAY (Bit 16)            */
#define SMB1_INST_IDLE_SCALING_FAIR_IDLE_DELAY_Msk (0xfff0000UL)        /*!< SMB1_INST IDLE_SCALING: FAIR_IDLE_DELAY (Bitfield-Mask: 0xfff) */

/* ---------------------------  SMB1_INST_CONFIGURATION  -------------------------- */
#define SMB1_INST_CONFIGURATION_PORT_SEL_Pos  (0UL)                     /*!< SMB1_INST CONFIGURATION: PORT_SEL (Bit 0)                   */
#define SMB1_INST_CONFIGURATION_PORT_SEL_Msk  (0xfUL)                   /*!< SMB1_INST CONFIGURATION: PORT_SEL (Bitfield-Mask: 0x0f)     */
#define SMB1_INST_CONFIGURATION_TCEN_Pos      (4UL)                     /*!< SMB1_INST CONFIGURATION: TCEN (Bit 4)                       */
#define SMB1_INST_CONFIGURATION_TCEN_Msk      (0x10UL)                  /*!< SMB1_INST CONFIGURATION: TCEN (Bitfield-Mask: 0x01)         */
#define SMB1_INST_CONFIGURATION_SLOW_CLOCK_Pos (5UL)                    /*!< SMB1_INST CONFIGURATION: SLOW_CLOCK (Bit 5)                 */
#define SMB1_INST_CONFIGURATION_SLOW_CLOCK_Msk (0x20UL)                 /*!< SMB1_INST CONFIGURATION: SLOW_CLOCK (Bitfield-Mask: 0x01)   */
#define SMB1_INST_CONFIGURATION_TEST_Pos      (6UL)                     /*!< SMB1_INST CONFIGURATION: TEST (Bit 6)                       */
#define SMB1_INST_CONFIGURATION_TEST_Msk      (0x40UL)                  /*!< SMB1_INST CONFIGURATION: TEST (Bitfield-Mask: 0x01)         */
#define SMB1_INST_CONFIGURATION_PECEN_Pos     (7UL)                     /*!< SMB1_INST CONFIGURATION: PECEN (Bit 7)                      */
#define SMB1_INST_CONFIGURATION_PECEN_Msk     (0x80UL)                  /*!< SMB1_INST CONFIGURATION: PECEN (Bitfield-Mask: 0x01)        */
#define SMB1_INST_CONFIGURATION_FEN_Pos       (8UL)                     /*!< SMB1_INST CONFIGURATION: FEN (Bit 8)                        */
#define SMB1_INST_CONFIGURATION_FEN_Msk       (0x100UL)                 /*!< SMB1_INST CONFIGURATION: FEN (Bitfield-Mask: 0x01)          */
#define SMB1_INST_CONFIGURATION_RESET_Pos     (9UL)                     /*!< SMB1_INST CONFIGURATION: RESET (Bit 9)                      */
#define SMB1_INST_CONFIGURATION_RESET_Msk     (0x200UL)                 /*!< SMB1_INST CONFIGURATION: RESET (Bitfield-Mask: 0x01)        */
#define SMB1_INST_CONFIGURATION_ENAB_Pos      (10UL)                    /*!< SMB1_INST CONFIGURATION: ENAB (Bit 10)                      */
#define SMB1_INST_CONFIGURATION_ENAB_Msk      (0x400UL)                 /*!< SMB1_INST CONFIGURATION: ENAB (Bitfield-Mask: 0x01)         */
#define SMB1_INST_CONFIGURATION_DSA_Pos       (11UL)                    /*!< SMB1_INST CONFIGURATION: DSA (Bit 11)                       */
#define SMB1_INST_CONFIGURATION_DSA_Msk       (0x800UL)                 /*!< SMB1_INST CONFIGURATION: DSA (Bitfield-Mask: 0x01)          */
#define SMB1_INST_CONFIGURATION_FAIR_Pos      (12UL)                    /*!< SMB1_INST CONFIGURATION: FAIR (Bit 12)                      */
#define SMB1_INST_CONFIGURATION_FAIR_Msk      (0x1000UL)                /*!< SMB1_INST CONFIGURATION: FAIR (Bitfield-Mask: 0x01)         */
#define SMB1_INST_CONFIGURATION_TEST0_Pos     (13UL)                    /*!< SMB1_INST CONFIGURATION: TEST0 (Bit 13)                     */
#define SMB1_INST_CONFIGURATION_TEST0_Msk     (0x2000UL)                /*!< SMB1_INST CONFIGURATION: TEST0 (Bitfield-Mask: 0x01)        */
#define SMB1_INST_CONFIGURATION_GC_DIS_Pos    (14UL)                    /*!< SMB1_INST CONFIGURATION: GC_DIS (Bit 14)                    */
#define SMB1_INST_CONFIGURATION_GC_DIS_Msk    (0x4000UL)                /*!< SMB1_INST CONFIGURATION: GC_DIS (Bitfield-Mask: 0x01)       */
#define SMB1_INST_CONFIGURATION_FLUSH_SXBUF_Pos (16UL)                  /*!< SMB1_INST CONFIGURATION: FLUSH_SXBUF (Bit 16)               */
#define SMB1_INST_CONFIGURATION_FLUSH_SXBUF_Msk (0x10000UL)             /*!< SMB1_INST CONFIGURATION: FLUSH_SXBUF (Bitfield-Mask: 0x01)  */
#define SMB1_INST_CONFIGURATION_FLUSH_SRBUF_Pos (17UL)                  /*!< SMB1_INST CONFIGURATION: FLUSH_SRBUF (Bit 17)               */
#define SMB1_INST_CONFIGURATION_FLUSH_SRBUF_Msk (0x20000UL)             /*!< SMB1_INST CONFIGURATION: FLUSH_SRBUF (Bitfield-Mask: 0x01)  */
#define SMB1_INST_CONFIGURATION_FLUSH_MXBUF_Pos (18UL)                  /*!< SMB1_INST CONFIGURATION: FLUSH_MXBUF (Bit 18)               */
#define SMB1_INST_CONFIGURATION_FLUSH_MXBUF_Msk (0x40000UL)             /*!< SMB1_INST CONFIGURATION: FLUSH_MXBUF (Bitfield-Mask: 0x01)  */
#define SMB1_INST_CONFIGURATION_FLUSH_MRBUF_Pos (19UL)                  /*!< SMB1_INST CONFIGURATION: FLUSH_MRBUF (Bit 19)               */
#define SMB1_INST_CONFIGURATION_FLUSH_MRBUF_Msk (0x80000UL)             /*!< SMB1_INST CONFIGURATION: FLUSH_MRBUF (Bitfield-Mask: 0x01)  */
#define SMB1_INST_CONFIGURATION_EN_AAS_Pos    (28UL)                    /*!< SMB1_INST CONFIGURATION: EN_AAS (Bit 28)                    */
#define SMB1_INST_CONFIGURATION_EN_AAS_Msk    (0x10000000UL)            /*!< SMB1_INST CONFIGURATION: EN_AAS (Bitfield-Mask: 0x01)       */
#define SMB1_INST_CONFIGURATION_ENIDI_Pos     (29UL)                    /*!< SMB1_INST CONFIGURATION: ENIDI (Bit 29)                     */
#define SMB1_INST_CONFIGURATION_ENIDI_Msk     (0x20000000UL)            /*!< SMB1_INST CONFIGURATION: ENIDI (Bitfield-Mask: 0x01)        */
#define SMB1_INST_CONFIGURATION_ENMI_Pos      (30UL)                    /*!< SMB1_INST CONFIGURATION: ENMI (Bit 30)                      */
#define SMB1_INST_CONFIGURATION_ENMI_Msk      (0x40000000UL)            /*!< SMB1_INST CONFIGURATION: ENMI (Bitfield-Mask: 0x01)         */
#define SMB1_INST_CONFIGURATION_ENSI_Pos      (31UL)                    /*!< SMB1_INST CONFIGURATION: ENSI (Bit 31)                      */
#define SMB1_INST_CONFIGURATION_ENSI_Msk      (0x80000000UL)            /*!< SMB1_INST CONFIGURATION: ENSI (Bitfield-Mask: 0x01)         */

/* -----------------------------  SMB1_INST_BUS_CLOCK  ---------------------------- */
#define SMB1_INST_BUS_CLOCK_LOW_PERIOD_Pos    (0UL)                     /*!< SMB1_INST BUS_CLOCK: LOW_PERIOD (Bit 0)                     */
#define SMB1_INST_BUS_CLOCK_LOW_PERIOD_Msk    (0xffUL)                  /*!< SMB1_INST BUS_CLOCK: LOW_PERIOD (Bitfield-Mask: 0xff)       */
#define SMB1_INST_BUS_CLOCK_HIGH_PERIOD_Pos   (8UL)                     /*!< SMB1_INST BUS_CLOCK: HIGH_PERIOD (Bit 8)                    */
#define SMB1_INST_BUS_CLOCK_HIGH_PERIOD_Msk   (0xff00UL)                /*!< SMB1_INST BUS_CLOCK: HIGH_PERIOD (Bitfield-Mask: 0xff)      */

/* -----------------------------  SMB1_INST_BLOCK_ID  ----------------------------- */
#define SMB1_INST_BLOCK_ID_ID_Pos             (0UL)                     /*!< SMB1_INST BLOCK_ID: ID (Bit 0)                              */
#define SMB1_INST_BLOCK_ID_ID_Msk             (0xffUL)                  /*!< SMB1_INST BLOCK_ID: ID (Bitfield-Mask: 0xff)                */

/* -----------------------------  SMB1_INST_REVISION  ----------------------------- */
#define SMB1_INST_REVISION_REVISION_Pos       (0UL)                     /*!< SMB1_INST REVISION: REVISION (Bit 0)                        */
#define SMB1_INST_REVISION_REVISION_Msk       (0xffUL)                  /*!< SMB1_INST REVISION: REVISION (Bitfield-Mask: 0xff)          */

/* -------------------------  SMB1_INST_BIT_BANG_CONTROL  ------------------------- */
#define SMB1_INST_BIT_BANG_CONTROL_BBEN_Pos   (0UL)                     /*!< SMB1_INST BIT_BANG_CONTROL: BBEN (Bit 0)                    */
#define SMB1_INST_BIT_BANG_CONTROL_BBEN_Msk   (0x1UL)                   /*!< SMB1_INST BIT_BANG_CONTROL: BBEN (Bitfield-Mask: 0x01)      */
#define SMB1_INST_BIT_BANG_CONTROL_CLDIR_Pos  (1UL)                     /*!< SMB1_INST BIT_BANG_CONTROL: CLDIR (Bit 1)                   */
#define SMB1_INST_BIT_BANG_CONTROL_CLDIR_Msk  (0x2UL)                   /*!< SMB1_INST BIT_BANG_CONTROL: CLDIR (Bitfield-Mask: 0x01)     */
#define SMB1_INST_BIT_BANG_CONTROL_DADIR_Pos  (2UL)                     /*!< SMB1_INST BIT_BANG_CONTROL: DADIR (Bit 2)                   */
#define SMB1_INST_BIT_BANG_CONTROL_DADIR_Msk  (0x4UL)                   /*!< SMB1_INST BIT_BANG_CONTROL: DADIR (Bitfield-Mask: 0x01)     */
#define SMB1_INST_BIT_BANG_CONTROL_BBCLK_Pos  (3UL)                     /*!< SMB1_INST BIT_BANG_CONTROL: BBCLK (Bit 3)                   */
#define SMB1_INST_BIT_BANG_CONTROL_BBCLK_Msk  (0x8UL)                   /*!< SMB1_INST BIT_BANG_CONTROL: BBCLK (Bitfield-Mask: 0x01)     */
#define SMB1_INST_BIT_BANG_CONTROL_BBDAT_Pos  (4UL)                     /*!< SMB1_INST BIT_BANG_CONTROL: BBDAT (Bit 4)                   */
#define SMB1_INST_BIT_BANG_CONTROL_BBDAT_Msk  (0x10UL)                  /*!< SMB1_INST BIT_BANG_CONTROL: BBDAT (Bitfield-Mask: 0x01)     */
#define SMB1_INST_BIT_BANG_CONTROL_BBCLKI_Pos (5UL)                     /*!< SMB1_INST BIT_BANG_CONTROL: BBCLKI (Bit 5)                  */
#define SMB1_INST_BIT_BANG_CONTROL_BBCLKI_Msk (0x20UL)                  /*!< SMB1_INST BIT_BANG_CONTROL: BBCLKI (Bitfield-Mask: 0x01)    */
#define SMB1_INST_BIT_BANG_CONTROL_BBDATI_Pos (6UL)                     /*!< SMB1_INST BIT_BANG_CONTROL: BBDATI (Bit 6)                  */
#define SMB1_INST_BIT_BANG_CONTROL_BBDATI_Msk (0x40UL)                  /*!< SMB1_INST BIT_BANG_CONTROL: BBDATI (Bitfield-Mask: 0x01)    */

/* -------------------------------  SMB1_INST_TEST  ------------------------------- */
#define SMB1_INST_TEST_TEST_Pos               (0UL)                     /*!< SMB1_INST TEST: TEST (Bit 0)                                */
#define SMB1_INST_TEST_TEST_Msk               (0xffUL)                  /*!< SMB1_INST TEST: TEST (Bitfield-Mask: 0xff)                  */

/* ----------------------------  SMB1_INST_DATA_TIMING  --------------------------- */
#define SMB1_INST_DATA_TIMING_DATA_HOLD_Pos   (0UL)                     /*!< SMB1_INST DATA_TIMING: DATA_HOLD (Bit 0)                    */
#define SMB1_INST_DATA_TIMING_DATA_HOLD_Msk   (0xffUL)                  /*!< SMB1_INST DATA_TIMING: DATA_HOLD (Bitfield-Mask: 0xff)      */
#define SMB1_INST_DATA_TIMING_RESTART_SETUP_Pos (8UL)                   /*!< SMB1_INST DATA_TIMING: RESTART_SETUP (Bit 8)                */
#define SMB1_INST_DATA_TIMING_RESTART_SETUP_Msk (0xff00UL)              /*!< SMB1_INST DATA_TIMING: RESTART_SETUP (Bitfield-Mask: 0xff)  */
#define SMB1_INST_DATA_TIMING_STOP_SETUP_Pos  (16UL)                    /*!< SMB1_INST DATA_TIMING: STOP_SETUP (Bit 16)                  */
#define SMB1_INST_DATA_TIMING_STOP_SETUP_Msk  (0xff0000UL)              /*!< SMB1_INST DATA_TIMING: STOP_SETUP (Bitfield-Mask: 0xff)     */
#define SMB1_INST_DATA_TIMING_FIRST_START_HOLD_Pos (24UL)               /*!< SMB1_INST DATA_TIMING: FIRST_START_HOLD (Bit 24)            */
#define SMB1_INST_DATA_TIMING_FIRST_START_HOLD_Msk (0xff000000UL)       /*!< SMB1_INST DATA_TIMING: FIRST_START_HOLD (Bitfield-Mask: 0xff) */

/* -------------------------  SMB1_INST_TIME_OUT_SCALING  ------------------------- */
#define SMB1_INST_TIME_OUT_SCALING_CLOCK_HIGH_TIME_OUT_Pos (0UL)        /*!< SMB1_INST TIME_OUT_SCALING: CLOCK_HIGH_TIME_OUT (Bit 0)     */
#define SMB1_INST_TIME_OUT_SCALING_CLOCK_HIGH_TIME_OUT_Msk (0xffUL)     /*!< SMB1_INST TIME_OUT_SCALING: CLOCK_HIGH_TIME_OUT (Bitfield-Mask: 0xff) */
#define SMB1_INST_TIME_OUT_SCALING_SLAVE_CUM_TIME_OUT_Pos (8UL)         /*!< SMB1_INST TIME_OUT_SCALING: SLAVE_CUM_TIME_OUT (Bit 8)      */
#define SMB1_INST_TIME_OUT_SCALING_SLAVE_CUM_TIME_OUT_Msk (0xff00UL)    /*!< SMB1_INST TIME_OUT_SCALING: SLAVE_CUM_TIME_OUT (Bitfield-Mask: 0xff) */
#define SMB1_INST_TIME_OUT_SCALING_MASTER_CUM_TIME_OUT_Pos (16UL)       /*!< SMB1_INST TIME_OUT_SCALING: MASTER_CUM_TIME_OUT (Bit 16)    */
#define SMB1_INST_TIME_OUT_SCALING_MASTER_CUM_TIME_OUT_Msk (0xff0000UL) /*!< SMB1_INST TIME_OUT_SCALING: MASTER_CUM_TIME_OUT (Bitfield-Mask: 0xff) */
#define SMB1_INST_TIME_OUT_SCALING_BUS_IDLE_MIN_Pos (24UL)              /*!< SMB1_INST TIME_OUT_SCALING: BUS_IDLE_MIN (Bit 24)           */
#define SMB1_INST_TIME_OUT_SCALING_BUS_IDLE_MIN_Msk (0xff000000UL)      /*!< SMB1_INST TIME_OUT_SCALING: BUS_IDLE_MIN (Bitfield-Mask: 0xff) */

/* -----------------------  SMB1_INST_SLAVE_TRANSMIT_BUFFER  ---------------------- */
#define SMB1_INST_SLAVE_TRANSMIT_BUFFER_SLAVE_TRANSMIT_BUFFER_Pos (0UL) /*!< SMB1_INST SLAVE_TRANSMIT_BUFFER: SLAVE_TRANSMIT_BUFFER (Bit 0) */
#define SMB1_INST_SLAVE_TRANSMIT_BUFFER_SLAVE_TRANSMIT_BUFFER_Msk (0xffUL) /*!< SMB1_INST SLAVE_TRANSMIT_BUFFER: SLAVE_TRANSMIT_BUFFER (Bitfield-Mask: 0xff) */

/* -----------------------  SMB1_INST_SLAVE_RECEIVE_BUFFER  ----------------------- */
#define SMB1_INST_SLAVE_RECEIVE_BUFFER_SLAVE_RECEIVE_BUFFER_Pos (0UL)   /*!< SMB1_INST SLAVE_RECEIVE_BUFFER: SLAVE_RECEIVE_BUFFER (Bit 0) */
#define SMB1_INST_SLAVE_RECEIVE_BUFFER_SLAVE_RECEIVE_BUFFER_Msk (0xffUL) /*!< SMB1_INST SLAVE_RECEIVE_BUFFER: SLAVE_RECEIVE_BUFFER (Bitfield-Mask: 0xff) */

/* -----------------------  SMB1_INST_MASTER_TRANSMIT_BUFER  ---------------------- */
#define SMB1_INST_MASTER_TRANSMIT_BUFER_MASTER_TRANSMIT_BUFFER_Pos (0UL) /*!< SMB1_INST MASTER_TRANSMIT_BUFER: MASTER_TRANSMIT_BUFFER (Bit 0) */
#define SMB1_INST_MASTER_TRANSMIT_BUFER_MASTER_TRANSMIT_BUFFER_Msk (0xffUL) /*!< SMB1_INST MASTER_TRANSMIT_BUFER: MASTER_TRANSMIT_BUFFER (Bitfield-Mask: 0xff) */

/* -----------------------  SMB1_INST_MASTER_RECEIVE_BUFFER  ---------------------- */
#define SMB1_INST_MASTER_RECEIVE_BUFFER_MASTER_RECEIVE_BUFFER_Pos (0UL) /*!< SMB1_INST MASTER_RECEIVE_BUFFER: MASTER_RECEIVE_BUFFER (Bit 0) */
#define SMB1_INST_MASTER_RECEIVE_BUFFER_MASTER_RECEIVE_BUFFER_Msk (0xffUL) /*!< SMB1_INST MASTER_RECEIVE_BUFFER: MASTER_RECEIVE_BUFFER (Bitfield-Mask: 0xff) */

/* ----------------------------  SMB1_INST_WAKE_STATUS  --------------------------- */
#define SMB1_INST_WAKE_STATUS_START_BIT_DETECTION_Pos (0UL)             /*!< SMB1_INST WAKE_STATUS: START_BIT_DETECTION (Bit 0)          */
#define SMB1_INST_WAKE_STATUS_START_BIT_DETECTION_Msk (0x1UL)           /*!< SMB1_INST WAKE_STATUS: START_BIT_DETECTION (Bitfield-Mask: 0x01) */

/* ----------------------------  SMB1_INST_WAKE_ENABLE  --------------------------- */
#define SMB1_INST_WAKE_ENABLE_START_DETECT_INT_EN_Pos (0UL)             /*!< SMB1_INST WAKE_ENABLE: START_DETECT_INT_EN (Bit 0)          */
#define SMB1_INST_WAKE_ENABLE_START_DETECT_INT_EN_Msk (0x1UL)           /*!< SMB1_INST WAKE_ENABLE: START_DETECT_INT_EN (Bitfield-Mask: 0x01) */


/* ================================================================================ */
/* ================       struct 'SMB2_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ------------------------------  SMB2_INST_STATUS  ------------------------------ */
#define SMB2_INST_STATUS_NBB_Pos              (0UL)                     /*!< SMB2_INST STATUS: NBB (Bit 0)                               */
#define SMB2_INST_STATUS_NBB_Msk              (0x1UL)                   /*!< SMB2_INST STATUS: NBB (Bitfield-Mask: 0x01)                 */
#define SMB2_INST_STATUS_LAB_Pos              (1UL)                     /*!< SMB2_INST STATUS: LAB (Bit 1)                               */
#define SMB2_INST_STATUS_LAB_Msk              (0x2UL)                   /*!< SMB2_INST STATUS: LAB (Bitfield-Mask: 0x01)                 */
#define SMB2_INST_STATUS_AAS_Pos              (2UL)                     /*!< SMB2_INST STATUS: AAS (Bit 2)                               */
#define SMB2_INST_STATUS_AAS_Msk              (0x4UL)                   /*!< SMB2_INST STATUS: AAS (Bitfield-Mask: 0x01)                 */
#define SMB2_INST_STATUS_LRB_AD0_Pos          (3UL)                     /*!< SMB2_INST STATUS: LRB_AD0 (Bit 3)                           */
#define SMB2_INST_STATUS_LRB_AD0_Msk          (0x8UL)                   /*!< SMB2_INST STATUS: LRB_AD0 (Bitfield-Mask: 0x01)             */
#define SMB2_INST_STATUS_BER_Pos              (4UL)                     /*!< SMB2_INST STATUS: BER (Bit 4)                               */
#define SMB2_INST_STATUS_BER_Msk              (0x10UL)                  /*!< SMB2_INST STATUS: BER (Bitfield-Mask: 0x01)                 */
#define SMB2_INST_STATUS_STS_Pos              (5UL)                     /*!< SMB2_INST STATUS: STS (Bit 5)                               */
#define SMB2_INST_STATUS_STS_Msk              (0x20UL)                  /*!< SMB2_INST STATUS: STS (Bitfield-Mask: 0x01)                 */
#define SMB2_INST_STATUS_SAD_Pos              (6UL)                     /*!< SMB2_INST STATUS: SAD (Bit 6)                               */
#define SMB2_INST_STATUS_SAD_Msk              (0x40UL)                  /*!< SMB2_INST STATUS: SAD (Bitfield-Mask: 0x01)                 */
#define SMB2_INST_STATUS_PIN_Pos              (7UL)                     /*!< SMB2_INST STATUS: PIN (Bit 7)                               */
#define SMB2_INST_STATUS_PIN_Msk              (0x80UL)                  /*!< SMB2_INST STATUS: PIN (Bitfield-Mask: 0x01)                 */

/* ------------------------------  SMB2_INST_CONTROL  ----------------------------- */
#define SMB2_INST_CONTROL_ACK_Pos             (0UL)                     /*!< SMB2_INST CONTROL: ACK (Bit 0)                              */
#define SMB2_INST_CONTROL_ACK_Msk             (0x1UL)                   /*!< SMB2_INST CONTROL: ACK (Bitfield-Mask: 0x01)                */
#define SMB2_INST_CONTROL_STO_Pos             (1UL)                     /*!< SMB2_INST CONTROL: STO (Bit 1)                              */
#define SMB2_INST_CONTROL_STO_Msk             (0x2UL)                   /*!< SMB2_INST CONTROL: STO (Bitfield-Mask: 0x01)                */
#define SMB2_INST_CONTROL_STA_Pos             (2UL)                     /*!< SMB2_INST CONTROL: STA (Bit 2)                              */
#define SMB2_INST_CONTROL_STA_Msk             (0x4UL)                   /*!< SMB2_INST CONTROL: STA (Bitfield-Mask: 0x01)                */
#define SMB2_INST_CONTROL_ENI_Pos             (3UL)                     /*!< SMB2_INST CONTROL: ENI (Bit 3)                              */
#define SMB2_INST_CONTROL_ENI_Msk             (0x8UL)                   /*!< SMB2_INST CONTROL: ENI (Bitfield-Mask: 0x01)                */
#define SMB2_INST_CONTROL_ESO_Pos             (6UL)                     /*!< SMB2_INST CONTROL: ESO (Bit 6)                              */
#define SMB2_INST_CONTROL_ESO_Msk             (0x40UL)                  /*!< SMB2_INST CONTROL: ESO (Bitfield-Mask: 0x01)                */
#define SMB2_INST_CONTROL_PIN_Pos             (7UL)                     /*!< SMB2_INST CONTROL: PIN (Bit 7)                              */
#define SMB2_INST_CONTROL_PIN_Msk             (0x80UL)                  /*!< SMB2_INST CONTROL: PIN (Bitfield-Mask: 0x01)                */

/* --------------------------------  SMB2_INST_OWN  ------------------------------- */
#define SMB2_INST_OWN_OWN_ADDRESS_1_Pos       (0UL)                     /*!< SMB2_INST OWN: OWN_ADDRESS_1 (Bit 0)                        */
#define SMB2_INST_OWN_OWN_ADDRESS_1_Msk       (0x7fUL)                  /*!< SMB2_INST OWN: OWN_ADDRESS_1 (Bitfield-Mask: 0x7f)          */
#define SMB2_INST_OWN_OWN_ADDRESS_2_Pos       (8UL)                     /*!< SMB2_INST OWN: OWN_ADDRESS_2 (Bit 8)                        */
#define SMB2_INST_OWN_OWN_ADDRESS_2_Msk       (0x7f00UL)                /*!< SMB2_INST OWN: OWN_ADDRESS_2 (Bitfield-Mask: 0x7f)          */

/* --------------------------  SMB2_INST_MASTER_COMMAND  -------------------------- */
#define SMB2_INST_MASTER_COMMAND_MRUN_Pos     (0UL)                     /*!< SMB2_INST MASTER_COMMAND: MRUN (Bit 0)                      */
#define SMB2_INST_MASTER_COMMAND_MRUN_Msk     (0x1UL)                   /*!< SMB2_INST MASTER_COMMAND: MRUN (Bitfield-Mask: 0x01)        */
#define SMB2_INST_MASTER_COMMAND_MPROCEED_Pos (1UL)                     /*!< SMB2_INST MASTER_COMMAND: MPROCEED (Bit 1)                  */
#define SMB2_INST_MASTER_COMMAND_MPROCEED_Msk (0x2UL)                   /*!< SMB2_INST MASTER_COMMAND: MPROCEED (Bitfield-Mask: 0x01)    */
#define SMB2_INST_MASTER_COMMAND_START0_Pos   (8UL)                     /*!< SMB2_INST MASTER_COMMAND: START0 (Bit 8)                    */
#define SMB2_INST_MASTER_COMMAND_START0_Msk   (0x100UL)                 /*!< SMB2_INST MASTER_COMMAND: START0 (Bitfield-Mask: 0x01)      */
#define SMB2_INST_MASTER_COMMAND_STARTN_Pos   (9UL)                     /*!< SMB2_INST MASTER_COMMAND: STARTN (Bit 9)                    */
#define SMB2_INST_MASTER_COMMAND_STARTN_Msk   (0x200UL)                 /*!< SMB2_INST MASTER_COMMAND: STARTN (Bitfield-Mask: 0x01)      */
#define SMB2_INST_MASTER_COMMAND_STOP_Pos     (10UL)                    /*!< SMB2_INST MASTER_COMMAND: STOP (Bit 10)                     */
#define SMB2_INST_MASTER_COMMAND_STOP_Msk     (0x400UL)                 /*!< SMB2_INST MASTER_COMMAND: STOP (Bitfield-Mask: 0x01)        */
#define SMB2_INST_MASTER_COMMAND_PEC_TERM_Pos (11UL)                    /*!< SMB2_INST MASTER_COMMAND: PEC_TERM (Bit 11)                 */
#define SMB2_INST_MASTER_COMMAND_PEC_TERM_Msk (0x800UL)                 /*!< SMB2_INST MASTER_COMMAND: PEC_TERM (Bitfield-Mask: 0x01)    */
#define SMB2_INST_MASTER_COMMAND_READM_Pos    (12UL)                    /*!< SMB2_INST MASTER_COMMAND: READM (Bit 12)                    */
#define SMB2_INST_MASTER_COMMAND_READM_Msk    (0x1000UL)                /*!< SMB2_INST MASTER_COMMAND: READM (Bitfield-Mask: 0x01)       */
#define SMB2_INST_MASTER_COMMAND_READ_PEC_Pos (13UL)                    /*!< SMB2_INST MASTER_COMMAND: READ_PEC (Bit 13)                 */
#define SMB2_INST_MASTER_COMMAND_READ_PEC_Msk (0x2000UL)                /*!< SMB2_INST MASTER_COMMAND: READ_PEC (Bitfield-Mask: 0x01)    */
#define SMB2_INST_MASTER_COMMAND_WRITE_COUNT_Pos (16UL)                 /*!< SMB2_INST MASTER_COMMAND: WRITE_COUNT (Bit 16)              */
#define SMB2_INST_MASTER_COMMAND_WRITE_COUNT_Msk (0xff0000UL)           /*!< SMB2_INST MASTER_COMMAND: WRITE_COUNT (Bitfield-Mask: 0xff) */
#define SMB2_INST_MASTER_COMMAND_READ_COUNT_Pos (24UL)                  /*!< SMB2_INST MASTER_COMMAND: READ_COUNT (Bit 24)               */
#define SMB2_INST_MASTER_COMMAND_READ_COUNT_Msk (0xff000000UL)          /*!< SMB2_INST MASTER_COMMAND: READ_COUNT (Bitfield-Mask: 0xff)  */

/* ---------------------------  SMB2_INST_SLAVE_COMMAND  -------------------------- */
#define SMB2_INST_SLAVE_COMMAND_SRUN_Pos      (0UL)                     /*!< SMB2_INST SLAVE_COMMAND: SRUN (Bit 0)                       */
#define SMB2_INST_SLAVE_COMMAND_SRUN_Msk      (0x1UL)                   /*!< SMB2_INST SLAVE_COMMAND: SRUN (Bitfield-Mask: 0x01)         */
#define SMB2_INST_SLAVE_COMMAND_SPROCEED_Pos  (1UL)                     /*!< SMB2_INST SLAVE_COMMAND: SPROCEED (Bit 1)                   */
#define SMB2_INST_SLAVE_COMMAND_SPROCEED_Msk  (0x2UL)                   /*!< SMB2_INST SLAVE_COMMAND: SPROCEED (Bitfield-Mask: 0x01)     */
#define SMB2_INST_SLAVE_COMMAND_SLAVE_PEC_Pos (2UL)                     /*!< SMB2_INST SLAVE_COMMAND: SLAVE_PEC (Bit 2)                  */
#define SMB2_INST_SLAVE_COMMAND_SLAVE_PEC_Msk (0x4UL)                   /*!< SMB2_INST SLAVE_COMMAND: SLAVE_PEC (Bitfield-Mask: 0x01)    */
#define SMB2_INST_SLAVE_COMMAND_SLAVE_WRITECOUNT_Pos (8UL)              /*!< SMB2_INST SLAVE_COMMAND: SLAVE_WRITECOUNT (Bit 8)           */
#define SMB2_INST_SLAVE_COMMAND_SLAVE_WRITECOUNT_Msk (0xff00UL)         /*!< SMB2_INST SLAVE_COMMAND: SLAVE_WRITECOUNT (Bitfield-Mask: 0xff) */
#define SMB2_INST_SLAVE_COMMAND_SLAVE_READCOUNT_Pos (16UL)              /*!< SMB2_INST SLAVE_COMMAND: SLAVE_READCOUNT (Bit 16)           */
#define SMB2_INST_SLAVE_COMMAND_SLAVE_READCOUNT_Msk (0xff0000UL)        /*!< SMB2_INST SLAVE_COMMAND: SLAVE_READCOUNT (Bitfield-Mask: 0xff) */

/* --------------------------------  SMB2_INST_PEC  ------------------------------- */
#define SMB2_INST_PEC_PEC_Pos                 (0UL)                     /*!< SMB2_INST PEC: PEC (Bit 0)                                  */
#define SMB2_INST_PEC_PEC_Msk                 (0xffUL)                  /*!< SMB2_INST PEC: PEC (Bitfield-Mask: 0xff)                    */

/* ---------------------  SMB2_INST_REPEATED_START_HOLD_TIME  --------------------- */
#define SMB2_INST_REPEATED_START_HOLD_TIME_RPT_START_HOLD_TIME_Pos (0UL) /*!< SMB2_INST REPEATED_START_HOLD_TIME: RPT_START_HOLD_TIME (Bit 0) */
#define SMB2_INST_REPEATED_START_HOLD_TIME_RPT_START_HOLD_TIME_Msk (0xffUL) /*!< SMB2_INST REPEATED_START_HOLD_TIME: RPT_START_HOLD_TIME (Bitfield-Mask: 0xff) */

/* ----------------------------  SMB2_INST_COMPLETION  ---------------------------- */
#define SMB2_INST_COMPLETION_DTEN_Pos         (2UL)                     /*!< SMB2_INST COMPLETION: DTEN (Bit 2)                          */
#define SMB2_INST_COMPLETION_DTEN_Msk         (0x4UL)                   /*!< SMB2_INST COMPLETION: DTEN (Bitfield-Mask: 0x01)            */
#define SMB2_INST_COMPLETION_MCEN_Pos         (3UL)                     /*!< SMB2_INST COMPLETION: MCEN (Bit 3)                          */
#define SMB2_INST_COMPLETION_MCEN_Msk         (0x8UL)                   /*!< SMB2_INST COMPLETION: MCEN (Bitfield-Mask: 0x01)            */
#define SMB2_INST_COMPLETION_SCEN_Pos         (4UL)                     /*!< SMB2_INST COMPLETION: SCEN (Bit 4)                          */
#define SMB2_INST_COMPLETION_SCEN_Msk         (0x10UL)                  /*!< SMB2_INST COMPLETION: SCEN (Bitfield-Mask: 0x01)            */
#define SMB2_INST_COMPLETION_BIDEN_Pos        (5UL)                     /*!< SMB2_INST COMPLETION: BIDEN (Bit 5)                         */
#define SMB2_INST_COMPLETION_BIDEN_Msk        (0x20UL)                  /*!< SMB2_INST COMPLETION: BIDEN (Bitfield-Mask: 0x01)           */
#define SMB2_INST_COMPLETION_TIMERR_Pos       (6UL)                     /*!< SMB2_INST COMPLETION: TIMERR (Bit 6)                        */
#define SMB2_INST_COMPLETION_TIMERR_Msk       (0x40UL)                  /*!< SMB2_INST COMPLETION: TIMERR (Bitfield-Mask: 0x01)          */
#define SMB2_INST_COMPLETION_DTO_Pos          (8UL)                     /*!< SMB2_INST COMPLETION: DTO (Bit 8)                           */
#define SMB2_INST_COMPLETION_DTO_Msk          (0x100UL)                 /*!< SMB2_INST COMPLETION: DTO (Bitfield-Mask: 0x01)             */
#define SMB2_INST_COMPLETION_MCTO_Pos         (9UL)                     /*!< SMB2_INST COMPLETION: MCTO (Bit 9)                          */
#define SMB2_INST_COMPLETION_MCTO_Msk         (0x200UL)                 /*!< SMB2_INST COMPLETION: MCTO (Bitfield-Mask: 0x01)            */
#define SMB2_INST_COMPLETION_SCTO_Pos         (10UL)                    /*!< SMB2_INST COMPLETION: SCTO (Bit 10)                         */
#define SMB2_INST_COMPLETION_SCTO_Msk         (0x400UL)                 /*!< SMB2_INST COMPLETION: SCTO (Bitfield-Mask: 0x01)            */
#define SMB2_INST_COMPLETION_CHDL_Pos         (11UL)                    /*!< SMB2_INST COMPLETION: CHDL (Bit 11)                         */
#define SMB2_INST_COMPLETION_CHDL_Msk         (0x800UL)                 /*!< SMB2_INST COMPLETION: CHDL (Bitfield-Mask: 0x01)            */
#define SMB2_INST_COMPLETION_CHDH_Pos         (12UL)                    /*!< SMB2_INST COMPLETION: CHDH (Bit 12)                         */
#define SMB2_INST_COMPLETION_CHDH_Msk         (0x1000UL)                /*!< SMB2_INST COMPLETION: CHDH (Bitfield-Mask: 0x01)            */
#define SMB2_INST_COMPLETION_BER_Pos          (13UL)                    /*!< SMB2_INST COMPLETION: BER (Bit 13)                          */
#define SMB2_INST_COMPLETION_BER_Msk          (0x2000UL)                /*!< SMB2_INST COMPLETION: BER (Bitfield-Mask: 0x01)             */
#define SMB2_INST_COMPLETION_LAB_Pos          (14UL)                    /*!< SMB2_INST COMPLETION: LAB (Bit 14)                          */
#define SMB2_INST_COMPLETION_LAB_Msk          (0x4000UL)                /*!< SMB2_INST COMPLETION: LAB (Bitfield-Mask: 0x01)             */
#define SMB2_INST_COMPLETION_SNAKR_Pos        (16UL)                    /*!< SMB2_INST COMPLETION: SNAKR (Bit 16)                        */
#define SMB2_INST_COMPLETION_SNAKR_Msk        (0x10000UL)               /*!< SMB2_INST COMPLETION: SNAKR (Bitfield-Mask: 0x01)           */
#define SMB2_INST_COMPLETION_STR_Pos          (17UL)                    /*!< SMB2_INST COMPLETION: STR (Bit 17)                          */
#define SMB2_INST_COMPLETION_STR_Msk          (0x20000UL)               /*!< SMB2_INST COMPLETION: STR (Bitfield-Mask: 0x01)             */
#define SMB2_INST_COMPLETION_SPROT_Pos        (19UL)                    /*!< SMB2_INST COMPLETION: SPROT (Bit 19)                        */
#define SMB2_INST_COMPLETION_SPROT_Msk        (0x80000UL)               /*!< SMB2_INST COMPLETION: SPROT (Bitfield-Mask: 0x01)           */
#define SMB2_INST_COMPLETION_REPEAT_READ_Pos  (20UL)                    /*!< SMB2_INST COMPLETION: REPEAT_READ (Bit 20)                  */
#define SMB2_INST_COMPLETION_REPEAT_READ_Msk  (0x100000UL)              /*!< SMB2_INST COMPLETION: REPEAT_READ (Bitfield-Mask: 0x01)     */
#define SMB2_INST_COMPLETION_REPEAT_WRITE_Pos (21UL)                    /*!< SMB2_INST COMPLETION: REPEAT_WRITE (Bit 21)                 */
#define SMB2_INST_COMPLETION_REPEAT_WRITE_Msk (0x200000UL)              /*!< SMB2_INST COMPLETION: REPEAT_WRITE (Bitfield-Mask: 0x01)    */
#define SMB2_INST_COMPLETION_MNAKX_Pos        (24UL)                    /*!< SMB2_INST COMPLETION: MNAKX (Bit 24)                        */
#define SMB2_INST_COMPLETION_MNAKX_Msk        (0x1000000UL)             /*!< SMB2_INST COMPLETION: MNAKX (Bitfield-Mask: 0x01)           */
#define SMB2_INST_COMPLETION_MTR_Pos          (25UL)                    /*!< SMB2_INST COMPLETION: MTR (Bit 25)                          */
#define SMB2_INST_COMPLETION_MTR_Msk          (0x2000000UL)             /*!< SMB2_INST COMPLETION: MTR (Bitfield-Mask: 0x01)             */
#define SMB2_INST_COMPLETION_IDLE_Pos         (29UL)                    /*!< SMB2_INST COMPLETION: IDLE (Bit 29)                         */
#define SMB2_INST_COMPLETION_IDLE_Msk         (0x20000000UL)            /*!< SMB2_INST COMPLETION: IDLE (Bitfield-Mask: 0x01)            */
#define SMB2_INST_COMPLETION_MDONE_Pos        (30UL)                    /*!< SMB2_INST COMPLETION: MDONE (Bit 30)                        */
#define SMB2_INST_COMPLETION_MDONE_Msk        (0x40000000UL)            /*!< SMB2_INST COMPLETION: MDONE (Bitfield-Mask: 0x01)           */
#define SMB2_INST_COMPLETION_SDONE_Pos        (31UL)                    /*!< SMB2_INST COMPLETION: SDONE (Bit 31)                        */
#define SMB2_INST_COMPLETION_SDONE_Msk        (0x80000000UL)            /*!< SMB2_INST COMPLETION: SDONE (Bitfield-Mask: 0x01)           */

/* ---------------------------  SMB2_INST_IDLE_SCALING  --------------------------- */
#define SMB2_INST_IDLE_SCALING_FAIR_BUS_IDLE_MIN_Pos (0UL)              /*!< SMB2_INST IDLE_SCALING: FAIR_BUS_IDLE_MIN (Bit 0)           */
#define SMB2_INST_IDLE_SCALING_FAIR_BUS_IDLE_MIN_Msk (0xfffUL)          /*!< SMB2_INST IDLE_SCALING: FAIR_BUS_IDLE_MIN (Bitfield-Mask: 0xfff) */
#define SMB2_INST_IDLE_SCALING_FAIR_IDLE_DELAY_Pos (16UL)               /*!< SMB2_INST IDLE_SCALING: FAIR_IDLE_DELAY (Bit 16)            */
#define SMB2_INST_IDLE_SCALING_FAIR_IDLE_DELAY_Msk (0xfff0000UL)        /*!< SMB2_INST IDLE_SCALING: FAIR_IDLE_DELAY (Bitfield-Mask: 0xfff) */

/* ---------------------------  SMB2_INST_CONFIGURATION  -------------------------- */
#define SMB2_INST_CONFIGURATION_PORT_SEL_Pos  (0UL)                     /*!< SMB2_INST CONFIGURATION: PORT_SEL (Bit 0)                   */
#define SMB2_INST_CONFIGURATION_PORT_SEL_Msk  (0xfUL)                   /*!< SMB2_INST CONFIGURATION: PORT_SEL (Bitfield-Mask: 0x0f)     */
#define SMB2_INST_CONFIGURATION_TCEN_Pos      (4UL)                     /*!< SMB2_INST CONFIGURATION: TCEN (Bit 4)                       */
#define SMB2_INST_CONFIGURATION_TCEN_Msk      (0x10UL)                  /*!< SMB2_INST CONFIGURATION: TCEN (Bitfield-Mask: 0x01)         */
#define SMB2_INST_CONFIGURATION_SLOW_CLOCK_Pos (5UL)                    /*!< SMB2_INST CONFIGURATION: SLOW_CLOCK (Bit 5)                 */
#define SMB2_INST_CONFIGURATION_SLOW_CLOCK_Msk (0x20UL)                 /*!< SMB2_INST CONFIGURATION: SLOW_CLOCK (Bitfield-Mask: 0x01)   */
#define SMB2_INST_CONFIGURATION_TEST_Pos      (6UL)                     /*!< SMB2_INST CONFIGURATION: TEST (Bit 6)                       */
#define SMB2_INST_CONFIGURATION_TEST_Msk      (0x40UL)                  /*!< SMB2_INST CONFIGURATION: TEST (Bitfield-Mask: 0x01)         */
#define SMB2_INST_CONFIGURATION_PECEN_Pos     (7UL)                     /*!< SMB2_INST CONFIGURATION: PECEN (Bit 7)                      */
#define SMB2_INST_CONFIGURATION_PECEN_Msk     (0x80UL)                  /*!< SMB2_INST CONFIGURATION: PECEN (Bitfield-Mask: 0x01)        */
#define SMB2_INST_CONFIGURATION_FEN_Pos       (8UL)                     /*!< SMB2_INST CONFIGURATION: FEN (Bit 8)                        */
#define SMB2_INST_CONFIGURATION_FEN_Msk       (0x100UL)                 /*!< SMB2_INST CONFIGURATION: FEN (Bitfield-Mask: 0x01)          */
#define SMB2_INST_CONFIGURATION_RESET_Pos     (9UL)                     /*!< SMB2_INST CONFIGURATION: RESET (Bit 9)                      */
#define SMB2_INST_CONFIGURATION_RESET_Msk     (0x200UL)                 /*!< SMB2_INST CONFIGURATION: RESET (Bitfield-Mask: 0x01)        */
#define SMB2_INST_CONFIGURATION_ENAB_Pos      (10UL)                    /*!< SMB2_INST CONFIGURATION: ENAB (Bit 10)                      */
#define SMB2_INST_CONFIGURATION_ENAB_Msk      (0x400UL)                 /*!< SMB2_INST CONFIGURATION: ENAB (Bitfield-Mask: 0x01)         */
#define SMB2_INST_CONFIGURATION_DSA_Pos       (11UL)                    /*!< SMB2_INST CONFIGURATION: DSA (Bit 11)                       */
#define SMB2_INST_CONFIGURATION_DSA_Msk       (0x800UL)                 /*!< SMB2_INST CONFIGURATION: DSA (Bitfield-Mask: 0x01)          */
#define SMB2_INST_CONFIGURATION_FAIR_Pos      (12UL)                    /*!< SMB2_INST CONFIGURATION: FAIR (Bit 12)                      */
#define SMB2_INST_CONFIGURATION_FAIR_Msk      (0x1000UL)                /*!< SMB2_INST CONFIGURATION: FAIR (Bitfield-Mask: 0x01)         */
#define SMB2_INST_CONFIGURATION_TEST0_Pos     (13UL)                    /*!< SMB2_INST CONFIGURATION: TEST0 (Bit 13)                     */
#define SMB2_INST_CONFIGURATION_TEST0_Msk     (0x2000UL)                /*!< SMB2_INST CONFIGURATION: TEST0 (Bitfield-Mask: 0x01)        */
#define SMB2_INST_CONFIGURATION_GC_DIS_Pos    (14UL)                    /*!< SMB2_INST CONFIGURATION: GC_DIS (Bit 14)                    */
#define SMB2_INST_CONFIGURATION_GC_DIS_Msk    (0x4000UL)                /*!< SMB2_INST CONFIGURATION: GC_DIS (Bitfield-Mask: 0x01)       */
#define SMB2_INST_CONFIGURATION_FLUSH_SXBUF_Pos (16UL)                  /*!< SMB2_INST CONFIGURATION: FLUSH_SXBUF (Bit 16)               */
#define SMB2_INST_CONFIGURATION_FLUSH_SXBUF_Msk (0x10000UL)             /*!< SMB2_INST CONFIGURATION: FLUSH_SXBUF (Bitfield-Mask: 0x01)  */
#define SMB2_INST_CONFIGURATION_FLUSH_SRBUF_Pos (17UL)                  /*!< SMB2_INST CONFIGURATION: FLUSH_SRBUF (Bit 17)               */
#define SMB2_INST_CONFIGURATION_FLUSH_SRBUF_Msk (0x20000UL)             /*!< SMB2_INST CONFIGURATION: FLUSH_SRBUF (Bitfield-Mask: 0x01)  */
#define SMB2_INST_CONFIGURATION_FLUSH_MXBUF_Pos (18UL)                  /*!< SMB2_INST CONFIGURATION: FLUSH_MXBUF (Bit 18)               */
#define SMB2_INST_CONFIGURATION_FLUSH_MXBUF_Msk (0x40000UL)             /*!< SMB2_INST CONFIGURATION: FLUSH_MXBUF (Bitfield-Mask: 0x01)  */
#define SMB2_INST_CONFIGURATION_FLUSH_MRBUF_Pos (19UL)                  /*!< SMB2_INST CONFIGURATION: FLUSH_MRBUF (Bit 19)               */
#define SMB2_INST_CONFIGURATION_FLUSH_MRBUF_Msk (0x80000UL)             /*!< SMB2_INST CONFIGURATION: FLUSH_MRBUF (Bitfield-Mask: 0x01)  */
#define SMB2_INST_CONFIGURATION_EN_AAS_Pos    (28UL)                    /*!< SMB2_INST CONFIGURATION: EN_AAS (Bit 28)                    */
#define SMB2_INST_CONFIGURATION_EN_AAS_Msk    (0x10000000UL)            /*!< SMB2_INST CONFIGURATION: EN_AAS (Bitfield-Mask: 0x01)       */
#define SMB2_INST_CONFIGURATION_ENIDI_Pos     (29UL)                    /*!< SMB2_INST CONFIGURATION: ENIDI (Bit 29)                     */
#define SMB2_INST_CONFIGURATION_ENIDI_Msk     (0x20000000UL)            /*!< SMB2_INST CONFIGURATION: ENIDI (Bitfield-Mask: 0x01)        */
#define SMB2_INST_CONFIGURATION_ENMI_Pos      (30UL)                    /*!< SMB2_INST CONFIGURATION: ENMI (Bit 30)                      */
#define SMB2_INST_CONFIGURATION_ENMI_Msk      (0x40000000UL)            /*!< SMB2_INST CONFIGURATION: ENMI (Bitfield-Mask: 0x01)         */
#define SMB2_INST_CONFIGURATION_ENSI_Pos      (31UL)                    /*!< SMB2_INST CONFIGURATION: ENSI (Bit 31)                      */
#define SMB2_INST_CONFIGURATION_ENSI_Msk      (0x80000000UL)            /*!< SMB2_INST CONFIGURATION: ENSI (Bitfield-Mask: 0x01)         */

/* -----------------------------  SMB2_INST_BUS_CLOCK  ---------------------------- */
#define SMB2_INST_BUS_CLOCK_LOW_PERIOD_Pos    (0UL)                     /*!< SMB2_INST BUS_CLOCK: LOW_PERIOD (Bit 0)                     */
#define SMB2_INST_BUS_CLOCK_LOW_PERIOD_Msk    (0xffUL)                  /*!< SMB2_INST BUS_CLOCK: LOW_PERIOD (Bitfield-Mask: 0xff)       */
#define SMB2_INST_BUS_CLOCK_HIGH_PERIOD_Pos   (8UL)                     /*!< SMB2_INST BUS_CLOCK: HIGH_PERIOD (Bit 8)                    */
#define SMB2_INST_BUS_CLOCK_HIGH_PERIOD_Msk   (0xff00UL)                /*!< SMB2_INST BUS_CLOCK: HIGH_PERIOD (Bitfield-Mask: 0xff)      */

/* -----------------------------  SMB2_INST_BLOCK_ID  ----------------------------- */
#define SMB2_INST_BLOCK_ID_ID_Pos             (0UL)                     /*!< SMB2_INST BLOCK_ID: ID (Bit 0)                              */
#define SMB2_INST_BLOCK_ID_ID_Msk             (0xffUL)                  /*!< SMB2_INST BLOCK_ID: ID (Bitfield-Mask: 0xff)                */

/* -----------------------------  SMB2_INST_REVISION  ----------------------------- */
#define SMB2_INST_REVISION_REVISION_Pos       (0UL)                     /*!< SMB2_INST REVISION: REVISION (Bit 0)                        */
#define SMB2_INST_REVISION_REVISION_Msk       (0xffUL)                  /*!< SMB2_INST REVISION: REVISION (Bitfield-Mask: 0xff)          */

/* -------------------------  SMB2_INST_BIT_BANG_CONTROL  ------------------------- */
#define SMB2_INST_BIT_BANG_CONTROL_BBEN_Pos   (0UL)                     /*!< SMB2_INST BIT_BANG_CONTROL: BBEN (Bit 0)                    */
#define SMB2_INST_BIT_BANG_CONTROL_BBEN_Msk   (0x1UL)                   /*!< SMB2_INST BIT_BANG_CONTROL: BBEN (Bitfield-Mask: 0x01)      */
#define SMB2_INST_BIT_BANG_CONTROL_CLDIR_Pos  (1UL)                     /*!< SMB2_INST BIT_BANG_CONTROL: CLDIR (Bit 1)                   */
#define SMB2_INST_BIT_BANG_CONTROL_CLDIR_Msk  (0x2UL)                   /*!< SMB2_INST BIT_BANG_CONTROL: CLDIR (Bitfield-Mask: 0x01)     */
#define SMB2_INST_BIT_BANG_CONTROL_DADIR_Pos  (2UL)                     /*!< SMB2_INST BIT_BANG_CONTROL: DADIR (Bit 2)                   */
#define SMB2_INST_BIT_BANG_CONTROL_DADIR_Msk  (0x4UL)                   /*!< SMB2_INST BIT_BANG_CONTROL: DADIR (Bitfield-Mask: 0x01)     */
#define SMB2_INST_BIT_BANG_CONTROL_BBCLK_Pos  (3UL)                     /*!< SMB2_INST BIT_BANG_CONTROL: BBCLK (Bit 3)                   */
#define SMB2_INST_BIT_BANG_CONTROL_BBCLK_Msk  (0x8UL)                   /*!< SMB2_INST BIT_BANG_CONTROL: BBCLK (Bitfield-Mask: 0x01)     */
#define SMB2_INST_BIT_BANG_CONTROL_BBDAT_Pos  (4UL)                     /*!< SMB2_INST BIT_BANG_CONTROL: BBDAT (Bit 4)                   */
#define SMB2_INST_BIT_BANG_CONTROL_BBDAT_Msk  (0x10UL)                  /*!< SMB2_INST BIT_BANG_CONTROL: BBDAT (Bitfield-Mask: 0x01)     */
#define SMB2_INST_BIT_BANG_CONTROL_BBCLKI_Pos (5UL)                     /*!< SMB2_INST BIT_BANG_CONTROL: BBCLKI (Bit 5)                  */
#define SMB2_INST_BIT_BANG_CONTROL_BBCLKI_Msk (0x20UL)                  /*!< SMB2_INST BIT_BANG_CONTROL: BBCLKI (Bitfield-Mask: 0x01)    */
#define SMB2_INST_BIT_BANG_CONTROL_BBDATI_Pos (6UL)                     /*!< SMB2_INST BIT_BANG_CONTROL: BBDATI (Bit 6)                  */
#define SMB2_INST_BIT_BANG_CONTROL_BBDATI_Msk (0x40UL)                  /*!< SMB2_INST BIT_BANG_CONTROL: BBDATI (Bitfield-Mask: 0x01)    */

/* -------------------------------  SMB2_INST_TEST  ------------------------------- */
#define SMB2_INST_TEST_TEST_Pos               (0UL)                     /*!< SMB2_INST TEST: TEST (Bit 0)                                */
#define SMB2_INST_TEST_TEST_Msk               (0xffUL)                  /*!< SMB2_INST TEST: TEST (Bitfield-Mask: 0xff)                  */

/* ----------------------------  SMB2_INST_DATA_TIMING  --------------------------- */
#define SMB2_INST_DATA_TIMING_DATA_HOLD_Pos   (0UL)                     /*!< SMB2_INST DATA_TIMING: DATA_HOLD (Bit 0)                    */
#define SMB2_INST_DATA_TIMING_DATA_HOLD_Msk   (0xffUL)                  /*!< SMB2_INST DATA_TIMING: DATA_HOLD (Bitfield-Mask: 0xff)      */
#define SMB2_INST_DATA_TIMING_RESTART_SETUP_Pos (8UL)                   /*!< SMB2_INST DATA_TIMING: RESTART_SETUP (Bit 8)                */
#define SMB2_INST_DATA_TIMING_RESTART_SETUP_Msk (0xff00UL)              /*!< SMB2_INST DATA_TIMING: RESTART_SETUP (Bitfield-Mask: 0xff)  */
#define SMB2_INST_DATA_TIMING_STOP_SETUP_Pos  (16UL)                    /*!< SMB2_INST DATA_TIMING: STOP_SETUP (Bit 16)                  */
#define SMB2_INST_DATA_TIMING_STOP_SETUP_Msk  (0xff0000UL)              /*!< SMB2_INST DATA_TIMING: STOP_SETUP (Bitfield-Mask: 0xff)     */
#define SMB2_INST_DATA_TIMING_FIRST_START_HOLD_Pos (24UL)               /*!< SMB2_INST DATA_TIMING: FIRST_START_HOLD (Bit 24)            */
#define SMB2_INST_DATA_TIMING_FIRST_START_HOLD_Msk (0xff000000UL)       /*!< SMB2_INST DATA_TIMING: FIRST_START_HOLD (Bitfield-Mask: 0xff) */

/* -------------------------  SMB2_INST_TIME_OUT_SCALING  ------------------------- */
#define SMB2_INST_TIME_OUT_SCALING_CLOCK_HIGH_TIME_OUT_Pos (0UL)        /*!< SMB2_INST TIME_OUT_SCALING: CLOCK_HIGH_TIME_OUT (Bit 0)     */
#define SMB2_INST_TIME_OUT_SCALING_CLOCK_HIGH_TIME_OUT_Msk (0xffUL)     /*!< SMB2_INST TIME_OUT_SCALING: CLOCK_HIGH_TIME_OUT (Bitfield-Mask: 0xff) */
#define SMB2_INST_TIME_OUT_SCALING_SLAVE_CUM_TIME_OUT_Pos (8UL)         /*!< SMB2_INST TIME_OUT_SCALING: SLAVE_CUM_TIME_OUT (Bit 8)      */
#define SMB2_INST_TIME_OUT_SCALING_SLAVE_CUM_TIME_OUT_Msk (0xff00UL)    /*!< SMB2_INST TIME_OUT_SCALING: SLAVE_CUM_TIME_OUT (Bitfield-Mask: 0xff) */
#define SMB2_INST_TIME_OUT_SCALING_MASTER_CUM_TIME_OUT_Pos (16UL)       /*!< SMB2_INST TIME_OUT_SCALING: MASTER_CUM_TIME_OUT (Bit 16)    */
#define SMB2_INST_TIME_OUT_SCALING_MASTER_CUM_TIME_OUT_Msk (0xff0000UL) /*!< SMB2_INST TIME_OUT_SCALING: MASTER_CUM_TIME_OUT (Bitfield-Mask: 0xff) */
#define SMB2_INST_TIME_OUT_SCALING_BUS_IDLE_MIN_Pos (24UL)              /*!< SMB2_INST TIME_OUT_SCALING: BUS_IDLE_MIN (Bit 24)           */
#define SMB2_INST_TIME_OUT_SCALING_BUS_IDLE_MIN_Msk (0xff000000UL)      /*!< SMB2_INST TIME_OUT_SCALING: BUS_IDLE_MIN (Bitfield-Mask: 0xff) */

/* -----------------------  SMB2_INST_SLAVE_TRANSMIT_BUFFER  ---------------------- */
#define SMB2_INST_SLAVE_TRANSMIT_BUFFER_SLAVE_TRANSMIT_BUFFER_Pos (0UL) /*!< SMB2_INST SLAVE_TRANSMIT_BUFFER: SLAVE_TRANSMIT_BUFFER (Bit 0) */
#define SMB2_INST_SLAVE_TRANSMIT_BUFFER_SLAVE_TRANSMIT_BUFFER_Msk (0xffUL) /*!< SMB2_INST SLAVE_TRANSMIT_BUFFER: SLAVE_TRANSMIT_BUFFER (Bitfield-Mask: 0xff) */

/* -----------------------  SMB2_INST_SLAVE_RECEIVE_BUFFER  ----------------------- */
#define SMB2_INST_SLAVE_RECEIVE_BUFFER_SLAVE_RECEIVE_BUFFER_Pos (0UL)   /*!< SMB2_INST SLAVE_RECEIVE_BUFFER: SLAVE_RECEIVE_BUFFER (Bit 0) */
#define SMB2_INST_SLAVE_RECEIVE_BUFFER_SLAVE_RECEIVE_BUFFER_Msk (0xffUL) /*!< SMB2_INST SLAVE_RECEIVE_BUFFER: SLAVE_RECEIVE_BUFFER (Bitfield-Mask: 0xff) */

/* -----------------------  SMB2_INST_MASTER_TRANSMIT_BUFER  ---------------------- */
#define SMB2_INST_MASTER_TRANSMIT_BUFER_MASTER_TRANSMIT_BUFFER_Pos (0UL) /*!< SMB2_INST MASTER_TRANSMIT_BUFER: MASTER_TRANSMIT_BUFFER (Bit 0) */
#define SMB2_INST_MASTER_TRANSMIT_BUFER_MASTER_TRANSMIT_BUFFER_Msk (0xffUL) /*!< SMB2_INST MASTER_TRANSMIT_BUFER: MASTER_TRANSMIT_BUFFER (Bitfield-Mask: 0xff) */

/* -----------------------  SMB2_INST_MASTER_RECEIVE_BUFFER  ---------------------- */
#define SMB2_INST_MASTER_RECEIVE_BUFFER_MASTER_RECEIVE_BUFFER_Pos (0UL) /*!< SMB2_INST MASTER_RECEIVE_BUFFER: MASTER_RECEIVE_BUFFER (Bit 0) */
#define SMB2_INST_MASTER_RECEIVE_BUFFER_MASTER_RECEIVE_BUFFER_Msk (0xffUL) /*!< SMB2_INST MASTER_RECEIVE_BUFFER: MASTER_RECEIVE_BUFFER (Bitfield-Mask: 0xff) */

/* ----------------------------  SMB2_INST_WAKE_STATUS  --------------------------- */
#define SMB2_INST_WAKE_STATUS_START_BIT_DETECTION_Pos (0UL)             /*!< SMB2_INST WAKE_STATUS: START_BIT_DETECTION (Bit 0)          */
#define SMB2_INST_WAKE_STATUS_START_BIT_DETECTION_Msk (0x1UL)           /*!< SMB2_INST WAKE_STATUS: START_BIT_DETECTION (Bitfield-Mask: 0x01) */

/* ----------------------------  SMB2_INST_WAKE_ENABLE  --------------------------- */
#define SMB2_INST_WAKE_ENABLE_START_DETECT_INT_EN_Pos (0UL)             /*!< SMB2_INST WAKE_ENABLE: START_DETECT_INT_EN (Bit 0)          */
#define SMB2_INST_WAKE_ENABLE_START_DETECT_INT_EN_Msk (0x1UL)           /*!< SMB2_INST WAKE_ENABLE: START_DETECT_INT_EN (Bitfield-Mask: 0x01) */


/* ================================================================================ */
/* ================       struct 'SMB3_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ------------------------------  SMB3_INST_STATUS  ------------------------------ */
#define SMB3_INST_STATUS_NBB_Pos              (0UL)                     /*!< SMB3_INST STATUS: NBB (Bit 0)                               */
#define SMB3_INST_STATUS_NBB_Msk              (0x1UL)                   /*!< SMB3_INST STATUS: NBB (Bitfield-Mask: 0x01)                 */
#define SMB3_INST_STATUS_LAB_Pos              (1UL)                     /*!< SMB3_INST STATUS: LAB (Bit 1)                               */
#define SMB3_INST_STATUS_LAB_Msk              (0x2UL)                   /*!< SMB3_INST STATUS: LAB (Bitfield-Mask: 0x01)                 */
#define SMB3_INST_STATUS_AAS_Pos              (2UL)                     /*!< SMB3_INST STATUS: AAS (Bit 2)                               */
#define SMB3_INST_STATUS_AAS_Msk              (0x4UL)                   /*!< SMB3_INST STATUS: AAS (Bitfield-Mask: 0x01)                 */
#define SMB3_INST_STATUS_LRB_AD0_Pos          (3UL)                     /*!< SMB3_INST STATUS: LRB_AD0 (Bit 3)                           */
#define SMB3_INST_STATUS_LRB_AD0_Msk          (0x8UL)                   /*!< SMB3_INST STATUS: LRB_AD0 (Bitfield-Mask: 0x01)             */
#define SMB3_INST_STATUS_BER_Pos              (4UL)                     /*!< SMB3_INST STATUS: BER (Bit 4)                               */
#define SMB3_INST_STATUS_BER_Msk              (0x10UL)                  /*!< SMB3_INST STATUS: BER (Bitfield-Mask: 0x01)                 */
#define SMB3_INST_STATUS_STS_Pos              (5UL)                     /*!< SMB3_INST STATUS: STS (Bit 5)                               */
#define SMB3_INST_STATUS_STS_Msk              (0x20UL)                  /*!< SMB3_INST STATUS: STS (Bitfield-Mask: 0x01)                 */
#define SMB3_INST_STATUS_SAD_Pos              (6UL)                     /*!< SMB3_INST STATUS: SAD (Bit 6)                               */
#define SMB3_INST_STATUS_SAD_Msk              (0x40UL)                  /*!< SMB3_INST STATUS: SAD (Bitfield-Mask: 0x01)                 */
#define SMB3_INST_STATUS_PIN_Pos              (7UL)                     /*!< SMB3_INST STATUS: PIN (Bit 7)                               */
#define SMB3_INST_STATUS_PIN_Msk              (0x80UL)                  /*!< SMB3_INST STATUS: PIN (Bitfield-Mask: 0x01)                 */

/* ------------------------------  SMB3_INST_CONTROL  ----------------------------- */
#define SMB3_INST_CONTROL_ACK_Pos             (0UL)                     /*!< SMB3_INST CONTROL: ACK (Bit 0)                              */
#define SMB3_INST_CONTROL_ACK_Msk             (0x1UL)                   /*!< SMB3_INST CONTROL: ACK (Bitfield-Mask: 0x01)                */
#define SMB3_INST_CONTROL_STO_Pos             (1UL)                     /*!< SMB3_INST CONTROL: STO (Bit 1)                              */
#define SMB3_INST_CONTROL_STO_Msk             (0x2UL)                   /*!< SMB3_INST CONTROL: STO (Bitfield-Mask: 0x01)                */
#define SMB3_INST_CONTROL_STA_Pos             (2UL)                     /*!< SMB3_INST CONTROL: STA (Bit 2)                              */
#define SMB3_INST_CONTROL_STA_Msk             (0x4UL)                   /*!< SMB3_INST CONTROL: STA (Bitfield-Mask: 0x01)                */
#define SMB3_INST_CONTROL_ENI_Pos             (3UL)                     /*!< SMB3_INST CONTROL: ENI (Bit 3)                              */
#define SMB3_INST_CONTROL_ENI_Msk             (0x8UL)                   /*!< SMB3_INST CONTROL: ENI (Bitfield-Mask: 0x01)                */
#define SMB3_INST_CONTROL_ESO_Pos             (6UL)                     /*!< SMB3_INST CONTROL: ESO (Bit 6)                              */
#define SMB3_INST_CONTROL_ESO_Msk             (0x40UL)                  /*!< SMB3_INST CONTROL: ESO (Bitfield-Mask: 0x01)                */
#define SMB3_INST_CONTROL_PIN_Pos             (7UL)                     /*!< SMB3_INST CONTROL: PIN (Bit 7)                              */
#define SMB3_INST_CONTROL_PIN_Msk             (0x80UL)                  /*!< SMB3_INST CONTROL: PIN (Bitfield-Mask: 0x01)                */

/* --------------------------------  SMB3_INST_OWN  ------------------------------- */
#define SMB3_INST_OWN_OWN_ADDRESS_1_Pos       (0UL)                     /*!< SMB3_INST OWN: OWN_ADDRESS_1 (Bit 0)                        */
#define SMB3_INST_OWN_OWN_ADDRESS_1_Msk       (0x7fUL)                  /*!< SMB3_INST OWN: OWN_ADDRESS_1 (Bitfield-Mask: 0x7f)          */
#define SMB3_INST_OWN_OWN_ADDRESS_2_Pos       (8UL)                     /*!< SMB3_INST OWN: OWN_ADDRESS_2 (Bit 8)                        */
#define SMB3_INST_OWN_OWN_ADDRESS_2_Msk       (0x7f00UL)                /*!< SMB3_INST OWN: OWN_ADDRESS_2 (Bitfield-Mask: 0x7f)          */

/* --------------------------  SMB3_INST_MASTER_COMMAND  -------------------------- */
#define SMB3_INST_MASTER_COMMAND_MRUN_Pos     (0UL)                     /*!< SMB3_INST MASTER_COMMAND: MRUN (Bit 0)                      */
#define SMB3_INST_MASTER_COMMAND_MRUN_Msk     (0x1UL)                   /*!< SMB3_INST MASTER_COMMAND: MRUN (Bitfield-Mask: 0x01)        */
#define SMB3_INST_MASTER_COMMAND_MPROCEED_Pos (1UL)                     /*!< SMB3_INST MASTER_COMMAND: MPROCEED (Bit 1)                  */
#define SMB3_INST_MASTER_COMMAND_MPROCEED_Msk (0x2UL)                   /*!< SMB3_INST MASTER_COMMAND: MPROCEED (Bitfield-Mask: 0x01)    */
#define SMB3_INST_MASTER_COMMAND_START0_Pos   (8UL)                     /*!< SMB3_INST MASTER_COMMAND: START0 (Bit 8)                    */
#define SMB3_INST_MASTER_COMMAND_START0_Msk   (0x100UL)                 /*!< SMB3_INST MASTER_COMMAND: START0 (Bitfield-Mask: 0x01)      */
#define SMB3_INST_MASTER_COMMAND_STARTN_Pos   (9UL)                     /*!< SMB3_INST MASTER_COMMAND: STARTN (Bit 9)                    */
#define SMB3_INST_MASTER_COMMAND_STARTN_Msk   (0x200UL)                 /*!< SMB3_INST MASTER_COMMAND: STARTN (Bitfield-Mask: 0x01)      */
#define SMB3_INST_MASTER_COMMAND_STOP_Pos     (10UL)                    /*!< SMB3_INST MASTER_COMMAND: STOP (Bit 10)                     */
#define SMB3_INST_MASTER_COMMAND_STOP_Msk     (0x400UL)                 /*!< SMB3_INST MASTER_COMMAND: STOP (Bitfield-Mask: 0x01)        */
#define SMB3_INST_MASTER_COMMAND_PEC_TERM_Pos (11UL)                    /*!< SMB3_INST MASTER_COMMAND: PEC_TERM (Bit 11)                 */
#define SMB3_INST_MASTER_COMMAND_PEC_TERM_Msk (0x800UL)                 /*!< SMB3_INST MASTER_COMMAND: PEC_TERM (Bitfield-Mask: 0x01)    */
#define SMB3_INST_MASTER_COMMAND_READM_Pos    (12UL)                    /*!< SMB3_INST MASTER_COMMAND: READM (Bit 12)                    */
#define SMB3_INST_MASTER_COMMAND_READM_Msk    (0x1000UL)                /*!< SMB3_INST MASTER_COMMAND: READM (Bitfield-Mask: 0x01)       */
#define SMB3_INST_MASTER_COMMAND_READ_PEC_Pos (13UL)                    /*!< SMB3_INST MASTER_COMMAND: READ_PEC (Bit 13)                 */
#define SMB3_INST_MASTER_COMMAND_READ_PEC_Msk (0x2000UL)                /*!< SMB3_INST MASTER_COMMAND: READ_PEC (Bitfield-Mask: 0x01)    */
#define SMB3_INST_MASTER_COMMAND_WRITE_COUNT_Pos (16UL)                 /*!< SMB3_INST MASTER_COMMAND: WRITE_COUNT (Bit 16)              */
#define SMB3_INST_MASTER_COMMAND_WRITE_COUNT_Msk (0xff0000UL)           /*!< SMB3_INST MASTER_COMMAND: WRITE_COUNT (Bitfield-Mask: 0xff) */
#define SMB3_INST_MASTER_COMMAND_READ_COUNT_Pos (24UL)                  /*!< SMB3_INST MASTER_COMMAND: READ_COUNT (Bit 24)               */
#define SMB3_INST_MASTER_COMMAND_READ_COUNT_Msk (0xff000000UL)          /*!< SMB3_INST MASTER_COMMAND: READ_COUNT (Bitfield-Mask: 0xff)  */

/* ---------------------------  SMB3_INST_SLAVE_COMMAND  -------------------------- */
#define SMB3_INST_SLAVE_COMMAND_SRUN_Pos      (0UL)                     /*!< SMB3_INST SLAVE_COMMAND: SRUN (Bit 0)                       */
#define SMB3_INST_SLAVE_COMMAND_SRUN_Msk      (0x1UL)                   /*!< SMB3_INST SLAVE_COMMAND: SRUN (Bitfield-Mask: 0x01)         */
#define SMB3_INST_SLAVE_COMMAND_SPROCEED_Pos  (1UL)                     /*!< SMB3_INST SLAVE_COMMAND: SPROCEED (Bit 1)                   */
#define SMB3_INST_SLAVE_COMMAND_SPROCEED_Msk  (0x2UL)                   /*!< SMB3_INST SLAVE_COMMAND: SPROCEED (Bitfield-Mask: 0x01)     */
#define SMB3_INST_SLAVE_COMMAND_SLAVE_PEC_Pos (2UL)                     /*!< SMB3_INST SLAVE_COMMAND: SLAVE_PEC (Bit 2)                  */
#define SMB3_INST_SLAVE_COMMAND_SLAVE_PEC_Msk (0x4UL)                   /*!< SMB3_INST SLAVE_COMMAND: SLAVE_PEC (Bitfield-Mask: 0x01)    */
#define SMB3_INST_SLAVE_COMMAND_SLAVE_WRITECOUNT_Pos (8UL)              /*!< SMB3_INST SLAVE_COMMAND: SLAVE_WRITECOUNT (Bit 8)           */
#define SMB3_INST_SLAVE_COMMAND_SLAVE_WRITECOUNT_Msk (0xff00UL)         /*!< SMB3_INST SLAVE_COMMAND: SLAVE_WRITECOUNT (Bitfield-Mask: 0xff) */
#define SMB3_INST_SLAVE_COMMAND_SLAVE_READCOUNT_Pos (16UL)              /*!< SMB3_INST SLAVE_COMMAND: SLAVE_READCOUNT (Bit 16)           */
#define SMB3_INST_SLAVE_COMMAND_SLAVE_READCOUNT_Msk (0xff0000UL)        /*!< SMB3_INST SLAVE_COMMAND: SLAVE_READCOUNT (Bitfield-Mask: 0xff) */

/* --------------------------------  SMB3_INST_PEC  ------------------------------- */
#define SMB3_INST_PEC_PEC_Pos                 (0UL)                     /*!< SMB3_INST PEC: PEC (Bit 0)                                  */
#define SMB3_INST_PEC_PEC_Msk                 (0xffUL)                  /*!< SMB3_INST PEC: PEC (Bitfield-Mask: 0xff)                    */

/* ---------------------  SMB3_INST_REPEATED_START_HOLD_TIME  --------------------- */
#define SMB3_INST_REPEATED_START_HOLD_TIME_RPT_START_HOLD_TIME_Pos (0UL) /*!< SMB3_INST REPEATED_START_HOLD_TIME: RPT_START_HOLD_TIME (Bit 0) */
#define SMB3_INST_REPEATED_START_HOLD_TIME_RPT_START_HOLD_TIME_Msk (0xffUL) /*!< SMB3_INST REPEATED_START_HOLD_TIME: RPT_START_HOLD_TIME (Bitfield-Mask: 0xff) */

/* ----------------------------  SMB3_INST_COMPLETION  ---------------------------- */
#define SMB3_INST_COMPLETION_DTEN_Pos         (2UL)                     /*!< SMB3_INST COMPLETION: DTEN (Bit 2)                          */
#define SMB3_INST_COMPLETION_DTEN_Msk         (0x4UL)                   /*!< SMB3_INST COMPLETION: DTEN (Bitfield-Mask: 0x01)            */
#define SMB3_INST_COMPLETION_MCEN_Pos         (3UL)                     /*!< SMB3_INST COMPLETION: MCEN (Bit 3)                          */
#define SMB3_INST_COMPLETION_MCEN_Msk         (0x8UL)                   /*!< SMB3_INST COMPLETION: MCEN (Bitfield-Mask: 0x01)            */
#define SMB3_INST_COMPLETION_SCEN_Pos         (4UL)                     /*!< SMB3_INST COMPLETION: SCEN (Bit 4)                          */
#define SMB3_INST_COMPLETION_SCEN_Msk         (0x10UL)                  /*!< SMB3_INST COMPLETION: SCEN (Bitfield-Mask: 0x01)            */
#define SMB3_INST_COMPLETION_BIDEN_Pos        (5UL)                     /*!< SMB3_INST COMPLETION: BIDEN (Bit 5)                         */
#define SMB3_INST_COMPLETION_BIDEN_Msk        (0x20UL)                  /*!< SMB3_INST COMPLETION: BIDEN (Bitfield-Mask: 0x01)           */
#define SMB3_INST_COMPLETION_TIMERR_Pos       (6UL)                     /*!< SMB3_INST COMPLETION: TIMERR (Bit 6)                        */
#define SMB3_INST_COMPLETION_TIMERR_Msk       (0x40UL)                  /*!< SMB3_INST COMPLETION: TIMERR (Bitfield-Mask: 0x01)          */
#define SMB3_INST_COMPLETION_DTO_Pos          (8UL)                     /*!< SMB3_INST COMPLETION: DTO (Bit 8)                           */
#define SMB3_INST_COMPLETION_DTO_Msk          (0x100UL)                 /*!< SMB3_INST COMPLETION: DTO (Bitfield-Mask: 0x01)             */
#define SMB3_INST_COMPLETION_MCTO_Pos         (9UL)                     /*!< SMB3_INST COMPLETION: MCTO (Bit 9)                          */
#define SMB3_INST_COMPLETION_MCTO_Msk         (0x200UL)                 /*!< SMB3_INST COMPLETION: MCTO (Bitfield-Mask: 0x01)            */
#define SMB3_INST_COMPLETION_SCTO_Pos         (10UL)                    /*!< SMB3_INST COMPLETION: SCTO (Bit 10)                         */
#define SMB3_INST_COMPLETION_SCTO_Msk         (0x400UL)                 /*!< SMB3_INST COMPLETION: SCTO (Bitfield-Mask: 0x01)            */
#define SMB3_INST_COMPLETION_CHDL_Pos         (11UL)                    /*!< SMB3_INST COMPLETION: CHDL (Bit 11)                         */
#define SMB3_INST_COMPLETION_CHDL_Msk         (0x800UL)                 /*!< SMB3_INST COMPLETION: CHDL (Bitfield-Mask: 0x01)            */
#define SMB3_INST_COMPLETION_CHDH_Pos         (12UL)                    /*!< SMB3_INST COMPLETION: CHDH (Bit 12)                         */
#define SMB3_INST_COMPLETION_CHDH_Msk         (0x1000UL)                /*!< SMB3_INST COMPLETION: CHDH (Bitfield-Mask: 0x01)            */
#define SMB3_INST_COMPLETION_BER_Pos          (13UL)                    /*!< SMB3_INST COMPLETION: BER (Bit 13)                          */
#define SMB3_INST_COMPLETION_BER_Msk          (0x2000UL)                /*!< SMB3_INST COMPLETION: BER (Bitfield-Mask: 0x01)             */
#define SMB3_INST_COMPLETION_LAB_Pos          (14UL)                    /*!< SMB3_INST COMPLETION: LAB (Bit 14)                          */
#define SMB3_INST_COMPLETION_LAB_Msk          (0x4000UL)                /*!< SMB3_INST COMPLETION: LAB (Bitfield-Mask: 0x01)             */
#define SMB3_INST_COMPLETION_SNAKR_Pos        (16UL)                    /*!< SMB3_INST COMPLETION: SNAKR (Bit 16)                        */
#define SMB3_INST_COMPLETION_SNAKR_Msk        (0x10000UL)               /*!< SMB3_INST COMPLETION: SNAKR (Bitfield-Mask: 0x01)           */
#define SMB3_INST_COMPLETION_STR_Pos          (17UL)                    /*!< SMB3_INST COMPLETION: STR (Bit 17)                          */
#define SMB3_INST_COMPLETION_STR_Msk          (0x20000UL)               /*!< SMB3_INST COMPLETION: STR (Bitfield-Mask: 0x01)             */
#define SMB3_INST_COMPLETION_SPROT_Pos        (19UL)                    /*!< SMB3_INST COMPLETION: SPROT (Bit 19)                        */
#define SMB3_INST_COMPLETION_SPROT_Msk        (0x80000UL)               /*!< SMB3_INST COMPLETION: SPROT (Bitfield-Mask: 0x01)           */
#define SMB3_INST_COMPLETION_REPEAT_READ_Pos  (20UL)                    /*!< SMB3_INST COMPLETION: REPEAT_READ (Bit 20)                  */
#define SMB3_INST_COMPLETION_REPEAT_READ_Msk  (0x100000UL)              /*!< SMB3_INST COMPLETION: REPEAT_READ (Bitfield-Mask: 0x01)     */
#define SMB3_INST_COMPLETION_REPEAT_WRITE_Pos (21UL)                    /*!< SMB3_INST COMPLETION: REPEAT_WRITE (Bit 21)                 */
#define SMB3_INST_COMPLETION_REPEAT_WRITE_Msk (0x200000UL)              /*!< SMB3_INST COMPLETION: REPEAT_WRITE (Bitfield-Mask: 0x01)    */
#define SMB3_INST_COMPLETION_MNAKX_Pos        (24UL)                    /*!< SMB3_INST COMPLETION: MNAKX (Bit 24)                        */
#define SMB3_INST_COMPLETION_MNAKX_Msk        (0x1000000UL)             /*!< SMB3_INST COMPLETION: MNAKX (Bitfield-Mask: 0x01)           */
#define SMB3_INST_COMPLETION_MTR_Pos          (25UL)                    /*!< SMB3_INST COMPLETION: MTR (Bit 25)                          */
#define SMB3_INST_COMPLETION_MTR_Msk          (0x2000000UL)             /*!< SMB3_INST COMPLETION: MTR (Bitfield-Mask: 0x01)             */
#define SMB3_INST_COMPLETION_IDLE_Pos         (29UL)                    /*!< SMB3_INST COMPLETION: IDLE (Bit 29)                         */
#define SMB3_INST_COMPLETION_IDLE_Msk         (0x20000000UL)            /*!< SMB3_INST COMPLETION: IDLE (Bitfield-Mask: 0x01)            */
#define SMB3_INST_COMPLETION_MDONE_Pos        (30UL)                    /*!< SMB3_INST COMPLETION: MDONE (Bit 30)                        */
#define SMB3_INST_COMPLETION_MDONE_Msk        (0x40000000UL)            /*!< SMB3_INST COMPLETION: MDONE (Bitfield-Mask: 0x01)           */
#define SMB3_INST_COMPLETION_SDONE_Pos        (31UL)                    /*!< SMB3_INST COMPLETION: SDONE (Bit 31)                        */
#define SMB3_INST_COMPLETION_SDONE_Msk        (0x80000000UL)            /*!< SMB3_INST COMPLETION: SDONE (Bitfield-Mask: 0x01)           */

/* ---------------------------  SMB3_INST_IDLE_SCALING  --------------------------- */
#define SMB3_INST_IDLE_SCALING_FAIR_BUS_IDLE_MIN_Pos (0UL)              /*!< SMB3_INST IDLE_SCALING: FAIR_BUS_IDLE_MIN (Bit 0)           */
#define SMB3_INST_IDLE_SCALING_FAIR_BUS_IDLE_MIN_Msk (0xfffUL)          /*!< SMB3_INST IDLE_SCALING: FAIR_BUS_IDLE_MIN (Bitfield-Mask: 0xfff) */
#define SMB3_INST_IDLE_SCALING_FAIR_IDLE_DELAY_Pos (16UL)               /*!< SMB3_INST IDLE_SCALING: FAIR_IDLE_DELAY (Bit 16)            */
#define SMB3_INST_IDLE_SCALING_FAIR_IDLE_DELAY_Msk (0xfff0000UL)        /*!< SMB3_INST IDLE_SCALING: FAIR_IDLE_DELAY (Bitfield-Mask: 0xfff) */

/* ---------------------------  SMB3_INST_CONFIGURATION  -------------------------- */
#define SMB3_INST_CONFIGURATION_PORT_SEL_Pos  (0UL)                     /*!< SMB3_INST CONFIGURATION: PORT_SEL (Bit 0)                   */
#define SMB3_INST_CONFIGURATION_PORT_SEL_Msk  (0xfUL)                   /*!< SMB3_INST CONFIGURATION: PORT_SEL (Bitfield-Mask: 0x0f)     */
#define SMB3_INST_CONFIGURATION_TCEN_Pos      (4UL)                     /*!< SMB3_INST CONFIGURATION: TCEN (Bit 4)                       */
#define SMB3_INST_CONFIGURATION_TCEN_Msk      (0x10UL)                  /*!< SMB3_INST CONFIGURATION: TCEN (Bitfield-Mask: 0x01)         */
#define SMB3_INST_CONFIGURATION_SLOW_CLOCK_Pos (5UL)                    /*!< SMB3_INST CONFIGURATION: SLOW_CLOCK (Bit 5)                 */
#define SMB3_INST_CONFIGURATION_SLOW_CLOCK_Msk (0x20UL)                 /*!< SMB3_INST CONFIGURATION: SLOW_CLOCK (Bitfield-Mask: 0x01)   */
#define SMB3_INST_CONFIGURATION_TEST_Pos      (6UL)                     /*!< SMB3_INST CONFIGURATION: TEST (Bit 6)                       */
#define SMB3_INST_CONFIGURATION_TEST_Msk      (0x40UL)                  /*!< SMB3_INST CONFIGURATION: TEST (Bitfield-Mask: 0x01)         */
#define SMB3_INST_CONFIGURATION_PECEN_Pos     (7UL)                     /*!< SMB3_INST CONFIGURATION: PECEN (Bit 7)                      */
#define SMB3_INST_CONFIGURATION_PECEN_Msk     (0x80UL)                  /*!< SMB3_INST CONFIGURATION: PECEN (Bitfield-Mask: 0x01)        */
#define SMB3_INST_CONFIGURATION_FEN_Pos       (8UL)                     /*!< SMB3_INST CONFIGURATION: FEN (Bit 8)                        */
#define SMB3_INST_CONFIGURATION_FEN_Msk       (0x100UL)                 /*!< SMB3_INST CONFIGURATION: FEN (Bitfield-Mask: 0x01)          */
#define SMB3_INST_CONFIGURATION_RESET_Pos     (9UL)                     /*!< SMB3_INST CONFIGURATION: RESET (Bit 9)                      */
#define SMB3_INST_CONFIGURATION_RESET_Msk     (0x200UL)                 /*!< SMB3_INST CONFIGURATION: RESET (Bitfield-Mask: 0x01)        */
#define SMB3_INST_CONFIGURATION_ENAB_Pos      (10UL)                    /*!< SMB3_INST CONFIGURATION: ENAB (Bit 10)                      */
#define SMB3_INST_CONFIGURATION_ENAB_Msk      (0x400UL)                 /*!< SMB3_INST CONFIGURATION: ENAB (Bitfield-Mask: 0x01)         */
#define SMB3_INST_CONFIGURATION_DSA_Pos       (11UL)                    /*!< SMB3_INST CONFIGURATION: DSA (Bit 11)                       */
#define SMB3_INST_CONFIGURATION_DSA_Msk       (0x800UL)                 /*!< SMB3_INST CONFIGURATION: DSA (Bitfield-Mask: 0x01)          */
#define SMB3_INST_CONFIGURATION_FAIR_Pos      (12UL)                    /*!< SMB3_INST CONFIGURATION: FAIR (Bit 12)                      */
#define SMB3_INST_CONFIGURATION_FAIR_Msk      (0x1000UL)                /*!< SMB3_INST CONFIGURATION: FAIR (Bitfield-Mask: 0x01)         */
#define SMB3_INST_CONFIGURATION_TEST0_Pos     (13UL)                    /*!< SMB3_INST CONFIGURATION: TEST0 (Bit 13)                     */
#define SMB3_INST_CONFIGURATION_TEST0_Msk     (0x2000UL)                /*!< SMB3_INST CONFIGURATION: TEST0 (Bitfield-Mask: 0x01)        */
#define SMB3_INST_CONFIGURATION_GC_DIS_Pos    (14UL)                    /*!< SMB3_INST CONFIGURATION: GC_DIS (Bit 14)                    */
#define SMB3_INST_CONFIGURATION_GC_DIS_Msk    (0x4000UL)                /*!< SMB3_INST CONFIGURATION: GC_DIS (Bitfield-Mask: 0x01)       */
#define SMB3_INST_CONFIGURATION_FLUSH_SXBUF_Pos (16UL)                  /*!< SMB3_INST CONFIGURATION: FLUSH_SXBUF (Bit 16)               */
#define SMB3_INST_CONFIGURATION_FLUSH_SXBUF_Msk (0x10000UL)             /*!< SMB3_INST CONFIGURATION: FLUSH_SXBUF (Bitfield-Mask: 0x01)  */
#define SMB3_INST_CONFIGURATION_FLUSH_SRBUF_Pos (17UL)                  /*!< SMB3_INST CONFIGURATION: FLUSH_SRBUF (Bit 17)               */
#define SMB3_INST_CONFIGURATION_FLUSH_SRBUF_Msk (0x20000UL)             /*!< SMB3_INST CONFIGURATION: FLUSH_SRBUF (Bitfield-Mask: 0x01)  */
#define SMB3_INST_CONFIGURATION_FLUSH_MXBUF_Pos (18UL)                  /*!< SMB3_INST CONFIGURATION: FLUSH_MXBUF (Bit 18)               */
#define SMB3_INST_CONFIGURATION_FLUSH_MXBUF_Msk (0x40000UL)             /*!< SMB3_INST CONFIGURATION: FLUSH_MXBUF (Bitfield-Mask: 0x01)  */
#define SMB3_INST_CONFIGURATION_FLUSH_MRBUF_Pos (19UL)                  /*!< SMB3_INST CONFIGURATION: FLUSH_MRBUF (Bit 19)               */
#define SMB3_INST_CONFIGURATION_FLUSH_MRBUF_Msk (0x80000UL)             /*!< SMB3_INST CONFIGURATION: FLUSH_MRBUF (Bitfield-Mask: 0x01)  */
#define SMB3_INST_CONFIGURATION_EN_AAS_Pos    (28UL)                    /*!< SMB3_INST CONFIGURATION: EN_AAS (Bit 28)                    */
#define SMB3_INST_CONFIGURATION_EN_AAS_Msk    (0x10000000UL)            /*!< SMB3_INST CONFIGURATION: EN_AAS (Bitfield-Mask: 0x01)       */
#define SMB3_INST_CONFIGURATION_ENIDI_Pos     (29UL)                    /*!< SMB3_INST CONFIGURATION: ENIDI (Bit 29)                     */
#define SMB3_INST_CONFIGURATION_ENIDI_Msk     (0x20000000UL)            /*!< SMB3_INST CONFIGURATION: ENIDI (Bitfield-Mask: 0x01)        */
#define SMB3_INST_CONFIGURATION_ENMI_Pos      (30UL)                    /*!< SMB3_INST CONFIGURATION: ENMI (Bit 30)                      */
#define SMB3_INST_CONFIGURATION_ENMI_Msk      (0x40000000UL)            /*!< SMB3_INST CONFIGURATION: ENMI (Bitfield-Mask: 0x01)         */
#define SMB3_INST_CONFIGURATION_ENSI_Pos      (31UL)                    /*!< SMB3_INST CONFIGURATION: ENSI (Bit 31)                      */
#define SMB3_INST_CONFIGURATION_ENSI_Msk      (0x80000000UL)            /*!< SMB3_INST CONFIGURATION: ENSI (Bitfield-Mask: 0x01)         */

/* -----------------------------  SMB3_INST_BUS_CLOCK  ---------------------------- */
#define SMB3_INST_BUS_CLOCK_LOW_PERIOD_Pos    (0UL)                     /*!< SMB3_INST BUS_CLOCK: LOW_PERIOD (Bit 0)                     */
#define SMB3_INST_BUS_CLOCK_LOW_PERIOD_Msk    (0xffUL)                  /*!< SMB3_INST BUS_CLOCK: LOW_PERIOD (Bitfield-Mask: 0xff)       */
#define SMB3_INST_BUS_CLOCK_HIGH_PERIOD_Pos   (8UL)                     /*!< SMB3_INST BUS_CLOCK: HIGH_PERIOD (Bit 8)                    */
#define SMB3_INST_BUS_CLOCK_HIGH_PERIOD_Msk   (0xff00UL)                /*!< SMB3_INST BUS_CLOCK: HIGH_PERIOD (Bitfield-Mask: 0xff)      */

/* -----------------------------  SMB3_INST_BLOCK_ID  ----------------------------- */
#define SMB3_INST_BLOCK_ID_ID_Pos             (0UL)                     /*!< SMB3_INST BLOCK_ID: ID (Bit 0)                              */
#define SMB3_INST_BLOCK_ID_ID_Msk             (0xffUL)                  /*!< SMB3_INST BLOCK_ID: ID (Bitfield-Mask: 0xff)                */

/* -----------------------------  SMB3_INST_REVISION  ----------------------------- */
#define SMB3_INST_REVISION_REVISION_Pos       (0UL)                     /*!< SMB3_INST REVISION: REVISION (Bit 0)                        */
#define SMB3_INST_REVISION_REVISION_Msk       (0xffUL)                  /*!< SMB3_INST REVISION: REVISION (Bitfield-Mask: 0xff)          */

/* -------------------------  SMB3_INST_BIT_BANG_CONTROL  ------------------------- */
#define SMB3_INST_BIT_BANG_CONTROL_BBEN_Pos   (0UL)                     /*!< SMB3_INST BIT_BANG_CONTROL: BBEN (Bit 0)                    */
#define SMB3_INST_BIT_BANG_CONTROL_BBEN_Msk   (0x1UL)                   /*!< SMB3_INST BIT_BANG_CONTROL: BBEN (Bitfield-Mask: 0x01)      */
#define SMB3_INST_BIT_BANG_CONTROL_CLDIR_Pos  (1UL)                     /*!< SMB3_INST BIT_BANG_CONTROL: CLDIR (Bit 1)                   */
#define SMB3_INST_BIT_BANG_CONTROL_CLDIR_Msk  (0x2UL)                   /*!< SMB3_INST BIT_BANG_CONTROL: CLDIR (Bitfield-Mask: 0x01)     */
#define SMB3_INST_BIT_BANG_CONTROL_DADIR_Pos  (2UL)                     /*!< SMB3_INST BIT_BANG_CONTROL: DADIR (Bit 2)                   */
#define SMB3_INST_BIT_BANG_CONTROL_DADIR_Msk  (0x4UL)                   /*!< SMB3_INST BIT_BANG_CONTROL: DADIR (Bitfield-Mask: 0x01)     */
#define SMB3_INST_BIT_BANG_CONTROL_BBCLK_Pos  (3UL)                     /*!< SMB3_INST BIT_BANG_CONTROL: BBCLK (Bit 3)                   */
#define SMB3_INST_BIT_BANG_CONTROL_BBCLK_Msk  (0x8UL)                   /*!< SMB3_INST BIT_BANG_CONTROL: BBCLK (Bitfield-Mask: 0x01)     */
#define SMB3_INST_BIT_BANG_CONTROL_BBDAT_Pos  (4UL)                     /*!< SMB3_INST BIT_BANG_CONTROL: BBDAT (Bit 4)                   */
#define SMB3_INST_BIT_BANG_CONTROL_BBDAT_Msk  (0x10UL)                  /*!< SMB3_INST BIT_BANG_CONTROL: BBDAT (Bitfield-Mask: 0x01)     */
#define SMB3_INST_BIT_BANG_CONTROL_BBCLKI_Pos (5UL)                     /*!< SMB3_INST BIT_BANG_CONTROL: BBCLKI (Bit 5)                  */
#define SMB3_INST_BIT_BANG_CONTROL_BBCLKI_Msk (0x20UL)                  /*!< SMB3_INST BIT_BANG_CONTROL: BBCLKI (Bitfield-Mask: 0x01)    */
#define SMB3_INST_BIT_BANG_CONTROL_BBDATI_Pos (6UL)                     /*!< SMB3_INST BIT_BANG_CONTROL: BBDATI (Bit 6)                  */
#define SMB3_INST_BIT_BANG_CONTROL_BBDATI_Msk (0x40UL)                  /*!< SMB3_INST BIT_BANG_CONTROL: BBDATI (Bitfield-Mask: 0x01)    */

/* -------------------------------  SMB3_INST_TEST  ------------------------------- */
#define SMB3_INST_TEST_TEST_Pos               (0UL)                     /*!< SMB3_INST TEST: TEST (Bit 0)                                */
#define SMB3_INST_TEST_TEST_Msk               (0xffUL)                  /*!< SMB3_INST TEST: TEST (Bitfield-Mask: 0xff)                  */

/* ----------------------------  SMB3_INST_DATA_TIMING  --------------------------- */
#define SMB3_INST_DATA_TIMING_DATA_HOLD_Pos   (0UL)                     /*!< SMB3_INST DATA_TIMING: DATA_HOLD (Bit 0)                    */
#define SMB3_INST_DATA_TIMING_DATA_HOLD_Msk   (0xffUL)                  /*!< SMB3_INST DATA_TIMING: DATA_HOLD (Bitfield-Mask: 0xff)      */
#define SMB3_INST_DATA_TIMING_RESTART_SETUP_Pos (8UL)                   /*!< SMB3_INST DATA_TIMING: RESTART_SETUP (Bit 8)                */
#define SMB3_INST_DATA_TIMING_RESTART_SETUP_Msk (0xff00UL)              /*!< SMB3_INST DATA_TIMING: RESTART_SETUP (Bitfield-Mask: 0xff)  */
#define SMB3_INST_DATA_TIMING_STOP_SETUP_Pos  (16UL)                    /*!< SMB3_INST DATA_TIMING: STOP_SETUP (Bit 16)                  */
#define SMB3_INST_DATA_TIMING_STOP_SETUP_Msk  (0xff0000UL)              /*!< SMB3_INST DATA_TIMING: STOP_SETUP (Bitfield-Mask: 0xff)     */
#define SMB3_INST_DATA_TIMING_FIRST_START_HOLD_Pos (24UL)               /*!< SMB3_INST DATA_TIMING: FIRST_START_HOLD (Bit 24)            */
#define SMB3_INST_DATA_TIMING_FIRST_START_HOLD_Msk (0xff000000UL)       /*!< SMB3_INST DATA_TIMING: FIRST_START_HOLD (Bitfield-Mask: 0xff) */

/* -------------------------  SMB3_INST_TIME_OUT_SCALING  ------------------------- */
#define SMB3_INST_TIME_OUT_SCALING_CLOCK_HIGH_TIME_OUT_Pos (0UL)        /*!< SMB3_INST TIME_OUT_SCALING: CLOCK_HIGH_TIME_OUT (Bit 0)     */
#define SMB3_INST_TIME_OUT_SCALING_CLOCK_HIGH_TIME_OUT_Msk (0xffUL)     /*!< SMB3_INST TIME_OUT_SCALING: CLOCK_HIGH_TIME_OUT (Bitfield-Mask: 0xff) */
#define SMB3_INST_TIME_OUT_SCALING_SLAVE_CUM_TIME_OUT_Pos (8UL)         /*!< SMB3_INST TIME_OUT_SCALING: SLAVE_CUM_TIME_OUT (Bit 8)      */
#define SMB3_INST_TIME_OUT_SCALING_SLAVE_CUM_TIME_OUT_Msk (0xff00UL)    /*!< SMB3_INST TIME_OUT_SCALING: SLAVE_CUM_TIME_OUT (Bitfield-Mask: 0xff) */
#define SMB3_INST_TIME_OUT_SCALING_MASTER_CUM_TIME_OUT_Pos (16UL)       /*!< SMB3_INST TIME_OUT_SCALING: MASTER_CUM_TIME_OUT (Bit 16)    */
#define SMB3_INST_TIME_OUT_SCALING_MASTER_CUM_TIME_OUT_Msk (0xff0000UL) /*!< SMB3_INST TIME_OUT_SCALING: MASTER_CUM_TIME_OUT (Bitfield-Mask: 0xff) */
#define SMB3_INST_TIME_OUT_SCALING_BUS_IDLE_MIN_Pos (24UL)              /*!< SMB3_INST TIME_OUT_SCALING: BUS_IDLE_MIN (Bit 24)           */
#define SMB3_INST_TIME_OUT_SCALING_BUS_IDLE_MIN_Msk (0xff000000UL)      /*!< SMB3_INST TIME_OUT_SCALING: BUS_IDLE_MIN (Bitfield-Mask: 0xff) */

/* -----------------------  SMB3_INST_SLAVE_TRANSMIT_BUFFER  ---------------------- */
#define SMB3_INST_SLAVE_TRANSMIT_BUFFER_SLAVE_TRANSMIT_BUFFER_Pos (0UL) /*!< SMB3_INST SLAVE_TRANSMIT_BUFFER: SLAVE_TRANSMIT_BUFFER (Bit 0) */
#define SMB3_INST_SLAVE_TRANSMIT_BUFFER_SLAVE_TRANSMIT_BUFFER_Msk (0xffUL) /*!< SMB3_INST SLAVE_TRANSMIT_BUFFER: SLAVE_TRANSMIT_BUFFER (Bitfield-Mask: 0xff) */

/* -----------------------  SMB3_INST_SLAVE_RECEIVE_BUFFER  ----------------------- */
#define SMB3_INST_SLAVE_RECEIVE_BUFFER_SLAVE_RECEIVE_BUFFER_Pos (0UL)   /*!< SMB3_INST SLAVE_RECEIVE_BUFFER: SLAVE_RECEIVE_BUFFER (Bit 0) */
#define SMB3_INST_SLAVE_RECEIVE_BUFFER_SLAVE_RECEIVE_BUFFER_Msk (0xffUL) /*!< SMB3_INST SLAVE_RECEIVE_BUFFER: SLAVE_RECEIVE_BUFFER (Bitfield-Mask: 0xff) */

/* -----------------------  SMB3_INST_MASTER_TRANSMIT_BUFER  ---------------------- */
#define SMB3_INST_MASTER_TRANSMIT_BUFER_MASTER_TRANSMIT_BUFFER_Pos (0UL) /*!< SMB3_INST MASTER_TRANSMIT_BUFER: MASTER_TRANSMIT_BUFFER (Bit 0) */
#define SMB3_INST_MASTER_TRANSMIT_BUFER_MASTER_TRANSMIT_BUFFER_Msk (0xffUL) /*!< SMB3_INST MASTER_TRANSMIT_BUFER: MASTER_TRANSMIT_BUFFER (Bitfield-Mask: 0xff) */

/* -----------------------  SMB3_INST_MASTER_RECEIVE_BUFFER  ---------------------- */
#define SMB3_INST_MASTER_RECEIVE_BUFFER_MASTER_RECEIVE_BUFFER_Pos (0UL) /*!< SMB3_INST MASTER_RECEIVE_BUFFER: MASTER_RECEIVE_BUFFER (Bit 0) */
#define SMB3_INST_MASTER_RECEIVE_BUFFER_MASTER_RECEIVE_BUFFER_Msk (0xffUL) /*!< SMB3_INST MASTER_RECEIVE_BUFFER: MASTER_RECEIVE_BUFFER (Bitfield-Mask: 0xff) */

/* ----------------------------  SMB3_INST_WAKE_STATUS  --------------------------- */
#define SMB3_INST_WAKE_STATUS_START_BIT_DETECTION_Pos (0UL)             /*!< SMB3_INST WAKE_STATUS: START_BIT_DETECTION (Bit 0)          */
#define SMB3_INST_WAKE_STATUS_START_BIT_DETECTION_Msk (0x1UL)           /*!< SMB3_INST WAKE_STATUS: START_BIT_DETECTION (Bitfield-Mask: 0x01) */

/* ----------------------------  SMB3_INST_WAKE_ENABLE  --------------------------- */
#define SMB3_INST_WAKE_ENABLE_START_DETECT_INT_EN_Pos (0UL)             /*!< SMB3_INST WAKE_ENABLE: START_DETECT_INT_EN (Bit 0)          */
#define SMB3_INST_WAKE_ENABLE_START_DETECT_INT_EN_Msk (0x1UL)           /*!< SMB3_INST WAKE_ENABLE: START_DETECT_INT_EN (Bitfield-Mask: 0x01) */


/* ================================================================================ */
/* ================      struct 'GP_SPI0_INST' Position & Mask     ================ */
/* ================================================================================ */


/* ----------------------------  GP_SPI0_INST_CONTROL  ---------------------------- */
#define GP_SPI0_INST_CONTROL_LSBF_Pos         (0UL)                     /*!< GP_SPI0_INST CONTROL: LSBF (Bit 0)                          */
#define GP_SPI0_INST_CONTROL_LSBF_Msk         (0x1UL)                   /*!< GP_SPI0_INST CONTROL: LSBF (Bitfield-Mask: 0x01)            */
#define GP_SPI0_INST_CONTROL_BIOEN_Pos        (1UL)                     /*!< GP_SPI0_INST CONTROL: BIOEN (Bit 1)                         */
#define GP_SPI0_INST_CONTROL_BIOEN_Msk        (0x2UL)                   /*!< GP_SPI0_INST CONTROL: BIOEN (Bitfield-Mask: 0x01)           */
#define GP_SPI0_INST_CONTROL_SPDIN_SELECT_Pos (2UL)                     /*!< GP_SPI0_INST CONTROL: SPDIN_SELECT (Bit 2)                  */
#define GP_SPI0_INST_CONTROL_SPDIN_SELECT_Msk (0xcUL)                   /*!< GP_SPI0_INST CONTROL: SPDIN_SELECT (Bitfield-Mask: 0x03)    */
#define GP_SPI0_INST_CONTROL_SOFT_RESET_Pos   (4UL)                     /*!< GP_SPI0_INST CONTROL: SOFT_RESET (Bit 4)                    */
#define GP_SPI0_INST_CONTROL_SOFT_RESET_Msk   (0x10UL)                  /*!< GP_SPI0_INST CONTROL: SOFT_RESET (Bitfield-Mask: 0x01)      */
#define GP_SPI0_INST_CONTROL_AUTO_READ_Pos    (5UL)                     /*!< GP_SPI0_INST CONTROL: AUTO_READ (Bit 5)                     */
#define GP_SPI0_INST_CONTROL_AUTO_READ_Msk    (0x20UL)                  /*!< GP_SPI0_INST CONTROL: AUTO_READ (Bitfield-Mask: 0x01)       */
#define GP_SPI0_INST_CONTROL_CE_Pos           (6UL)                     /*!< GP_SPI0_INST CONTROL: CE (Bit 6)                            */
#define GP_SPI0_INST_CONTROL_CE_Msk           (0x40UL)                  /*!< GP_SPI0_INST CONTROL: CE (Bitfield-Mask: 0x01)              */

/* -----------------------------  GP_SPI0_INST_STATUS  ---------------------------- */
#define GP_SPI0_INST_STATUS_TXBE_Pos          (0UL)                     /*!< GP_SPI0_INST STATUS: TXBE (Bit 0)                           */
#define GP_SPI0_INST_STATUS_TXBE_Msk          (0x1UL)                   /*!< GP_SPI0_INST STATUS: TXBE (Bitfield-Mask: 0x01)             */
#define GP_SPI0_INST_STATUS_RXBF_Pos          (1UL)                     /*!< GP_SPI0_INST STATUS: RXBF (Bit 1)                           */
#define GP_SPI0_INST_STATUS_RXBF_Msk          (0x2UL)                   /*!< GP_SPI0_INST STATUS: RXBF (Bitfield-Mask: 0x01)             */
#define GP_SPI0_INST_STATUS_ACTIVE_Pos        (2UL)                     /*!< GP_SPI0_INST STATUS: ACTIVE (Bit 2)                         */
#define GP_SPI0_INST_STATUS_ACTIVE_Msk        (0x4UL)                   /*!< GP_SPI0_INST STATUS: ACTIVE (Bitfield-Mask: 0x01)           */

/* -------------------------  GP_SPI0_INST_CLOCK_Control  ------------------------- */
#define GP_SPI0_INST_CLOCK_Control_TCLKPH_Pos (0UL)                     /*!< GP_SPI0_INST CLOCK_Control: TCLKPH (Bit 0)                  */
#define GP_SPI0_INST_CLOCK_Control_TCLKPH_Msk (0x1UL)                   /*!< GP_SPI0_INST CLOCK_Control: TCLKPH (Bitfield-Mask: 0x01)    */
#define GP_SPI0_INST_CLOCK_Control_RCLKPH_Pos (1UL)                     /*!< GP_SPI0_INST CLOCK_Control: RCLKPH (Bit 1)                  */
#define GP_SPI0_INST_CLOCK_Control_RCLKPH_Msk (0x2UL)                   /*!< GP_SPI0_INST CLOCK_Control: RCLKPH (Bitfield-Mask: 0x01)    */
#define GP_SPI0_INST_CLOCK_Control_CLKPOL_Pos (2UL)                     /*!< GP_SPI0_INST CLOCK_Control: CLKPOL (Bit 2)                  */
#define GP_SPI0_INST_CLOCK_Control_CLKPOL_Msk (0x4UL)                   /*!< GP_SPI0_INST CLOCK_Control: CLKPOL (Bitfield-Mask: 0x01)    */
#define GP_SPI0_INST_CLOCK_Control_CLKSRC_Pos (4UL)                     /*!< GP_SPI0_INST CLOCK_Control: CLKSRC (Bit 4)                  */
#define GP_SPI0_INST_CLOCK_Control_CLKSRC_Msk (0x10UL)                  /*!< GP_SPI0_INST CLOCK_Control: CLKSRC (Bitfield-Mask: 0x01)    */


/* ================================================================================ */
/* ================      struct 'GP_SPI1_INST' Position & Mask     ================ */
/* ================================================================================ */


/* ----------------------------  GP_SPI1_INST_CONTROL  ---------------------------- */
#define GP_SPI1_INST_CONTROL_LSBF_Pos         (0UL)                     /*!< GP_SPI1_INST CONTROL: LSBF (Bit 0)                          */
#define GP_SPI1_INST_CONTROL_LSBF_Msk         (0x1UL)                   /*!< GP_SPI1_INST CONTROL: LSBF (Bitfield-Mask: 0x01)            */
#define GP_SPI1_INST_CONTROL_BIOEN_Pos        (1UL)                     /*!< GP_SPI1_INST CONTROL: BIOEN (Bit 1)                         */
#define GP_SPI1_INST_CONTROL_BIOEN_Msk        (0x2UL)                   /*!< GP_SPI1_INST CONTROL: BIOEN (Bitfield-Mask: 0x01)           */
#define GP_SPI1_INST_CONTROL_SPDIN_SELECT_Pos (2UL)                     /*!< GP_SPI1_INST CONTROL: SPDIN_SELECT (Bit 2)                  */
#define GP_SPI1_INST_CONTROL_SPDIN_SELECT_Msk (0xcUL)                   /*!< GP_SPI1_INST CONTROL: SPDIN_SELECT (Bitfield-Mask: 0x03)    */
#define GP_SPI1_INST_CONTROL_SOFT_RESET_Pos   (4UL)                     /*!< GP_SPI1_INST CONTROL: SOFT_RESET (Bit 4)                    */
#define GP_SPI1_INST_CONTROL_SOFT_RESET_Msk   (0x10UL)                  /*!< GP_SPI1_INST CONTROL: SOFT_RESET (Bitfield-Mask: 0x01)      */
#define GP_SPI1_INST_CONTROL_AUTO_READ_Pos    (5UL)                     /*!< GP_SPI1_INST CONTROL: AUTO_READ (Bit 5)                     */
#define GP_SPI1_INST_CONTROL_AUTO_READ_Msk    (0x20UL)                  /*!< GP_SPI1_INST CONTROL: AUTO_READ (Bitfield-Mask: 0x01)       */
#define GP_SPI1_INST_CONTROL_CE_Pos           (6UL)                     /*!< GP_SPI1_INST CONTROL: CE (Bit 6)                            */
#define GP_SPI1_INST_CONTROL_CE_Msk           (0x40UL)                  /*!< GP_SPI1_INST CONTROL: CE (Bitfield-Mask: 0x01)              */

/* -----------------------------  GP_SPI1_INST_STATUS  ---------------------------- */
#define GP_SPI1_INST_STATUS_TXBE_Pos          (0UL)                     /*!< GP_SPI1_INST STATUS: TXBE (Bit 0)                           */
#define GP_SPI1_INST_STATUS_TXBE_Msk          (0x1UL)                   /*!< GP_SPI1_INST STATUS: TXBE (Bitfield-Mask: 0x01)             */
#define GP_SPI1_INST_STATUS_RXBF_Pos          (1UL)                     /*!< GP_SPI1_INST STATUS: RXBF (Bit 1)                           */
#define GP_SPI1_INST_STATUS_RXBF_Msk          (0x2UL)                   /*!< GP_SPI1_INST STATUS: RXBF (Bitfield-Mask: 0x01)             */
#define GP_SPI1_INST_STATUS_ACTIVE_Pos        (2UL)                     /*!< GP_SPI1_INST STATUS: ACTIVE (Bit 2)                         */
#define GP_SPI1_INST_STATUS_ACTIVE_Msk        (0x4UL)                   /*!< GP_SPI1_INST STATUS: ACTIVE (Bitfield-Mask: 0x01)           */

/* -------------------------  GP_SPI1_INST_CLOCK_Control  ------------------------- */
#define GP_SPI1_INST_CLOCK_Control_TCLKPH_Pos (0UL)                     /*!< GP_SPI1_INST CLOCK_Control: TCLKPH (Bit 0)                  */
#define GP_SPI1_INST_CLOCK_Control_TCLKPH_Msk (0x1UL)                   /*!< GP_SPI1_INST CLOCK_Control: TCLKPH (Bitfield-Mask: 0x01)    */
#define GP_SPI1_INST_CLOCK_Control_RCLKPH_Pos (1UL)                     /*!< GP_SPI1_INST CLOCK_Control: RCLKPH (Bit 1)                  */
#define GP_SPI1_INST_CLOCK_Control_RCLKPH_Msk (0x2UL)                   /*!< GP_SPI1_INST CLOCK_Control: RCLKPH (Bitfield-Mask: 0x01)    */
#define GP_SPI1_INST_CLOCK_Control_CLKPOL_Pos (2UL)                     /*!< GP_SPI1_INST CLOCK_Control: CLKPOL (Bit 2)                  */
#define GP_SPI1_INST_CLOCK_Control_CLKPOL_Msk (0x4UL)                   /*!< GP_SPI1_INST CLOCK_Control: CLKPOL (Bitfield-Mask: 0x01)    */
#define GP_SPI1_INST_CLOCK_Control_CLKSRC_Pos (4UL)                     /*!< GP_SPI1_INST CLOCK_Control: CLKSRC (Bit 4)                  */
#define GP_SPI1_INST_CLOCK_Control_CLKSRC_Msk (0x10UL)                  /*!< GP_SPI1_INST CLOCK_Control: CLKSRC (Bitfield-Mask: 0x01)    */


/* ================================================================================ */
/* ================       struct 'QMSPI_INST' Position & Mask      ================ */
/* ================================================================================ */


/* ----------------------------  QMSPI_INST_QMSPI_MODE  --------------------------- */
#define QMSPI_INST_QMSPI_MODE_ACTIVATE_Pos    (0UL)                     /*!< QMSPI_INST QMSPI_MODE: ACTIVATE (Bit 0)                     */
#define QMSPI_INST_QMSPI_MODE_ACTIVATE_Msk    (0x1UL)                   /*!< QMSPI_INST QMSPI_MODE: ACTIVATE (Bitfield-Mask: 0x01)       */
#define QMSPI_INST_QMSPI_MODE_SOFT_RESET_Pos  (1UL)                     /*!< QMSPI_INST QMSPI_MODE: SOFT_RESET (Bit 1)                   */
#define QMSPI_INST_QMSPI_MODE_SOFT_RESET_Msk  (0x2UL)                   /*!< QMSPI_INST QMSPI_MODE: SOFT_RESET (Bitfield-Mask: 0x01)     */
#define QMSPI_INST_QMSPI_MODE_CPOL_Pos        (8UL)                     /*!< QMSPI_INST QMSPI_MODE: CPOL (Bit 8)                         */
#define QMSPI_INST_QMSPI_MODE_CPOL_Msk        (0x100UL)                 /*!< QMSPI_INST QMSPI_MODE: CPOL (Bitfield-Mask: 0x01)           */
#define QMSPI_INST_QMSPI_MODE_CHPA_MOSI_Pos   (9UL)                     /*!< QMSPI_INST QMSPI_MODE: CHPA_MOSI (Bit 9)                    */
#define QMSPI_INST_QMSPI_MODE_CHPA_MOSI_Msk   (0x200UL)                 /*!< QMSPI_INST QMSPI_MODE: CHPA_MOSI (Bitfield-Mask: 0x01)      */
#define QMSPI_INST_QMSPI_MODE_CHPA_MISO_Pos   (10UL)                    /*!< QMSPI_INST QMSPI_MODE: CHPA_MISO (Bit 10)                   */
#define QMSPI_INST_QMSPI_MODE_CHPA_MISO_Msk   (0x400UL)                 /*!< QMSPI_INST QMSPI_MODE: CHPA_MISO (Bitfield-Mask: 0x01)      */
#define QMSPI_INST_QMSPI_MODE_CLOCK_DIVIDE_Pos (16UL)                   /*!< QMSPI_INST QMSPI_MODE: CLOCK_DIVIDE (Bit 16)                */
#define QMSPI_INST_QMSPI_MODE_CLOCK_DIVIDE_Msk (0x1ff0000UL)            /*!< QMSPI_INST QMSPI_MODE: CLOCK_DIVIDE (Bitfield-Mask: 0x1ff)  */

/* --------------------------  QMSPI_INST_QMSPI_CONTROL  -------------------------- */
#define QMSPI_INST_QMSPI_CONTROL_INTERFACE_MODE_Pos (0UL)               /*!< QMSPI_INST QMSPI_CONTROL: INTERFACE_MODE (Bit 0)            */
#define QMSPI_INST_QMSPI_CONTROL_INTERFACE_MODE_Msk (0x3UL)             /*!< QMSPI_INST QMSPI_CONTROL: INTERFACE_MODE (Bitfield-Mask: 0x03) */
#define QMSPI_INST_QMSPI_CONTROL_TX_TRANSFER_ENABLE_Pos (2UL)           /*!< QMSPI_INST QMSPI_CONTROL: TX_TRANSFER_ENABLE (Bit 2)        */
#define QMSPI_INST_QMSPI_CONTROL_TX_TRANSFER_ENABLE_Msk (0xcUL)         /*!< QMSPI_INST QMSPI_CONTROL: TX_TRANSFER_ENABLE (Bitfield-Mask: 0x03) */
#define QMSPI_INST_QMSPI_CONTROL_TX_DMA_ENABLE_Pos (4UL)                /*!< QMSPI_INST QMSPI_CONTROL: TX_DMA_ENABLE (Bit 4)             */
#define QMSPI_INST_QMSPI_CONTROL_TX_DMA_ENABLE_Msk (0x30UL)             /*!< QMSPI_INST QMSPI_CONTROL: TX_DMA_ENABLE (Bitfield-Mask: 0x03) */
#define QMSPI_INST_QMSPI_CONTROL_RX_TRANSFER_ENABLE_Pos (6UL)           /*!< QMSPI_INST QMSPI_CONTROL: RX_TRANSFER_ENABLE (Bit 6)        */
#define QMSPI_INST_QMSPI_CONTROL_RX_TRANSFER_ENABLE_Msk (0x40UL)        /*!< QMSPI_INST QMSPI_CONTROL: RX_TRANSFER_ENABLE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_CONTROL_RX_DMA_ENABLE_Pos (7UL)                /*!< QMSPI_INST QMSPI_CONTROL: RX_DMA_ENABLE (Bit 7)             */
#define QMSPI_INST_QMSPI_CONTROL_RX_DMA_ENABLE_Msk (0x180UL)            /*!< QMSPI_INST QMSPI_CONTROL: RX_DMA_ENABLE (Bitfield-Mask: 0x03) */
#define QMSPI_INST_QMSPI_CONTROL_CLOSE_TRANSFER_ENABLE_Pos (9UL)        /*!< QMSPI_INST QMSPI_CONTROL: CLOSE_TRANSFER_ENABLE (Bit 9)     */
#define QMSPI_INST_QMSPI_CONTROL_CLOSE_TRANSFER_ENABLE_Msk (0x200UL)    /*!< QMSPI_INST QMSPI_CONTROL: CLOSE_TRANSFER_ENABLE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_CONTROL_TRANSFER_UNITS_Pos (10UL)              /*!< QMSPI_INST QMSPI_CONTROL: TRANSFER_UNITS (Bit 10)           */
#define QMSPI_INST_QMSPI_CONTROL_TRANSFER_UNITS_Msk (0xc00UL)           /*!< QMSPI_INST QMSPI_CONTROL: TRANSFER_UNITS (Bitfield-Mask: 0x03) */
#define QMSPI_INST_QMSPI_CONTROL_DESCRIPTION_BUFFER_POINTER_Pos (12UL)  /*!< QMSPI_INST QMSPI_CONTROL: DESCRIPTION_BUFFER_POINTER (Bit 12) */
#define QMSPI_INST_QMSPI_CONTROL_DESCRIPTION_BUFFER_POINTER_Msk (0xf000UL) /*!< QMSPI_INST QMSPI_CONTROL: DESCRIPTION_BUFFER_POINTER (Bitfield-Mask: 0x0f) */
#define QMSPI_INST_QMSPI_CONTROL_DESCRIPTION_BUFFER_ENABLE_Pos (16UL)   /*!< QMSPI_INST QMSPI_CONTROL: DESCRIPTION_BUFFER_ENABLE (Bit 16) */
#define QMSPI_INST_QMSPI_CONTROL_DESCRIPTION_BUFFER_ENABLE_Msk (0x10000UL) /*!< QMSPI_INST QMSPI_CONTROL: DESCRIPTION_BUFFER_ENABLE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_CONTROL_TRANSFER_LENGTH_Pos (17UL)             /*!< QMSPI_INST QMSPI_CONTROL: TRANSFER_LENGTH (Bit 17)          */
#define QMSPI_INST_QMSPI_CONTROL_TRANSFER_LENGTH_Msk (0xfffe0000UL)     /*!< QMSPI_INST QMSPI_CONTROL: TRANSFER_LENGTH (Bitfield-Mask: 0x7fff) */

/* --------------------------  QMSPI_INST_QMSPI_EXECUTE  -------------------------- */
#define QMSPI_INST_QMSPI_EXECUTE_START_Pos    (0UL)                     /*!< QMSPI_INST QMSPI_EXECUTE: START (Bit 0)                     */
#define QMSPI_INST_QMSPI_EXECUTE_START_Msk    (0x1UL)                   /*!< QMSPI_INST QMSPI_EXECUTE: START (Bitfield-Mask: 0x01)       */
#define QMSPI_INST_QMSPI_EXECUTE_STOP_Pos     (1UL)                     /*!< QMSPI_INST QMSPI_EXECUTE: STOP (Bit 1)                      */
#define QMSPI_INST_QMSPI_EXECUTE_STOP_Msk     (0x2UL)                   /*!< QMSPI_INST QMSPI_EXECUTE: STOP (Bitfield-Mask: 0x01)        */
#define QMSPI_INST_QMSPI_EXECUTE_CLEAR_DATA_BUFFER_Pos (2UL)            /*!< QMSPI_INST QMSPI_EXECUTE: CLEAR_DATA_BUFFER (Bit 2)         */
#define QMSPI_INST_QMSPI_EXECUTE_CLEAR_DATA_BUFFER_Msk (0x4UL)          /*!< QMSPI_INST QMSPI_EXECUTE: CLEAR_DATA_BUFFER (Bitfield-Mask: 0x01) */

/* ---------------------  QMSPI_INST_QMSPI_INTERFACE_CONTROL  --------------------- */
#define QMSPI_INST_QMSPI_INTERFACE_CONTROL_WRITE_PROTECT_OUT_VALUE_Pos (0UL) /*!< QMSPI_INST QMSPI_INTERFACE_CONTROL: WRITE_PROTECT_OUT_VALUE (Bit 0) */
#define QMSPI_INST_QMSPI_INTERFACE_CONTROL_WRITE_PROTECT_OUT_VALUE_Msk (0x1UL) /*!< QMSPI_INST QMSPI_INTERFACE_CONTROL: WRITE_PROTECT_OUT_VALUE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_INTERFACE_CONTROL_WRITE_PROTECT_OUT_ENABLE_Pos (1UL) /*!< QMSPI_INST QMSPI_INTERFACE_CONTROL: WRITE_PROTECT_OUT_ENABLE (Bit 1) */
#define QMSPI_INST_QMSPI_INTERFACE_CONTROL_WRITE_PROTECT_OUT_ENABLE_Msk (0x2UL) /*!< QMSPI_INST QMSPI_INTERFACE_CONTROL: WRITE_PROTECT_OUT_ENABLE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_INTERFACE_CONTROL_HOLD_OUT_VALUE_Pos (2UL)     /*!< QMSPI_INST QMSPI_INTERFACE_CONTROL: HOLD_OUT_VALUE (Bit 2)  */
#define QMSPI_INST_QMSPI_INTERFACE_CONTROL_HOLD_OUT_VALUE_Msk (0x4UL)   /*!< QMSPI_INST QMSPI_INTERFACE_CONTROL: HOLD_OUT_VALUE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_INTERFACE_CONTROL_HOLD_OUT_ENABLE_Pos (3UL)    /*!< QMSPI_INST QMSPI_INTERFACE_CONTROL: HOLD_OUT_ENABLE (Bit 3) */
#define QMSPI_INST_QMSPI_INTERFACE_CONTROL_HOLD_OUT_ENABLE_Msk (0x8UL)  /*!< QMSPI_INST QMSPI_INTERFACE_CONTROL: HOLD_OUT_ENABLE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_INTERFACE_CONTROL_PULLDOWN_ON_NOT_SELECTED_Pos (4UL) /*!< QMSPI_INST QMSPI_INTERFACE_CONTROL: PULLDOWN_ON_NOT_SELECTED (Bit 4) */
#define QMSPI_INST_QMSPI_INTERFACE_CONTROL_PULLDOWN_ON_NOT_SELECTED_Msk (0x10UL) /*!< QMSPI_INST QMSPI_INTERFACE_CONTROL: PULLDOWN_ON_NOT_SELECTED (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_INTERFACE_CONTROL_PULLUP_ON_NOT_SELECTED_Pos (5UL) /*!< QMSPI_INST QMSPI_INTERFACE_CONTROL: PULLUP_ON_NOT_SELECTED (Bit 5) */
#define QMSPI_INST_QMSPI_INTERFACE_CONTROL_PULLUP_ON_NOT_SELECTED_Msk (0x20UL) /*!< QMSPI_INST QMSPI_INTERFACE_CONTROL: PULLUP_ON_NOT_SELECTED (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_INTERFACE_CONTROL_PULLDOWN_ON_NOT_DRIVEN_Pos (6UL) /*!< QMSPI_INST QMSPI_INTERFACE_CONTROL: PULLDOWN_ON_NOT_DRIVEN (Bit 6) */
#define QMSPI_INST_QMSPI_INTERFACE_CONTROL_PULLDOWN_ON_NOT_DRIVEN_Msk (0x40UL) /*!< QMSPI_INST QMSPI_INTERFACE_CONTROL: PULLDOWN_ON_NOT_DRIVEN (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_INTERFACE_CONTROL_PULLUP_ON_NOT_DRIVEN_Pos (7UL) /*!< QMSPI_INST QMSPI_INTERFACE_CONTROL: PULLUP_ON_NOT_DRIVEN (Bit 7) */
#define QMSPI_INST_QMSPI_INTERFACE_CONTROL_PULLUP_ON_NOT_DRIVEN_Msk (0x80UL) /*!< QMSPI_INST QMSPI_INTERFACE_CONTROL: PULLUP_ON_NOT_DRIVEN (Bitfield-Mask: 0x01) */

/* ---------------------------  QMSPI_INST_QMSPI_STATUS  -------------------------- */
#define QMSPI_INST_QMSPI_STATUS_TRANSFER_COMPLETE_Pos (0UL)             /*!< QMSPI_INST QMSPI_STATUS: TRANSFER_COMPLETE (Bit 0)          */
#define QMSPI_INST_QMSPI_STATUS_TRANSFER_COMPLETE_Msk (0x1UL)           /*!< QMSPI_INST QMSPI_STATUS: TRANSFER_COMPLETE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_STATUS_DMA_COMPLETE_Pos (1UL)                  /*!< QMSPI_INST QMSPI_STATUS: DMA_COMPLETE (Bit 1)               */
#define QMSPI_INST_QMSPI_STATUS_DMA_COMPLETE_Msk (0x2UL)                /*!< QMSPI_INST QMSPI_STATUS: DMA_COMPLETE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_STATUS_TRANSMIT_BUFFER_ERROR_Pos (2UL)         /*!< QMSPI_INST QMSPI_STATUS: TRANSMIT_BUFFER_ERROR (Bit 2)      */
#define QMSPI_INST_QMSPI_STATUS_TRANSMIT_BUFFER_ERROR_Msk (0x4UL)       /*!< QMSPI_INST QMSPI_STATUS: TRANSMIT_BUFFER_ERROR (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_STATUS_RECEIVE_BUFFER_ERROR_Pos (3UL)          /*!< QMSPI_INST QMSPI_STATUS: RECEIVE_BUFFER_ERROR (Bit 3)       */
#define QMSPI_INST_QMSPI_STATUS_RECEIVE_BUFFER_ERROR_Msk (0x8UL)        /*!< QMSPI_INST QMSPI_STATUS: RECEIVE_BUFFER_ERROR (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_STATUS_PROGRAMMING_ERROR_Pos (4UL)             /*!< QMSPI_INST QMSPI_STATUS: PROGRAMMING_ERROR (Bit 4)          */
#define QMSPI_INST_QMSPI_STATUS_PROGRAMMING_ERROR_Msk (0x10UL)          /*!< QMSPI_INST QMSPI_STATUS: PROGRAMMING_ERROR (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_STATUS_TRANSMIT_BUFFER_FULL_Pos (8UL)          /*!< QMSPI_INST QMSPI_STATUS: TRANSMIT_BUFFER_FULL (Bit 8)       */
#define QMSPI_INST_QMSPI_STATUS_TRANSMIT_BUFFER_FULL_Msk (0x100UL)      /*!< QMSPI_INST QMSPI_STATUS: TRANSMIT_BUFFER_FULL (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_STATUS_TRANSMIT_BUFFER_EMPTY_Pos (9UL)         /*!< QMSPI_INST QMSPI_STATUS: TRANSMIT_BUFFER_EMPTY (Bit 9)      */
#define QMSPI_INST_QMSPI_STATUS_TRANSMIT_BUFFER_EMPTY_Msk (0x200UL)     /*!< QMSPI_INST QMSPI_STATUS: TRANSMIT_BUFFER_EMPTY (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_STATUS_TRANSMIT_BUFFER_REQUEST_Pos (10UL)      /*!< QMSPI_INST QMSPI_STATUS: TRANSMIT_BUFFER_REQUEST (Bit 10)   */
#define QMSPI_INST_QMSPI_STATUS_TRANSMIT_BUFFER_REQUEST_Msk (0x400UL)   /*!< QMSPI_INST QMSPI_STATUS: TRANSMIT_BUFFER_REQUEST (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_STATUS_TRANSMIT_BUFFER_STALL_Pos (11UL)        /*!< QMSPI_INST QMSPI_STATUS: TRANSMIT_BUFFER_STALL (Bit 11)     */
#define QMSPI_INST_QMSPI_STATUS_TRANSMIT_BUFFER_STALL_Msk (0x800UL)     /*!< QMSPI_INST QMSPI_STATUS: TRANSMIT_BUFFER_STALL (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_STATUS_RECEIVE_BUFFER_FULL_Pos (12UL)          /*!< QMSPI_INST QMSPI_STATUS: RECEIVE_BUFFER_FULL (Bit 12)       */
#define QMSPI_INST_QMSPI_STATUS_RECEIVE_BUFFER_FULL_Msk (0x1000UL)      /*!< QMSPI_INST QMSPI_STATUS: RECEIVE_BUFFER_FULL (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_STATUS_RECEIVE_BUFFER_EMPTY_Pos (13UL)         /*!< QMSPI_INST QMSPI_STATUS: RECEIVE_BUFFER_EMPTY (Bit 13)      */
#define QMSPI_INST_QMSPI_STATUS_RECEIVE_BUFFER_EMPTY_Msk (0x2000UL)     /*!< QMSPI_INST QMSPI_STATUS: RECEIVE_BUFFER_EMPTY (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_STATUS_RECEIVE_BUFFER_REQUEST_Pos (14UL)       /*!< QMSPI_INST QMSPI_STATUS: RECEIVE_BUFFER_REQUEST (Bit 14)    */
#define QMSPI_INST_QMSPI_STATUS_RECEIVE_BUFFER_REQUEST_Msk (0x4000UL)   /*!< QMSPI_INST QMSPI_STATUS: RECEIVE_BUFFER_REQUEST (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_STATUS_RECEIVE_BUFFER_STALL_Pos (15UL)         /*!< QMSPI_INST QMSPI_STATUS: RECEIVE_BUFFER_STALL (Bit 15)      */
#define QMSPI_INST_QMSPI_STATUS_RECEIVE_BUFFER_STALL_Msk (0x8000UL)     /*!< QMSPI_INST QMSPI_STATUS: RECEIVE_BUFFER_STALL (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_STATUS_TRANSFER_ACTIVE_Pos (16UL)              /*!< QMSPI_INST QMSPI_STATUS: TRANSFER_ACTIVE (Bit 16)           */
#define QMSPI_INST_QMSPI_STATUS_TRANSFER_ACTIVE_Msk (0x10000UL)         /*!< QMSPI_INST QMSPI_STATUS: TRANSFER_ACTIVE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_STATUS_CURRENT_DESCRIPTION_BUFFER_Pos (24UL)   /*!< QMSPI_INST QMSPI_STATUS: CURRENT_DESCRIPTION_BUFFER (Bit 24) */
#define QMSPI_INST_QMSPI_STATUS_CURRENT_DESCRIPTION_BUFFER_Msk (0xf000000UL) /*!< QMSPI_INST QMSPI_STATUS: CURRENT_DESCRIPTION_BUFFER (Bitfield-Mask: 0x0f) */

/* --------------------  QMSPI_INST_QMSPI_BUFFER_COUNT_STATUS  -------------------- */
#define QMSPI_INST_QMSPI_BUFFER_COUNT_STATUS_TRANSMIT_BUFFER_COUNT_Pos (0UL) /*!< QMSPI_INST QMSPI_BUFFER_COUNT_STATUS: TRANSMIT_BUFFER_COUNT (Bit 0) */
#define QMSPI_INST_QMSPI_BUFFER_COUNT_STATUS_TRANSMIT_BUFFER_COUNT_Msk (0xffffUL) /*!< QMSPI_INST QMSPI_BUFFER_COUNT_STATUS: TRANSMIT_BUFFER_COUNT (Bitfield-Mask: 0xffff) */
#define QMSPI_INST_QMSPI_BUFFER_COUNT_STATUS_RECEIVE_BUFFER_COUNT_Pos (16UL) /*!< QMSPI_INST QMSPI_BUFFER_COUNT_STATUS: RECEIVE_BUFFER_COUNT (Bit 16) */
#define QMSPI_INST_QMSPI_BUFFER_COUNT_STATUS_RECEIVE_BUFFER_COUNT_Msk (0xffff0000UL) /*!< QMSPI_INST QMSPI_BUFFER_COUNT_STATUS: RECEIVE_BUFFER_COUNT (Bitfield-Mask: 0xffff) */

/* ----------------------  QMSPI_INST_QMSPI_INTERRUPT_ENABLE  --------------------- */
#define QMSPI_INST_QMSPI_INTERRUPT_ENABLE_TRANSFER_COMPLETE_ENABLE_Pos (0UL) /*!< QMSPI_INST QMSPI_INTERRUPT_ENABLE: TRANSFER_COMPLETE_ENABLE (Bit 0) */
#define QMSPI_INST_QMSPI_INTERRUPT_ENABLE_TRANSFER_COMPLETE_ENABLE_Msk (0x1UL) /*!< QMSPI_INST QMSPI_INTERRUPT_ENABLE: TRANSFER_COMPLETE_ENABLE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_INTERRUPT_ENABLE_DMA_COMPLETE_ENABLE_Pos (1UL) /*!< QMSPI_INST QMSPI_INTERRUPT_ENABLE: DMA_COMPLETE_ENABLE (Bit 1) */
#define QMSPI_INST_QMSPI_INTERRUPT_ENABLE_DMA_COMPLETE_ENABLE_Msk (0x2UL) /*!< QMSPI_INST QMSPI_INTERRUPT_ENABLE: DMA_COMPLETE_ENABLE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_INTERRUPT_ENABLE_TRANSMIT_BUFFER_ERROR_ENABLE_Pos (2UL) /*!< QMSPI_INST QMSPI_INTERRUPT_ENABLE: TRANSMIT_BUFFER_ERROR_ENABLE (Bit 2) */
#define QMSPI_INST_QMSPI_INTERRUPT_ENABLE_TRANSMIT_BUFFER_ERROR_ENABLE_Msk (0x4UL) /*!< QMSPI_INST QMSPI_INTERRUPT_ENABLE: TRANSMIT_BUFFER_ERROR_ENABLE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_INTERRUPT_ENABLE_RECEIVE_BUFFER_ERROR_ENABLE_Pos (3UL) /*!< QMSPI_INST QMSPI_INTERRUPT_ENABLE: RECEIVE_BUFFER_ERROR_ENABLE (Bit 3) */
#define QMSPI_INST_QMSPI_INTERRUPT_ENABLE_RECEIVE_BUFFER_ERROR_ENABLE_Msk (0x8UL) /*!< QMSPI_INST QMSPI_INTERRUPT_ENABLE: RECEIVE_BUFFER_ERROR_ENABLE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_INTERRUPT_ENABLE_PROGRAMMING_ERROR_ENABLE_Pos (4UL) /*!< QMSPI_INST QMSPI_INTERRUPT_ENABLE: PROGRAMMING_ERROR_ENABLE (Bit 4) */
#define QMSPI_INST_QMSPI_INTERRUPT_ENABLE_PROGRAMMING_ERROR_ENABLE_Msk (0x10UL) /*!< QMSPI_INST QMSPI_INTERRUPT_ENABLE: PROGRAMMING_ERROR_ENABLE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_INTERRUPT_ENABLE_TRANSMIT_BUFFER_FULL_ENABLE_Pos (8UL) /*!< QMSPI_INST QMSPI_INTERRUPT_ENABLE: TRANSMIT_BUFFER_FULL_ENABLE (Bit 8) */
#define QMSPI_INST_QMSPI_INTERRUPT_ENABLE_TRANSMIT_BUFFER_FULL_ENABLE_Msk (0x100UL) /*!< QMSPI_INST QMSPI_INTERRUPT_ENABLE: TRANSMIT_BUFFER_FULL_ENABLE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_INTERRUPT_ENABLE_TRANSMIT_BUFFER_EMPTY_ENABLE_Pos (9UL) /*!< QMSPI_INST QMSPI_INTERRUPT_ENABLE: TRANSMIT_BUFFER_EMPTY_ENABLE (Bit 9) */
#define QMSPI_INST_QMSPI_INTERRUPT_ENABLE_TRANSMIT_BUFFER_EMPTY_ENABLE_Msk (0x200UL) /*!< QMSPI_INST QMSPI_INTERRUPT_ENABLE: TRANSMIT_BUFFER_EMPTY_ENABLE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_INTERRUPT_ENABLE_TRANSMIT_BUFFER_REQUEST_ENABLE_Pos (10UL) /*!< QMSPI_INST QMSPI_INTERRUPT_ENABLE: TRANSMIT_BUFFER_REQUEST_ENABLE (Bit 10) */
#define QMSPI_INST_QMSPI_INTERRUPT_ENABLE_TRANSMIT_BUFFER_REQUEST_ENABLE_Msk (0x400UL) /*!< QMSPI_INST QMSPI_INTERRUPT_ENABLE: TRANSMIT_BUFFER_REQUEST_ENABLE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_INTERRUPT_ENABLE_RECEIVE_BUFFER_FULL_ENABLE_Pos (12UL) /*!< QMSPI_INST QMSPI_INTERRUPT_ENABLE: RECEIVE_BUFFER_FULL_ENABLE (Bit 12) */
#define QMSPI_INST_QMSPI_INTERRUPT_ENABLE_RECEIVE_BUFFER_FULL_ENABLE_Msk (0x1000UL) /*!< QMSPI_INST QMSPI_INTERRUPT_ENABLE: RECEIVE_BUFFER_FULL_ENABLE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_INTERRUPT_ENABLE_RECEIVE_BUFFER_EMPTY_ENABLE_Pos (13UL) /*!< QMSPI_INST QMSPI_INTERRUPT_ENABLE: RECEIVE_BUFFER_EMPTY_ENABLE (Bit 13) */
#define QMSPI_INST_QMSPI_INTERRUPT_ENABLE_RECEIVE_BUFFER_EMPTY_ENABLE_Msk (0x2000UL) /*!< QMSPI_INST QMSPI_INTERRUPT_ENABLE: RECEIVE_BUFFER_EMPTY_ENABLE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_INTERRUPT_ENABLE_RECEIVE_BUFFER_REQUEST_ENABLE_Pos (14UL) /*!< QMSPI_INST QMSPI_INTERRUPT_ENABLE: RECEIVE_BUFFER_REQUEST_ENABLE (Bit 14) */
#define QMSPI_INST_QMSPI_INTERRUPT_ENABLE_RECEIVE_BUFFER_REQUEST_ENABLE_Msk (0x4000UL) /*!< QMSPI_INST QMSPI_INTERRUPT_ENABLE: RECEIVE_BUFFER_REQUEST_ENABLE (Bitfield-Mask: 0x01) */

/* --------------------  QMSPI_INST_QMSPI_BUFFER_COUNT_TRIGGER  ------------------- */
#define QMSPI_INST_QMSPI_BUFFER_COUNT_TRIGGER_TRANSMIT_BUFFER_TRIGGER_Pos (0UL) /*!< QMSPI_INST QMSPI_BUFFER_COUNT_TRIGGER: TRANSMIT_BUFFER_TRIGGER (Bit 0) */
#define QMSPI_INST_QMSPI_BUFFER_COUNT_TRIGGER_TRANSMIT_BUFFER_TRIGGER_Msk (0xffffUL) /*!< QMSPI_INST QMSPI_BUFFER_COUNT_TRIGGER: TRANSMIT_BUFFER_TRIGGER (Bitfield-Mask: 0xffff) */
#define QMSPI_INST_QMSPI_BUFFER_COUNT_TRIGGER_RECEIVE_BUFFER_TRIGGER_Pos (16UL) /*!< QMSPI_INST QMSPI_BUFFER_COUNT_TRIGGER: RECEIVE_BUFFER_TRIGGER (Bit 16) */
#define QMSPI_INST_QMSPI_BUFFER_COUNT_TRIGGER_RECEIVE_BUFFER_TRIGGER_Msk (0xffff0000UL) /*!< QMSPI_INST QMSPI_BUFFER_COUNT_TRIGGER: RECEIVE_BUFFER_TRIGGER (Bitfield-Mask: 0xffff) */

/* ----------------------  QMSPI_INST_QMSPI_TRAMSMIT_BUFFER  ---------------------- */
#define QMSPI_INST_QMSPI_TRAMSMIT_BUFFER_TRANSMIT_BUFFER_Pos (0UL)      /*!< QMSPI_INST QMSPI_TRAMSMIT_BUFFER: TRANSMIT_BUFFER (Bit 0)   */
#define QMSPI_INST_QMSPI_TRAMSMIT_BUFFER_TRANSMIT_BUFFER_Msk (0xffffffffUL) /*!< QMSPI_INST QMSPI_TRAMSMIT_BUFFER: TRANSMIT_BUFFER (Bitfield-Mask: 0xffffffff) */

/* -----------------------  QMSPI_INST_QMSPI_RECEIVE_BUFFER  ---------------------- */
#define QMSPI_INST_QMSPI_RECEIVE_BUFFER_RECEIVE_BUFFER_Pos (0UL)        /*!< QMSPI_INST QMSPI_RECEIVE_BUFFER: RECEIVE_BUFFER (Bit 0)     */
#define QMSPI_INST_QMSPI_RECEIVE_BUFFER_RECEIVE_BUFFER_Msk (0xffffffffUL) /*!< QMSPI_INST QMSPI_RECEIVE_BUFFER: RECEIVE_BUFFER (Bitfield-Mask: 0xffffffff) */

/* --------------------  QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_0  ------------------- */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_0_INTERFACE_MODE_Pos (0UL)  /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_0: INTERFACE_MODE (Bit 0) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_0_INTERFACE_MODE_Msk (0x3UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_0: INTERFACE_MODE (Bitfield-Mask: 0x03) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_0_TX_TRANSFER_ENABLE_Pos (2UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_0: TX_TRANSFER_ENABLE (Bit 2) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_0_TX_TRANSFER_ENABLE_Msk (0xcUL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_0: TX_TRANSFER_ENABLE (Bitfield-Mask: 0x03) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_0_TX_DMA_ENABLE_Pos (4UL)   /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_0: TX_DMA_ENABLE (Bit 4) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_0_TX_DMA_ENABLE_Msk (0x30UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_0: TX_DMA_ENABLE (Bitfield-Mask: 0x03) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_0_RX_TRANSFER_ENABLE_Pos (6UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_0: RX_TRANSFER_ENABLE (Bit 6) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_0_RX_TRANSFER_ENABLE_Msk (0x40UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_0: RX_TRANSFER_ENABLE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_0_RX_DMA_ENABLE_Pos (7UL)   /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_0: RX_DMA_ENABLE (Bit 7) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_0_RX_DMA_ENABLE_Msk (0x180UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_0: RX_DMA_ENABLE (Bitfield-Mask: 0x03) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_0_CLOSE_TRANFSER_ENABLE_Pos (9UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_0: CLOSE_TRANFSER_ENABLE (Bit 9) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_0_CLOSE_TRANFSER_ENABLE_Msk (0x200UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_0: CLOSE_TRANFSER_ENABLE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_0_TRANSFER_LENGTH_BITS_Pos (10UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_0: TRANSFER_LENGTH_BITS (Bit 10) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_0_TRANSFER_LENGTH_BITS_Msk (0x400UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_0: TRANSFER_LENGTH_BITS (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_0_DESCRIPTION_BUFFER_LAST_Pos (11UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_0: DESCRIPTION_BUFFER_LAST (Bit 11) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_0_DESCRIPTION_BUFFER_LAST_Msk (0x800UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_0: DESCRIPTION_BUFFER_LAST (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_0_DESCRIPTION_BUFFER_NEXT_POINTER_Pos (12UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_0: DESCRIPTION_BUFFER_NEXT_POINTER (Bit 12) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_0_DESCRIPTION_BUFFER_NEXT_POINTER_Msk (0xf000UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_0: DESCRIPTION_BUFFER_NEXT_POINTER (Bitfield-Mask: 0x0f) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_0_TRANSFER_LENGTH_Pos (16UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_0: TRANSFER_LENGTH (Bit 16) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_0_TRANSFER_LENGTH_Msk (0xffff0000UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_0: TRANSFER_LENGTH (Bitfield-Mask: 0xffff) */

/* --------------------  QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_1  ------------------- */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_1_INTERFACE_MODE_Pos (0UL)  /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_1: INTERFACE_MODE (Bit 0) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_1_INTERFACE_MODE_Msk (0x3UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_1: INTERFACE_MODE (Bitfield-Mask: 0x03) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_1_TX_TRANSFER_ENABLE_Pos (2UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_1: TX_TRANSFER_ENABLE (Bit 2) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_1_TX_TRANSFER_ENABLE_Msk (0xcUL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_1: TX_TRANSFER_ENABLE (Bitfield-Mask: 0x03) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_1_TX_DMA_ENABLE_Pos (4UL)   /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_1: TX_DMA_ENABLE (Bit 4) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_1_TX_DMA_ENABLE_Msk (0x30UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_1: TX_DMA_ENABLE (Bitfield-Mask: 0x03) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_1_RX_TRANSFER_ENABLE_Pos (6UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_1: RX_TRANSFER_ENABLE (Bit 6) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_1_RX_TRANSFER_ENABLE_Msk (0x40UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_1: RX_TRANSFER_ENABLE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_1_RX_DMA_ENABLE_Pos (7UL)   /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_1: RX_DMA_ENABLE (Bit 7) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_1_RX_DMA_ENABLE_Msk (0x180UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_1: RX_DMA_ENABLE (Bitfield-Mask: 0x03) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_1_CLOSE_TRANFSER_ENABLE_Pos (9UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_1: CLOSE_TRANFSER_ENABLE (Bit 9) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_1_CLOSE_TRANFSER_ENABLE_Msk (0x200UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_1: CLOSE_TRANFSER_ENABLE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_1_TRANSFER_LENGTH_BITS_Pos (10UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_1: TRANSFER_LENGTH_BITS (Bit 10) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_1_TRANSFER_LENGTH_BITS_Msk (0x400UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_1: TRANSFER_LENGTH_BITS (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_1_DESCRIPTION_BUFFER_LAST_Pos (11UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_1: DESCRIPTION_BUFFER_LAST (Bit 11) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_1_DESCRIPTION_BUFFER_LAST_Msk (0x800UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_1: DESCRIPTION_BUFFER_LAST (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_1_DESCRIPTION_BUFFER_NEXT_POINTER_Pos (12UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_1: DESCRIPTION_BUFFER_NEXT_POINTER (Bit 12) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_1_DESCRIPTION_BUFFER_NEXT_POINTER_Msk (0xf000UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_1: DESCRIPTION_BUFFER_NEXT_POINTER (Bitfield-Mask: 0x0f) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_1_TRANSFER_LENGTH_Pos (16UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_1: TRANSFER_LENGTH (Bit 16) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_1_TRANSFER_LENGTH_Msk (0xffff0000UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_1: TRANSFER_LENGTH (Bitfield-Mask: 0xffff) */

/* --------------------  QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_2  ------------------- */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_2_INTERFACE_MODE_Pos (0UL)  /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_2: INTERFACE_MODE (Bit 0) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_2_INTERFACE_MODE_Msk (0x3UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_2: INTERFACE_MODE (Bitfield-Mask: 0x03) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_2_TX_TRANSFER_ENABLE_Pos (2UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_2: TX_TRANSFER_ENABLE (Bit 2) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_2_TX_TRANSFER_ENABLE_Msk (0xcUL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_2: TX_TRANSFER_ENABLE (Bitfield-Mask: 0x03) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_2_TX_DMA_ENABLE_Pos (4UL)   /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_2: TX_DMA_ENABLE (Bit 4) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_2_TX_DMA_ENABLE_Msk (0x30UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_2: TX_DMA_ENABLE (Bitfield-Mask: 0x03) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_2_RX_TRANSFER_ENABLE_Pos (6UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_2: RX_TRANSFER_ENABLE (Bit 6) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_2_RX_TRANSFER_ENABLE_Msk (0x40UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_2: RX_TRANSFER_ENABLE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_2_RX_DMA_ENABLE_Pos (7UL)   /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_2: RX_DMA_ENABLE (Bit 7) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_2_RX_DMA_ENABLE_Msk (0x180UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_2: RX_DMA_ENABLE (Bitfield-Mask: 0x03) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_2_CLOSE_TRANFSER_ENABLE_Pos (9UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_2: CLOSE_TRANFSER_ENABLE (Bit 9) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_2_CLOSE_TRANFSER_ENABLE_Msk (0x200UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_2: CLOSE_TRANFSER_ENABLE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_2_TRANSFER_LENGTH_BITS_Pos (10UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_2: TRANSFER_LENGTH_BITS (Bit 10) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_2_TRANSFER_LENGTH_BITS_Msk (0x400UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_2: TRANSFER_LENGTH_BITS (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_2_DESCRIPTION_BUFFER_LAST_Pos (11UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_2: DESCRIPTION_BUFFER_LAST (Bit 11) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_2_DESCRIPTION_BUFFER_LAST_Msk (0x800UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_2: DESCRIPTION_BUFFER_LAST (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_2_DESCRIPTION_BUFFER_NEXT_POINTER_Pos (12UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_2: DESCRIPTION_BUFFER_NEXT_POINTER (Bit 12) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_2_DESCRIPTION_BUFFER_NEXT_POINTER_Msk (0xf000UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_2: DESCRIPTION_BUFFER_NEXT_POINTER (Bitfield-Mask: 0x0f) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_2_TRANSFER_LENGTH_Pos (16UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_2: TRANSFER_LENGTH (Bit 16) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_2_TRANSFER_LENGTH_Msk (0xffff0000UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_2: TRANSFER_LENGTH (Bitfield-Mask: 0xffff) */

/* --------------------  QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_3  ------------------- */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_3_INTERFACE_MODE_Pos (0UL)  /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_3: INTERFACE_MODE (Bit 0) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_3_INTERFACE_MODE_Msk (0x3UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_3: INTERFACE_MODE (Bitfield-Mask: 0x03) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_3_TX_TRANSFER_ENABLE_Pos (2UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_3: TX_TRANSFER_ENABLE (Bit 2) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_3_TX_TRANSFER_ENABLE_Msk (0xcUL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_3: TX_TRANSFER_ENABLE (Bitfield-Mask: 0x03) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_3_TX_DMA_ENABLE_Pos (4UL)   /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_3: TX_DMA_ENABLE (Bit 4) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_3_TX_DMA_ENABLE_Msk (0x30UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_3: TX_DMA_ENABLE (Bitfield-Mask: 0x03) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_3_RX_TRANSFER_ENABLE_Pos (6UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_3: RX_TRANSFER_ENABLE (Bit 6) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_3_RX_TRANSFER_ENABLE_Msk (0x40UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_3: RX_TRANSFER_ENABLE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_3_RX_DMA_ENABLE_Pos (7UL)   /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_3: RX_DMA_ENABLE (Bit 7) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_3_RX_DMA_ENABLE_Msk (0x180UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_3: RX_DMA_ENABLE (Bitfield-Mask: 0x03) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_3_CLOSE_TRANFSER_ENABLE_Pos (9UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_3: CLOSE_TRANFSER_ENABLE (Bit 9) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_3_CLOSE_TRANFSER_ENABLE_Msk (0x200UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_3: CLOSE_TRANFSER_ENABLE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_3_TRANSFER_LENGTH_BITS_Pos (10UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_3: TRANSFER_LENGTH_BITS (Bit 10) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_3_TRANSFER_LENGTH_BITS_Msk (0x400UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_3: TRANSFER_LENGTH_BITS (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_3_DESCRIPTION_BUFFER_LAST_Pos (11UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_3: DESCRIPTION_BUFFER_LAST (Bit 11) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_3_DESCRIPTION_BUFFER_LAST_Msk (0x800UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_3: DESCRIPTION_BUFFER_LAST (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_3_DESCRIPTION_BUFFER_NEXT_POINTER_Pos (12UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_3: DESCRIPTION_BUFFER_NEXT_POINTER (Bit 12) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_3_DESCRIPTION_BUFFER_NEXT_POINTER_Msk (0xf000UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_3: DESCRIPTION_BUFFER_NEXT_POINTER (Bitfield-Mask: 0x0f) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_3_TRANSFER_LENGTH_Pos (16UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_3: TRANSFER_LENGTH (Bit 16) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_3_TRANSFER_LENGTH_Msk (0xffff0000UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_3: TRANSFER_LENGTH (Bitfield-Mask: 0xffff) */

/* --------------------  QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_4  ------------------- */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_4_INTERFACE_MODE_Pos (0UL)  /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_4: INTERFACE_MODE (Bit 0) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_4_INTERFACE_MODE_Msk (0x3UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_4: INTERFACE_MODE (Bitfield-Mask: 0x03) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_4_TX_TRANSFER_ENABLE_Pos (2UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_4: TX_TRANSFER_ENABLE (Bit 2) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_4_TX_TRANSFER_ENABLE_Msk (0xcUL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_4: TX_TRANSFER_ENABLE (Bitfield-Mask: 0x03) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_4_TX_DMA_ENABLE_Pos (4UL)   /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_4: TX_DMA_ENABLE (Bit 4) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_4_TX_DMA_ENABLE_Msk (0x30UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_4: TX_DMA_ENABLE (Bitfield-Mask: 0x03) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_4_RX_TRANSFER_ENABLE_Pos (6UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_4: RX_TRANSFER_ENABLE (Bit 6) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_4_RX_TRANSFER_ENABLE_Msk (0x40UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_4: RX_TRANSFER_ENABLE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_4_RX_DMA_ENABLE_Pos (7UL)   /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_4: RX_DMA_ENABLE (Bit 7) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_4_RX_DMA_ENABLE_Msk (0x180UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_4: RX_DMA_ENABLE (Bitfield-Mask: 0x03) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_4_CLOSE_TRANFSER_ENABLE_Pos (9UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_4: CLOSE_TRANFSER_ENABLE (Bit 9) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_4_CLOSE_TRANFSER_ENABLE_Msk (0x200UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_4: CLOSE_TRANFSER_ENABLE (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_4_TRANSFER_LENGTH_BITS_Pos (10UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_4: TRANSFER_LENGTH_BITS (Bit 10) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_4_TRANSFER_LENGTH_BITS_Msk (0x400UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_4: TRANSFER_LENGTH_BITS (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_4_DESCRIPTION_BUFFER_LAST_Pos (11UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_4: DESCRIPTION_BUFFER_LAST (Bit 11) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_4_DESCRIPTION_BUFFER_LAST_Msk (0x800UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_4: DESCRIPTION_BUFFER_LAST (Bitfield-Mask: 0x01) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_4_DESCRIPTION_BUFFER_NEXT_POINTER_Pos (12UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_4: DESCRIPTION_BUFFER_NEXT_POINTER (Bit 12) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_4_DESCRIPTION_BUFFER_NEXT_POINTER_Msk (0xf000UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_4: DESCRIPTION_BUFFER_NEXT_POINTER (Bitfield-Mask: 0x0f) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_4_TRANSFER_LENGTH_Pos (16UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_4: TRANSFER_LENGTH (Bit 16) */
#define QMSPI_INST_QMSPI_DESCRIPTION_BUFFER_4_TRANSFER_LENGTH_Msk (0xffff0000UL) /*!< QMSPI_INST QMSPI_DESCRIPTION_BUFFER_4: TRANSFER_LENGTH (Bitfield-Mask: 0xffff) */


/* ================================================================================ */
/* ================       struct 'TFDP_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ---------------------------  TFDP_INST_DEBUG_CONTROL  -------------------------- */
#define TFDP_INST_DEBUG_CONTROL_EN_Pos        (0UL)                     /*!< TFDP_INST DEBUG_CONTROL: EN (Bit 0)                         */
#define TFDP_INST_DEBUG_CONTROL_EN_Msk        (0x1UL)                   /*!< TFDP_INST DEBUG_CONTROL: EN (Bitfield-Mask: 0x01)           */
#define TFDP_INST_DEBUG_CONTROL_EDGE_SEL_Pos  (1UL)                     /*!< TFDP_INST DEBUG_CONTROL: EDGE_SEL (Bit 1)                   */
#define TFDP_INST_DEBUG_CONTROL_EDGE_SEL_Msk  (0x2UL)                   /*!< TFDP_INST DEBUG_CONTROL: EDGE_SEL (Bitfield-Mask: 0x01)     */
#define TFDP_INST_DEBUG_CONTROL_DIVSEL_Pos    (2UL)                     /*!< TFDP_INST DEBUG_CONTROL: DIVSEL (Bit 2)                     */
#define TFDP_INST_DEBUG_CONTROL_DIVSEL_Msk    (0xcUL)                   /*!< TFDP_INST DEBUG_CONTROL: DIVSEL (Bitfield-Mask: 0x03)       */
#define TFDP_INST_DEBUG_CONTROL_IP_DELAY_Pos  (4UL)                     /*!< TFDP_INST DEBUG_CONTROL: IP_DELAY (Bit 4)                   */
#define TFDP_INST_DEBUG_CONTROL_IP_DELAY_Msk  (0x70UL)                  /*!< TFDP_INST DEBUG_CONTROL: IP_DELAY (Bitfield-Mask: 0x07)     */


/* ================================================================================ */
/* ================        struct 'VCI_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ------------------------------  VCI_INST_VCI_REG  ------------------------------ */
#define VCI_INST_VCI_REG_VCI_IN_Pos           (0UL)                     /*!< VCI_INST VCI_REG: VCI_IN (Bit 0)                            */
#define VCI_INST_VCI_REG_VCI_IN_Msk           (0x7fUL)                  /*!< VCI_INST VCI_REG: VCI_IN (Bitfield-Mask: 0x7f)              */
#define VCI_INST_VCI_REG_VCI_OVRD_IN_Pos      (8UL)                     /*!< VCI_INST VCI_REG: VCI_OVRD_IN (Bit 8)                       */
#define VCI_INST_VCI_REG_VCI_OVRD_IN_Msk      (0x100UL)                 /*!< VCI_INST VCI_REG: VCI_OVRD_IN (Bitfield-Mask: 0x01)         */
#define VCI_INST_VCI_REG_VCI_OUT_Pos          (9UL)                     /*!< VCI_INST VCI_REG: VCI_OUT (Bit 9)                           */
#define VCI_INST_VCI_REG_VCI_OUT_Msk          (0x200UL)                 /*!< VCI_INST VCI_REG: VCI_OUT (Bitfield-Mask: 0x01)             */
#define VCI_INST_VCI_REG_VCI_FW_CNTRL_Pos     (10UL)                    /*!< VCI_INST VCI_REG: VCI_FW_CNTRL (Bit 10)                     */
#define VCI_INST_VCI_REG_VCI_FW_CNTRL_Msk     (0x400UL)                 /*!< VCI_INST VCI_REG: VCI_FW_CNTRL (Bitfield-Mask: 0x01)        */
#define VCI_INST_VCI_REG_FW_EXT_Pos           (11UL)                    /*!< VCI_INST VCI_REG: FW_EXT (Bit 11)                           */
#define VCI_INST_VCI_REG_FW_EXT_Msk           (0x800UL)                 /*!< VCI_INST VCI_REG: FW_EXT (Bitfield-Mask: 0x01)              */
#define VCI_INST_VCI_REG_FILTERS_BYPASS_Pos   (12UL)                    /*!< VCI_INST VCI_REG: FILTERS_BYPASS (Bit 12)                   */
#define VCI_INST_VCI_REG_FILTERS_BYPASS_Msk   (0x1000UL)                /*!< VCI_INST VCI_REG: FILTERS_BYPASS (Bitfield-Mask: 0x01)      */
#define VCI_INST_VCI_REG_WEEK_ALRM_Pos        (16UL)                    /*!< VCI_INST VCI_REG: WEEK_ALRM (Bit 16)                        */
#define VCI_INST_VCI_REG_WEEK_ALRM_Msk        (0x10000UL)               /*!< VCI_INST VCI_REG: WEEK_ALRM (Bitfield-Mask: 0x01)           */
#define VCI_INST_VCI_REG_RTC_ALRM_Pos         (17UL)                    /*!< VCI_INST VCI_REG: RTC_ALRM (Bit 17)                         */
#define VCI_INST_VCI_REG_RTC_ALRM_Msk         (0x20000UL)               /*!< VCI_INST VCI_REG: RTC_ALRM (Bitfield-Mask: 0x01)            */

/* ----------------------------  VCI_INST_LATCH_ENABLE  --------------------------- */
#define VCI_INST_LATCH_ENABLE_LE_Pos          (0UL)                     /*!< VCI_INST LATCH_ENABLE: LE (Bit 0)                           */
#define VCI_INST_LATCH_ENABLE_LE_Msk          (0x7fUL)                  /*!< VCI_INST LATCH_ENABLE: LE (Bitfield-Mask: 0x7f)             */
#define VCI_INST_LATCH_ENABLE_WEEK_ALRM_LE_Pos (16UL)                   /*!< VCI_INST LATCH_ENABLE: WEEK_ALRM_LE (Bit 16)                */
#define VCI_INST_LATCH_ENABLE_WEEK_ALRM_LE_Msk (0x10000UL)              /*!< VCI_INST LATCH_ENABLE: WEEK_ALRM_LE (Bitfield-Mask: 0x01)   */
#define VCI_INST_LATCH_ENABLE_RTC_ALRM_LE_Pos (17UL)                    /*!< VCI_INST LATCH_ENABLE: RTC_ALRM_LE (Bit 17)                 */
#define VCI_INST_LATCH_ENABLE_RTC_ALRM_LE_Msk (0x20000UL)               /*!< VCI_INST LATCH_ENABLE: RTC_ALRM_LE (Bitfield-Mask: 0x01)    */

/* ----------------------------  VCI_INST_LATCH_RESETS  --------------------------- */
#define VCI_INST_LATCH_RESETS_LS_Pos          (0UL)                     /*!< VCI_INST LATCH_RESETS: LS (Bit 0)                           */
#define VCI_INST_LATCH_RESETS_LS_Msk          (0x7fUL)                  /*!< VCI_INST LATCH_RESETS: LS (Bitfield-Mask: 0x7f)             */
#define VCI_INST_LATCH_RESETS_WEEK_ALRM_LS_Pos (16UL)                   /*!< VCI_INST LATCH_RESETS: WEEK_ALRM_LS (Bit 16)                */
#define VCI_INST_LATCH_RESETS_WEEK_ALRM_LS_Msk (0x10000UL)              /*!< VCI_INST LATCH_RESETS: WEEK_ALRM_LS (Bitfield-Mask: 0x01)   */
#define VCI_INST_LATCH_RESETS_RTC_ALRM_LS_Pos (17UL)                    /*!< VCI_INST LATCH_RESETS: RTC_ALRM_LS (Bit 17)                 */
#define VCI_INST_LATCH_RESETS_RTC_ALRM_LS_Msk (0x20000UL)               /*!< VCI_INST LATCH_RESETS: RTC_ALRM_LS (Bitfield-Mask: 0x01)    */

/* --------------------------  VCI_INST_VCI_INPUT_ENABLE  ------------------------- */
#define VCI_INST_VCI_INPUT_ENABLE_IE_Pos      (0UL)                     /*!< VCI_INST VCI_INPUT_ENABLE: IE (Bit 0)                       */
#define VCI_INST_VCI_INPUT_ENABLE_IE_Msk      (0x7fUL)                  /*!< VCI_INST VCI_INPUT_ENABLE: IE (Bitfield-Mask: 0x7f)         */

/* ---------------------------  VCI_INST_HOLDOFF_COUNT  --------------------------- */
#define VCI_INST_HOLDOFF_COUNT_HOLDOFF_TIME_Pos (0UL)                   /*!< VCI_INST HOLDOFF_COUNT: HOLDOFF_TIME (Bit 0)                */
#define VCI_INST_HOLDOFF_COUNT_HOLDOFF_TIME_Msk (0xffUL)                /*!< VCI_INST HOLDOFF_COUNT: HOLDOFF_TIME (Bitfield-Mask: 0xff)  */

/* ----------------------------  VCI_INST_VCI_POLARITY  --------------------------- */
#define VCI_INST_VCI_POLARITY_VCI_IN_POL_Pos  (0UL)                     /*!< VCI_INST VCI_POLARITY: VCI_IN_POL (Bit 0)                   */
#define VCI_INST_VCI_POLARITY_VCI_IN_POL_Msk  (0x7fUL)                  /*!< VCI_INST VCI_POLARITY: VCI_IN_POL (Bitfield-Mask: 0x7f)     */

/* -------------------------  VCI_INST_VCI_POSEDGE_DETECT  ------------------------ */
#define VCI_INST_VCI_POSEDGE_DETECT_VCI_IN_POS_Pos (0UL)                /*!< VCI_INST VCI_POSEDGE_DETECT: VCI_IN_POS (Bit 0)             */
#define VCI_INST_VCI_POSEDGE_DETECT_VCI_IN_POS_Msk (0x7fUL)             /*!< VCI_INST VCI_POSEDGE_DETECT: VCI_IN_POS (Bitfield-Mask: 0x7f) */

/* -------------------------  VCI_INST_VCI_NEGEDGE_DETECT  ------------------------ */
#define VCI_INST_VCI_NEGEDGE_DETECT_VCI_IN_NEG_Pos (0UL)                /*!< VCI_INST VCI_NEGEDGE_DETECT: VCI_IN_NEG (Bit 0)             */
#define VCI_INST_VCI_NEGEDGE_DETECT_VCI_IN_NEG_Msk (0x7fUL)             /*!< VCI_INST VCI_NEGEDGE_DETECT: VCI_IN_NEG (Bitfield-Mask: 0x7f) */

/* -------------------------  VCI_INST_VCI_BUFFER_ENABLE  ------------------------- */
#define VCI_INST_VCI_BUFFER_ENABLE_VCI_BUFFER_EN_Pos (0UL)              /*!< VCI_INST VCI_BUFFER_ENABLE: VCI_BUFFER_EN (Bit 0)           */
#define VCI_INST_VCI_BUFFER_ENABLE_VCI_BUFFER_EN_Msk (0x7fUL)           /*!< VCI_INST VCI_BUFFER_ENABLE: VCI_BUFFER_EN (Bitfield-Mask: 0x7f) */


/* ================================================================================ */
/* ================       struct 'VBAT_INST' Position & Mask       ================ */
/* ================================================================================ */


/* ------------------------------  VBAT_INST_PFR_STS  ----------------------------- */
#define VBAT_INST_PFR_STS_SOFT_Pos            (2UL)                     /*!< VBAT_INST PFR_STS: SOFT (Bit 2)                             */
#define VBAT_INST_PFR_STS_SOFT_Msk            (0x4UL)                   /*!< VBAT_INST PFR_STS: SOFT (Bitfield-Mask: 0x01)               */
#define VBAT_INST_PFR_STS_TEST_Pos            (3UL)                     /*!< VBAT_INST PFR_STS: TEST (Bit 3)                             */
#define VBAT_INST_PFR_STS_TEST_Msk            (0x8UL)                   /*!< VBAT_INST PFR_STS: TEST (Bitfield-Mask: 0x01)               */
#define VBAT_INST_PFR_STS_RESETI_Pos          (4UL)                     /*!< VBAT_INST PFR_STS: RESETI (Bit 4)                           */
#define VBAT_INST_PFR_STS_RESETI_Msk          (0x10UL)                  /*!< VBAT_INST PFR_STS: RESETI (Bitfield-Mask: 0x01)             */
#define VBAT_INST_PFR_STS_WDT_EVT_Pos         (5UL)                     /*!< VBAT_INST PFR_STS: WDT_EVT (Bit 5)                          */
#define VBAT_INST_PFR_STS_WDT_EVT_Msk         (0x20UL)                  /*!< VBAT_INST PFR_STS: WDT_EVT (Bitfield-Mask: 0x01)            */
#define VBAT_INST_PFR_STS_SYSRESETREQ_Pos     (6UL)                     /*!< VBAT_INST PFR_STS: SYSRESETREQ (Bit 6)                      */
#define VBAT_INST_PFR_STS_SYSRESETREQ_Msk     (0x40UL)                  /*!< VBAT_INST PFR_STS: SYSRESETREQ (Bitfield-Mask: 0x01)        */
#define VBAT_INST_PFR_STS_VBAT_RST_Pos        (7UL)                     /*!< VBAT_INST PFR_STS: VBAT_RST (Bit 7)                         */
#define VBAT_INST_PFR_STS_VBAT_RST_Msk        (0x80UL)                  /*!< VBAT_INST PFR_STS: VBAT_RST (Bitfield-Mask: 0x01)           */

/* -----------------------------  VBAT_INST_CLOCK_EN  ----------------------------- */
#define VBAT_INST_CLOCK_EN_C32K_SUPPRESS_Pos  (0UL)                     /*!< VBAT_INST CLOCK_EN: C32K_SUPPRESS (Bit 0)                   */
#define VBAT_INST_CLOCK_EN_C32K_SUPPRESS_Msk  (0x1UL)                   /*!< VBAT_INST CLOCK_EN: C32K_SUPPRESS (Bitfield-Mask: 0x01)     */
#define VBAT_INST_CLOCK_EN_EXT_32K_Pos        (1UL)                     /*!< VBAT_INST CLOCK_EN: EXT_32K (Bit 1)                         */
#define VBAT_INST_CLOCK_EN_EXT_32K_Msk        (0x2UL)                   /*!< VBAT_INST CLOCK_EN: EXT_32K (Bitfield-Mask: 0x01)           */
#define VBAT_INST_CLOCK_EN_C32KHZ_SOURCE_Pos  (2UL)                     /*!< VBAT_INST CLOCK_EN: C32KHZ_SOURCE (Bit 2)                   */
#define VBAT_INST_CLOCK_EN_C32KHZ_SOURCE_Msk  (0x4UL)                   /*!< VBAT_INST CLOCK_EN: C32KHZ_SOURCE (Bitfield-Mask: 0x01)     */
#define VBAT_INST_CLOCK_EN_XOSEL_Pos          (3UL)                     /*!< VBAT_INST CLOCK_EN: XOSEL (Bit 3)                           */
#define VBAT_INST_CLOCK_EN_XOSEL_Msk          (0x8UL)                   /*!< VBAT_INST CLOCK_EN: XOSEL (Bitfield-Mask: 0x01)             */

/* -------------------------  VBAT_INST_MONOTONIC_COUNTER  ------------------------ */
#define VBAT_INST_MONOTONIC_COUNTER_MONOTONIC_COUNTER_Pos (0UL)         /*!< VBAT_INST MONOTONIC_COUNTER: MONOTONIC_COUNTER (Bit 0)      */
#define VBAT_INST_MONOTONIC_COUNTER_MONOTONIC_COUNTER_Msk (0xffffffffUL) /*!< VBAT_INST MONOTONIC_COUNTER: MONOTONIC_COUNTER (Bitfield-Mask: 0xffffffff) */

/* --------------------------  VBAT_INST_COUNTER_HIWORD  -------------------------- */
#define VBAT_INST_COUNTER_HIWORD_COUNTER_HIWORD_Pos (0UL)               /*!< VBAT_INST COUNTER_HIWORD: COUNTER_HIWORD (Bit 0)            */
#define VBAT_INST_COUNTER_HIWORD_COUNTER_HIWORD_Msk (0xffffffffUL)      /*!< VBAT_INST COUNTER_HIWORD: COUNTER_HIWORD (Bitfield-Mask: 0xffffffff) */

/* ---------------------------  VBAT_INST_VWIRE_BACKUP  --------------------------- */
#define VBAT_INST_VWIRE_BACKUP_M2S_2H_BACKUP_Pos (0UL)                  /*!< VBAT_INST VWIRE_BACKUP: M2S_2H_BACKUP (Bit 0)               */
#define VBAT_INST_VWIRE_BACKUP_M2S_2H_BACKUP_Msk (0xfUL)                /*!< VBAT_INST VWIRE_BACKUP: M2S_2H_BACKUP (Bitfield-Mask: 0x0f) */
#define VBAT_INST_VWIRE_BACKUP_M2S_42H_BACKUP_Pos (4UL)                 /*!< VBAT_INST VWIRE_BACKUP: M2S_42H_BACKUP (Bit 4)              */
#define VBAT_INST_VWIRE_BACKUP_M2S_42H_BACKUP_Msk (0xf0UL)              /*!< VBAT_INST VWIRE_BACKUP: M2S_42H_BACKUP (Bitfield-Mask: 0x0f) */


/* ================================================================================ */
/* ================    struct 'EC_REG_BANK_INST' Position & Mask   ================ */
/* ================================================================================ */


/* ------------------------  EC_REG_BANK_INST_DEBUG_Enable  ----------------------- */
#define EC_REG_BANK_INST_DEBUG_Enable_DEBUG_EN_Pos (0UL)                /*!< EC_REG_BANK_INST DEBUG_Enable: DEBUG_EN (Bit 0)             */
#define EC_REG_BANK_INST_DEBUG_Enable_DEBUG_EN_Msk (0x1UL)              /*!< EC_REG_BANK_INST DEBUG_Enable: DEBUG_EN (Bitfield-Mask: 0x01) */
#define EC_REG_BANK_INST_DEBUG_Enable_DEBUG_PIN_CFG_Pos (1UL)           /*!< EC_REG_BANK_INST DEBUG_Enable: DEBUG_PIN_CFG (Bit 1)        */
#define EC_REG_BANK_INST_DEBUG_Enable_DEBUG_PIN_CFG_Msk (0x6UL)         /*!< EC_REG_BANK_INST DEBUG_Enable: DEBUG_PIN_CFG (Bitfield-Mask: 0x03) */
#define EC_REG_BANK_INST_DEBUG_Enable_DEBUG_PU_EN_Pos (3UL)             /*!< EC_REG_BANK_INST DEBUG_Enable: DEBUG_PU_EN (Bit 3)          */
#define EC_REG_BANK_INST_DEBUG_Enable_DEBUG_PU_EN_Msk (0x8UL)           /*!< EC_REG_BANK_INST DEBUG_Enable: DEBUG_PU_EN (Bitfield-Mask: 0x01) */

/* --------------------------  EC_REG_BANK_INST_OTP_LOCK  ------------------------- */
#define EC_REG_BANK_INST_OTP_LOCK_TEST_Pos    (0UL)                     /*!< EC_REG_BANK_INST OTP_LOCK: TEST (Bit 0)                     */
#define EC_REG_BANK_INST_OTP_LOCK_TEST_Msk    (0x1UL)                   /*!< EC_REG_BANK_INST OTP_LOCK: TEST (Bitfield-Mask: 0x01)       */
#define EC_REG_BANK_INST_OTP_LOCK_MCHIP_LOCK_Pos (1UL)                  /*!< EC_REG_BANK_INST OTP_LOCK: MCHIP_LOCK (Bit 1)               */
#define EC_REG_BANK_INST_OTP_LOCK_MCHIP_LOCK_Msk (0x2UL)                /*!< EC_REG_BANK_INST OTP_LOCK: MCHIP_LOCK (Bitfield-Mask: 0x01) */
#define EC_REG_BANK_INST_OTP_LOCK_PRIVATE_KEY_LOCK_Pos (2UL)            /*!< EC_REG_BANK_INST OTP_LOCK: PRIVATE_KEY_LOCK (Bit 2)         */
#define EC_REG_BANK_INST_OTP_LOCK_PRIVATE_KEY_LOCK_Msk (0x4UL)          /*!< EC_REG_BANK_INST OTP_LOCK: PRIVATE_KEY_LOCK (Bitfield-Mask: 0x01) */
#define EC_REG_BANK_INST_OTP_LOCK_USER_OTP_LOCK_Pos (3UL)               /*!< EC_REG_BANK_INST OTP_LOCK: USER_OTP_LOCK (Bit 3)            */
#define EC_REG_BANK_INST_OTP_LOCK_USER_OTP_LOCK_Msk (0x8UL)             /*!< EC_REG_BANK_INST OTP_LOCK: USER_OTP_LOCK (Bitfield-Mask: 0x01) */
#define EC_REG_BANK_INST_OTP_LOCK_PUBLIC_KEY_LOCK_Pos (4UL)             /*!< EC_REG_BANK_INST OTP_LOCK: PUBLIC_KEY_LOCK (Bit 4)          */
#define EC_REG_BANK_INST_OTP_LOCK_PUBLIC_KEY_LOCK_Msk (0x10UL)          /*!< EC_REG_BANK_INST OTP_LOCK: PUBLIC_KEY_LOCK (Bitfield-Mask: 0x01) */

/* -----------------  EC_REG_BANK_INST_AES_HASH_BYTE_SWAP_CONTROL  ---------------- */
#define EC_REG_BANK_INST_AES_HASH_BYTE_SWAP_CONTROL_INPUT_BYTE_SWAP_ENABLE_Pos (0UL) /*!< EC_REG_BANK_INST AES_HASH_BYTE_SWAP_CONTROL: INPUT_BYTE_SWAP_ENABLE (Bit 0) */
#define EC_REG_BANK_INST_AES_HASH_BYTE_SWAP_CONTROL_INPUT_BYTE_SWAP_ENABLE_Msk (0x1UL) /*!< EC_REG_BANK_INST AES_HASH_BYTE_SWAP_CONTROL: INPUT_BYTE_SWAP_ENABLE (Bitfield-Mask: 0x01) */
#define EC_REG_BANK_INST_AES_HASH_BYTE_SWAP_CONTROL_OUTPUT_BYTE_SWAP_ENABLE_Pos (1UL) /*!< EC_REG_BANK_INST AES_HASH_BYTE_SWAP_CONTROL: OUTPUT_BYTE_SWAP_ENABLE (Bit 1) */
#define EC_REG_BANK_INST_AES_HASH_BYTE_SWAP_CONTROL_OUTPUT_BYTE_SWAP_ENABLE_Msk (0x2UL) /*!< EC_REG_BANK_INST AES_HASH_BYTE_SWAP_CONTROL: OUTPUT_BYTE_SWAP_ENABLE (Bitfield-Mask: 0x01) */
#define EC_REG_BANK_INST_AES_HASH_BYTE_SWAP_CONTROL_INPUT_BLOCK_SWAP_ENABLE_Pos (2UL) /*!< EC_REG_BANK_INST AES_HASH_BYTE_SWAP_CONTROL: INPUT_BLOCK_SWAP_ENABLE (Bit 2) */
#define EC_REG_BANK_INST_AES_HASH_BYTE_SWAP_CONTROL_INPUT_BLOCK_SWAP_ENABLE_Msk (0x1cUL) /*!< EC_REG_BANK_INST AES_HASH_BYTE_SWAP_CONTROL: INPUT_BLOCK_SWAP_ENABLE (Bitfield-Mask: 0x07) */
#define EC_REG_BANK_INST_AES_HASH_BYTE_SWAP_CONTROL_OUTPUT_BLOCK_SWAP_ENABLE_Pos (5UL) /*!< EC_REG_BANK_INST AES_HASH_BYTE_SWAP_CONTROL: OUTPUT_BLOCK_SWAP_ENABLE (Bit 5) */
#define EC_REG_BANK_INST_AES_HASH_BYTE_SWAP_CONTROL_OUTPUT_BLOCK_SWAP_ENABLE_Msk (0xe0UL) /*!< EC_REG_BANK_INST AES_HASH_BYTE_SWAP_CONTROL: OUTPUT_BLOCK_SWAP_ENABLE (Bitfield-Mask: 0x07) */

/* ------------------------  EC_REG_BANK_INST_PECI_DISABLE  ----------------------- */
#define EC_REG_BANK_INST_PECI_DISABLE_PECI_DISABLE_Pos (0UL)            /*!< EC_REG_BANK_INST PECI_DISABLE: PECI_DISABLE (Bit 0)         */
#define EC_REG_BANK_INST_PECI_DISABLE_PECI_DISABLE_Msk (0x1UL)          /*!< EC_REG_BANK_INST PECI_DISABLE: PECI_DISABLE (Bitfield-Mask: 0x01) */

/* ---------------------  EC_REG_BANK_INST_CRYPTO_SOFT_RESET  --------------------- */
#define EC_REG_BANK_INST_CRYPTO_SOFT_RESET_RNG_SOFT_RESET_Pos (0UL)     /*!< EC_REG_BANK_INST CRYPTO_SOFT_RESET: RNG_SOFT_RESET (Bit 0)  */
#define EC_REG_BANK_INST_CRYPTO_SOFT_RESET_RNG_SOFT_RESET_Msk (0x1UL)   /*!< EC_REG_BANK_INST CRYPTO_SOFT_RESET: RNG_SOFT_RESET (Bitfield-Mask: 0x01) */
#define EC_REG_BANK_INST_CRYPTO_SOFT_RESET_PUBLIC_KEY_SOFT_RESET_Pos (1UL) /*!< EC_REG_BANK_INST CRYPTO_SOFT_RESET: PUBLIC_KEY_SOFT_RESET (Bit 1) */
#define EC_REG_BANK_INST_CRYPTO_SOFT_RESET_PUBLIC_KEY_SOFT_RESET_Msk (0x2UL) /*!< EC_REG_BANK_INST CRYPTO_SOFT_RESET: PUBLIC_KEY_SOFT_RESET (Bitfield-Mask: 0x01) */
#define EC_REG_BANK_INST_CRYPTO_SOFT_RESET_AES_HASH_SOFT_RESET_Pos (2UL) /*!< EC_REG_BANK_INST CRYPTO_SOFT_RESET: AES_HASH_SOFT_RESET (Bit 2) */
#define EC_REG_BANK_INST_CRYPTO_SOFT_RESET_AES_HASH_SOFT_RESET_Msk (0x4UL) /*!< EC_REG_BANK_INST CRYPTO_SOFT_RESET: AES_HASH_SOFT_RESET (Bitfield-Mask: 0x01) */

/* ----------------------  EC_REG_BANK_INST_GPIO_BANK_POWER  ---------------------- */
#define EC_REG_BANK_INST_GPIO_BANK_POWER_VTR_LEVEL1_Pos (0UL)           /*!< EC_REG_BANK_INST GPIO_BANK_POWER: VTR_LEVEL1 (Bit 0)        */
#define EC_REG_BANK_INST_GPIO_BANK_POWER_VTR_LEVEL1_Msk (0x1UL)         /*!< EC_REG_BANK_INST GPIO_BANK_POWER: VTR_LEVEL1 (Bitfield-Mask: 0x01) */
#define EC_REG_BANK_INST_GPIO_BANK_POWER_VTR_LEVEL2_Pos (1UL)           /*!< EC_REG_BANK_INST GPIO_BANK_POWER: VTR_LEVEL2 (Bit 1)        */
#define EC_REG_BANK_INST_GPIO_BANK_POWER_VTR_LEVEL2_Msk (0x2UL)         /*!< EC_REG_BANK_INST GPIO_BANK_POWER: VTR_LEVEL2 (Bitfield-Mask: 0x01) */
#define EC_REG_BANK_INST_GPIO_BANK_POWER_VTR_LEVEL3_Pos (2UL)           /*!< EC_REG_BANK_INST GPIO_BANK_POWER: VTR_LEVEL3 (Bit 2)        */
#define EC_REG_BANK_INST_GPIO_BANK_POWER_VTR_LEVEL3_Msk (0x4UL)         /*!< EC_REG_BANK_INST GPIO_BANK_POWER: VTR_LEVEL3 (Bitfield-Mask: 0x01) */
#define EC_REG_BANK_INST_GPIO_BANK_POWER_GPIO_BANK_POWER_LOCK_Pos (7UL) /*!< EC_REG_BANK_INST GPIO_BANK_POWER: GPIO_BANK_POWER_LOCK (Bit 7) */
#define EC_REG_BANK_INST_GPIO_BANK_POWER_GPIO_BANK_POWER_LOCK_Msk (0x80UL) /*!< EC_REG_BANK_INST GPIO_BANK_POWER: GPIO_BANK_POWER_LOCK (Bitfield-Mask: 0x01) */

/* ----------------------  EC_REG_BANK_INST_JTAG_MASTER_CFG  ---------------------- */
#define EC_REG_BANK_INST_JTAG_MASTER_CFG_JTM_CLK_Pos (0UL)              /*!< EC_REG_BANK_INST JTAG_MASTER_CFG: JTM_CLK (Bit 0)           */
#define EC_REG_BANK_INST_JTAG_MASTER_CFG_JTM_CLK_Msk (0x7UL)            /*!< EC_REG_BANK_INST JTAG_MASTER_CFG: JTM_CLK (Bitfield-Mask: 0x07) */
#define EC_REG_BANK_INST_JTAG_MASTER_CFG_MASTER_SLAVE_Pos (3UL)         /*!< EC_REG_BANK_INST JTAG_MASTER_CFG: MASTER_SLAVE (Bit 3)      */
#define EC_REG_BANK_INST_JTAG_MASTER_CFG_MASTER_SLAVE_Msk (0x8UL)       /*!< EC_REG_BANK_INST JTAG_MASTER_CFG: MASTER_SLAVE (Bitfield-Mask: 0x01) */

/* ----------------------  EC_REG_BANK_INST_JTAG_MASTER_STS  ---------------------- */
#define EC_REG_BANK_INST_JTAG_MASTER_STS_JTM_DONE_Pos (0UL)             /*!< EC_REG_BANK_INST JTAG_MASTER_STS: JTM_DONE (Bit 0)          */
#define EC_REG_BANK_INST_JTAG_MASTER_STS_JTM_DONE_Msk (0x1UL)           /*!< EC_REG_BANK_INST JTAG_MASTER_STS: JTM_DONE (Bitfield-Mask: 0x01) */

/* ----------------------  EC_REG_BANK_INST_JTAG_MASTER_TDO  ---------------------- */
#define EC_REG_BANK_INST_JTAG_MASTER_TDO_JTM_TDO_Pos (0UL)              /*!< EC_REG_BANK_INST JTAG_MASTER_TDO: JTM_TDO (Bit 0)           */
#define EC_REG_BANK_INST_JTAG_MASTER_TDO_JTM_TDO_Msk (0xffffffffUL)     /*!< EC_REG_BANK_INST JTAG_MASTER_TDO: JTM_TDO (Bitfield-Mask: 0xffffffff) */

/* ----------------------  EC_REG_BANK_INST_JTAG_MASTER_TDI  ---------------------- */
#define EC_REG_BANK_INST_JTAG_MASTER_TDI_JTM_TDI_Pos (0UL)              /*!< EC_REG_BANK_INST JTAG_MASTER_TDI: JTM_TDI (Bit 0)           */
#define EC_REG_BANK_INST_JTAG_MASTER_TDI_JTM_TDI_Msk (0xffffffffUL)     /*!< EC_REG_BANK_INST JTAG_MASTER_TDI: JTM_TDI (Bitfield-Mask: 0xffffffff) */

/* ----------------------  EC_REG_BANK_INST_JTAG_MASTER_TMS  ---------------------- */
#define EC_REG_BANK_INST_JTAG_MASTER_TMS_JTM_TMS_Pos (0UL)              /*!< EC_REG_BANK_INST JTAG_MASTER_TMS: JTM_TMS (Bit 0)           */
#define EC_REG_BANK_INST_JTAG_MASTER_TMS_JTM_TMS_Msk (0xffffffffUL)     /*!< EC_REG_BANK_INST JTAG_MASTER_TMS: JTM_TMS (Bitfield-Mask: 0xffffffff) */

/* ----------------------  EC_REG_BANK_INST_JTAG_MASTER_CMD  ---------------------- */
#define EC_REG_BANK_INST_JTAG_MASTER_CMD_JTM_COUNT_Pos (0UL)            /*!< EC_REG_BANK_INST JTAG_MASTER_CMD: JTM_COUNT (Bit 0)         */
#define EC_REG_BANK_INST_JTAG_MASTER_CMD_JTM_COUNT_Msk (0x1fUL)         /*!< EC_REG_BANK_INST JTAG_MASTER_CMD: JTM_COUNT (Bitfield-Mask: 0x1f) */


/* ================================================================================ */
/* ================       struct 'EFUSE_INST' Position & Mask      ================ */
/* ================================================================================ */


/* -----------------------------  EFUSE_INST_CONTROL  ----------------------------- */
#define EFUSE_INST_CONTROL_ENABLE_Pos         (0UL)                     /*!< EFUSE_INST CONTROL: ENABLE (Bit 0)                          */
#define EFUSE_INST_CONTROL_ENABLE_Msk         (0x1UL)                   /*!< EFUSE_INST CONTROL: ENABLE (Bitfield-Mask: 0x01)            */
#define EFUSE_INST_CONTROL_RESET_Pos          (1UL)                     /*!< EFUSE_INST CONTROL: RESET (Bit 1)                           */
#define EFUSE_INST_CONTROL_RESET_Msk          (0x2UL)                   /*!< EFUSE_INST CONTROL: RESET (Bitfield-Mask: 0x01)             */
#define EFUSE_INST_CONTROL_EXT_PGM_Pos        (2UL)                     /*!< EFUSE_INST CONTROL: EXT_PGM (Bit 2)                         */
#define EFUSE_INST_CONTROL_EXT_PGM_Msk        (0x4UL)                   /*!< EFUSE_INST CONTROL: EXT_PGM (Bitfield-Mask: 0x01)           */
#define EFUSE_INST_CONTROL_FSOURCE_EN_PRGM_Pos (3UL)                    /*!< EFUSE_INST CONTROL: FSOURCE_EN_PRGM (Bit 3)                 */
#define EFUSE_INST_CONTROL_FSOURCE_EN_PRGM_Msk (0x8UL)                  /*!< EFUSE_INST CONTROL: FSOURCE_EN_PRGM (Bitfield-Mask: 0x01)   */
#define EFUSE_INST_CONTROL_FSOURCE_EN_READ_Pos (4UL)                    /*!< EFUSE_INST CONTROL: FSOURCE_EN_READ (Bit 4)                 */
#define EFUSE_INST_CONTROL_FSOURCE_EN_READ_Msk (0x10UL)                 /*!< EFUSE_INST CONTROL: FSOURCE_EN_READ (Bitfield-Mask: 0x01)   */

/* --------------------------  EFUSE_INST_MANUAL_CONTROL  ------------------------- */
#define EFUSE_INST_MANUAL_CONTROL_MAN_ENABLE_Pos (0UL)                  /*!< EFUSE_INST MANUAL_CONTROL: MAN_ENABLE (Bit 0)               */
#define EFUSE_INST_MANUAL_CONTROL_MAN_ENABLE_Msk (0x1UL)                /*!< EFUSE_INST MANUAL_CONTROL: MAN_ENABLE (Bitfield-Mask: 0x01) */
#define EFUSE_INST_MANUAL_CONTROL_IP_CS_Pos   (1UL)                     /*!< EFUSE_INST MANUAL_CONTROL: IP_CS (Bit 1)                    */
#define EFUSE_INST_MANUAL_CONTROL_IP_CS_Msk   (0x2UL)                   /*!< EFUSE_INST MANUAL_CONTROL: IP_CS (Bitfield-Mask: 0x01)      */
#define EFUSE_INST_MANUAL_CONTROL_IP_PRGM_EN_Pos (2UL)                  /*!< EFUSE_INST MANUAL_CONTROL: IP_PRGM_EN (Bit 2)               */
#define EFUSE_INST_MANUAL_CONTROL_IP_PRGM_EN_Msk (0x4UL)                /*!< EFUSE_INST MANUAL_CONTROL: IP_PRGM_EN (Bitfield-Mask: 0x01) */
#define EFUSE_INST_MANUAL_CONTROL_IP_PRCHG_Pos (3UL)                    /*!< EFUSE_INST MANUAL_CONTROL: IP_PRCHG (Bit 3)                 */
#define EFUSE_INST_MANUAL_CONTROL_IP_PRCHG_Msk (0x8UL)                  /*!< EFUSE_INST MANUAL_CONTROL: IP_PRCHG (Bitfield-Mask: 0x01)   */
#define EFUSE_INST_MANUAL_CONTROL_IP_SENSE_PULSE_Pos (4UL)              /*!< EFUSE_INST MANUAL_CONTROL: IP_SENSE_PULSE (Bit 4)           */
#define EFUSE_INST_MANUAL_CONTROL_IP_SENSE_PULSE_Msk (0x10UL)           /*!< EFUSE_INST MANUAL_CONTROL: IP_SENSE_PULSE (Bitfield-Mask: 0x01) */
#define EFUSE_INST_MANUAL_CONTROL_IP_OE_Pos   (5UL)                     /*!< EFUSE_INST MANUAL_CONTROL: IP_OE (Bit 5)                    */
#define EFUSE_INST_MANUAL_CONTROL_IP_OE_Msk   (0x20UL)                  /*!< EFUSE_INST MANUAL_CONTROL: IP_OE (Bitfield-Mask: 0x01)      */

/* -----------------------  EFUSE_INST_MANUAL_MODE_ADDRESS  ----------------------- */
#define EFUSE_INST_MANUAL_MODE_ADDRESS_IP_ADDR_LO_Pos (0UL)             /*!< EFUSE_INST MANUAL_MODE_ADDRESS: IP_ADDR_LO (Bit 0)          */
#define EFUSE_INST_MANUAL_MODE_ADDRESS_IP_ADDR_LO_Msk (0x3ffUL)         /*!< EFUSE_INST MANUAL_MODE_ADDRESS: IP_ADDR_LO (Bitfield-Mask: 0x3ff) */
#define EFUSE_INST_MANUAL_MODE_ADDRESS_IP_ADDR_HI_Pos (10UL)            /*!< EFUSE_INST MANUAL_MODE_ADDRESS: IP_ADDR_HI (Bit 10)         */
#define EFUSE_INST_MANUAL_MODE_ADDRESS_IP_ADDR_HI_Msk (0xc00UL)         /*!< EFUSE_INST MANUAL_MODE_ADDRESS: IP_ADDR_HI (Bitfield-Mask: 0x03) */

/* -------------------------  EFUSE_INST_MANUAL_MODE_DATA  ------------------------ */
#define EFUSE_INST_MANUAL_MODE_DATA_IP_DATA_Pos (0UL)                   /*!< EFUSE_INST MANUAL_MODE_DATA: IP_DATA (Bit 0)                */
#define EFUSE_INST_MANUAL_MODE_DATA_IP_DATA_Msk (0xffffUL)              /*!< EFUSE_INST MANUAL_MODE_DATA: IP_DATA (Bitfield-Mask: 0xffff) */



/* ================================================================================ */
/* ================              Peripheral memory map             ================ */
/* ================================================================================ */

#define PCR_INST_BASE                   0x40080100UL
#define DMA_MAIN_INST_BASE              0x40002400UL
#define DMA_CHAN00_INST_BASE            0x40002440UL
#define DMA_CHAN01_INST_BASE            0x40002480UL
#define DMA_CHAN02_INST_BASE            0x400024C0UL
#define DMA_CHAN03_INST_BASE            0x40002500UL
#define DMA_CHAN04_INST_BASE            0x40002540UL
#define DMA_CHAN05_INST_BASE            0x40002580UL
#define DMA_CHAN06_INST_BASE            0x400025C0UL
#define DMA_CHAN07_INST_BASE            0x40002600UL
#define DMA_CHAN08_INST_BASE            0x40002640UL
#define DMA_CHAN09_INST_BASE            0x40002680UL
#define DMA_CHAN10_INST_BASE            0x400026C0UL
#define DMA_CHAN11_INST_BASE            0x40002700UL
#define DMA_CHAN12_INST_BASE            0x40002740UL
#define DMA_CHAN13_INST_BASE            0x40002780UL
#define INTS_INST_BASE                  0x4000E000UL
#define GCR_INST_BASE                   0x400FFF00UL
#define UART0_INST_BASE                 0x400F2400UL
#define UART1_INST_BASE                 0x400F2800UL
#define GPIO_000_036_INST_BASE          0x40081000UL
#define GPIO_040_076_INST_BASE          0x40081080UL
#define GPIO_100_137_INST_BASE          0x40081100UL
#define GPIO_140_176_INST_BASE          0x40081180UL
#define GPIO_200_236_INST_BASE          0x40081200UL
#define GPIO_240_257_INST_BASE          0x40081280UL
#define INPUT_OUTPUT_GPIO_INST_BASE     0x40081300UL
#define GPIO_PIN_CONTROL_2_INST_BASE    0x40081500UL
#define WDT_INST_BASE                   0x40000000UL
#define TIMER0_INST_BASE                0x40000C00UL
#define TIMER1_INST_BASE                0x40000C20UL
#define TIMER2_INST_BASE                0x40000C40UL
#define TIMER3_INST_BASE                0x40000C60UL
#define TIMER4_INST_BASE                0x40000C80UL
#define TIMER5_INST_BASE                0x40000CA0UL
#define COUNTER_TIMER0_INST_BASE        0x40000D00UL
#define COUNTER_TIMER1_INST_BASE        0x40000D20UL
#define COUNTER_TIMER2_INST_BASE        0x40000D40UL
#define COUNTER_TIMER3_INST_BASE        0x40000D60UL
#define CAPTURE_COMPARE_TIMER_INST_BASE 0x40001000UL
#define HTM0_INST_BASE                  0x40009800UL
#define HTM1_INST_BASE                  0x40009820UL
#define RTOS_INST_BASE                  0x40007400UL
#define RTC_INST_BASE                   0x400F5000UL
#define WEEK_INST_BASE                  0x4000AC80UL
#define TACH0_INST_BASE                 0x40006000UL
#define TACH1_INST_BASE                 0x40006010UL
#define TACH2_INST_BASE                 0x40006020UL
#define PWM0_INST_BASE                  0x40005800UL
#define PWM1_INST_BASE                  0x40005810UL
#define PWM2_INST_BASE                  0x40005820UL
#define PWM3_INST_BASE                  0x40005830UL
#define PWM4_INST_BASE                  0x40005840UL
#define PWM5_INST_BASE                  0x40005850UL
#define PWM6_INST_BASE                  0x40005860UL
#define PWM7_INST_BASE                  0x40005870UL
#define PWM8_INST_BASE                  0x40005880UL
#define PWM9_INST_BASE                  0x40005890UL
#define PWM10_INST_BASE                 0x400058A0UL
#define PWM11_INST_BASE                 0x400058B0UL
#define ADC_INST_BASE                   0x40007C00UL
#define FAN0_INST_BASE                  0x4000A000UL
#define FAN1_INST_BASE                  0x4000A080UL
#define LED0_INST_BASE                  0x4000B800UL
#define LED1_INST_BASE                  0x4000B900UL
#define LED2_INST_BASE                  0x4000BA00UL
#define LED3_INST_BASE                  0x4000BB00UL
#define RC_ID0_INST_BASE                0x40001400UL
#define RC_ID1_INST_BASE                0x40001480UL
#define RC_ID2_INST_BASE                0x40001500UL
#define KMS_INST_BASE                   0x40009C00UL
#define SMB0_INST_BASE                  0x40004000UL
#define SMB1_INST_BASE                  0x40004400UL
#define SMB2_INST_BASE                  0x40004800UL
#define SMB3_INST_BASE                  0x40004C00UL
#define GP_SPI0_INST_BASE               0x40009400UL
#define GP_SPI1_INST_BASE               0x40009480UL
#define QMSPI_INST_BASE                 0x40005400UL
#define TFDP_INST_BASE                  0x40008C00UL
#define VCI_INST_BASE                   0x4000AE00UL
#define VBAT_RAM_INST_BASE              0x4000A800UL
#define VBAT_INST_BASE                  0x4000A400UL
#define EC_REG_BANK_INST_BASE           0x4000FC00UL
#define EFUSE_INST_BASE                 0x40082000UL


/* ================================================================================ */
/* ================             Peripheral declaration             ================ */
/* ================================================================================ */

#define PCR_INST                        ((PCR_INST_Type           *) PCR_INST_BASE)
#define DMA_MAIN_INST                   ((DMA_MAIN_INST_Type      *) DMA_MAIN_INST_BASE)
#define DMA_CHAN00_INST                 ((DMA_CHAN00_INST_Type    *) DMA_CHAN00_INST_BASE)
#define DMA_CHAN01_INST                 ((DMA_CHAN01_INST_Type    *) DMA_CHAN01_INST_BASE)
#define DMA_CHAN02_INST                 ((DMA_CHAN02_INST_Type    *) DMA_CHAN02_INST_BASE)
#define DMA_CHAN03_INST                 ((DMA_CHAN02_INST_Type    *) DMA_CHAN03_INST_BASE)
#define DMA_CHAN04_INST                 ((DMA_CHAN02_INST_Type    *) DMA_CHAN04_INST_BASE)
#define DMA_CHAN05_INST                 ((DMA_CHAN02_INST_Type    *) DMA_CHAN05_INST_BASE)
#define DMA_CHAN06_INST                 ((DMA_CHAN02_INST_Type    *) DMA_CHAN06_INST_BASE)
#define DMA_CHAN07_INST                 ((DMA_CHAN02_INST_Type    *) DMA_CHAN07_INST_BASE)
#define DMA_CHAN08_INST                 ((DMA_CHAN02_INST_Type    *) DMA_CHAN08_INST_BASE)
#define DMA_CHAN09_INST                 ((DMA_CHAN02_INST_Type    *) DMA_CHAN09_INST_BASE)
#define DMA_CHAN10_INST                 ((DMA_CHAN02_INST_Type    *) DMA_CHAN10_INST_BASE)
#define DMA_CHAN11_INST                 ((DMA_CHAN02_INST_Type    *) DMA_CHAN11_INST_BASE)
#define DMA_CHAN12_INST                 ((DMA_CHAN02_INST_Type    *) DMA_CHAN12_INST_BASE)
#define DMA_CHAN13_INST                 ((DMA_CHAN02_INST_Type    *) DMA_CHAN13_INST_BASE)
#define INTS_INST                       ((INTS_INST_Type          *) INTS_INST_BASE)
#define GCR_INST                        ((GCR_INST_Type           *) GCR_INST_BASE)
#define UART0_INST                      ((UART0_INST_Type         *) UART0_INST_BASE)
#define UART1_INST                      ((UART0_INST_Type         *) UART1_INST_BASE)
#define GPIO_000_036_INST               ((GPIO_000_036_INST_Type  *) GPIO_000_036_INST_BASE)
#define GPIO_040_076_INST               ((GPIO_040_076_INST_Type  *) GPIO_040_076_INST_BASE)
#define GPIO_100_137_INST               ((GPIO_100_137_INST_Type  *) GPIO_100_137_INST_BASE)
#define GPIO_140_176_INST               ((GPIO_140_176_INST_Type  *) GPIO_140_176_INST_BASE)
#define GPIO_200_236_INST               ((GPIO_200_236_INST_Type  *) GPIO_200_236_INST_BASE)
#define GPIO_240_257_INST               ((GPIO_240_257_INST_Type  *) GPIO_240_257_INST_BASE)
#define INPUT_OUTPUT_GPIO_INST          ((INPUT_OUTPUT_GPIO_INST_Type *) INPUT_OUTPUT_GPIO_INST_BASE)
#define GPIO_PIN_CONTROL_2_INST         ((GPIO_PIN_CONTROL_2_INST_Type *) GPIO_PIN_CONTROL_2_INST_BASE)
#define WDT_INST                        ((WDT_INST_Type           *) WDT_INST_BASE)
#define TIMER0_INST                     ((TIMER0_INST_Type        *) TIMER0_INST_BASE)
#define TIMER1_INST                     ((TIMER0_INST_Type        *) TIMER1_INST_BASE)
#define TIMER2_INST                     ((TIMER0_INST_Type        *) TIMER2_INST_BASE)
#define TIMER3_INST                     ((TIMER0_INST_Type        *) TIMER3_INST_BASE)
#define TIMER4_INST                     ((TIMER0_INST_Type        *) TIMER4_INST_BASE)
#define TIMER5_INST                     ((TIMER0_INST_Type        *) TIMER5_INST_BASE)
#define COUNTER_TIMER0_INST             ((COUNTER_TIMER0_INST_Type *) COUNTER_TIMER0_INST_BASE)
#define COUNTER_TIMER1_INST             ((COUNTER_TIMER0_INST_Type *) COUNTER_TIMER1_INST_BASE)
#define COUNTER_TIMER2_INST             ((COUNTER_TIMER0_INST_Type *) COUNTER_TIMER2_INST_BASE)
#define COUNTER_TIMER3_INST             ((COUNTER_TIMER0_INST_Type *) COUNTER_TIMER3_INST_BASE)
#define CAPTURE_COMPARE_TIMER_INST      ((CAPTURE_COMPARE_TIMER_INST_Type *) CAPTURE_COMPARE_TIMER_INST_BASE)
#define HTM0_INST                       ((HTM0_INST_Type          *) HTM0_INST_BASE)
#define HTM1_INST                       ((HTM0_INST_Type          *) HTM1_INST_BASE)
#define RTOS_INST                       ((RTOS_INST_Type          *) RTOS_INST_BASE)
#define RTC_INST                        ((RTC_INST_Type           *) RTC_INST_BASE)
#define WEEK_INST                       ((WEEK_INST_Type          *) WEEK_INST_BASE)
#define TACH0_INST                      ((TACH0_INST_Type         *) TACH0_INST_BASE)
#define TACH1_INST                      ((TACH0_INST_Type         *) TACH1_INST_BASE)
#define TACH2_INST                      ((TACH0_INST_Type         *) TACH2_INST_BASE)
#define PWM0_INST                       ((PWM0_INST_Type          *) PWM0_INST_BASE)
#define PWM1_INST                       ((PWM0_INST_Type          *) PWM1_INST_BASE)
#define PWM2_INST                       ((PWM0_INST_Type          *) PWM2_INST_BASE)
#define PWM3_INST                       ((PWM0_INST_Type          *) PWM3_INST_BASE)
#define PWM4_INST                       ((PWM0_INST_Type          *) PWM4_INST_BASE)
#define PWM5_INST                       ((PWM0_INST_Type          *) PWM5_INST_BASE)
#define PWM6_INST                       ((PWM0_INST_Type          *) PWM6_INST_BASE)
#define PWM7_INST                       ((PWM0_INST_Type          *) PWM7_INST_BASE)
#define PWM8_INST                       ((PWM0_INST_Type          *) PWM8_INST_BASE)
#define PWM9_INST                       ((PWM0_INST_Type          *) PWM9_INST_BASE)
#define PWM10_INST                      ((PWM0_INST_Type          *) PWM10_INST_BASE)
#define PWM11_INST                      ((PWM0_INST_Type          *) PWM11_INST_BASE)
#define ADC_INST                        ((ADC_INST_Type           *) ADC_INST_BASE)
#define FAN0_INST                       ((FAN0_INST_Type          *) FAN0_INST_BASE)
#define FAN1_INST                       ((FAN0_INST_Type          *) FAN1_INST_BASE)
#define LED0_INST                       ((LED0_INST_Type          *) LED0_INST_BASE)
#define LED1_INST                       ((LED0_INST_Type          *) LED1_INST_BASE)
#define LED2_INST                       ((LED0_INST_Type          *) LED2_INST_BASE)
#define LED3_INST                       ((LED0_INST_Type          *) LED3_INST_BASE)
#define RC_ID0_INST                     ((RC_ID0_INST_Type        *) RC_ID0_INST_BASE)
#define RC_ID1_INST                     ((RC_ID0_INST_Type        *) RC_ID1_INST_BASE)
#define RC_ID2_INST                     ((RC_ID0_INST_Type        *) RC_ID2_INST_BASE)
#define KMS_INST                        ((KMS_INST_Type           *) KMS_INST_BASE)
#define SMB0_INST                       ((SMB0_INST_Type          *) SMB0_INST_BASE)
#define SMB1_INST                       ((SMB0_INST_Type          *) SMB1_INST_BASE)
#define SMB2_INST                       ((SMB0_INST_Type          *) SMB2_INST_BASE)
#define SMB3_INST                       ((SMB0_INST_Type          *) SMB3_INST_BASE)
#define GP_SPI0_INST                    ((GP_SPI0_INST_Type       *) GP_SPI0_INST_BASE)
#define GP_SPI1_INST                    ((GP_SPI0_INST_Type       *) GP_SPI1_INST_BASE)
#define QMSPI_INST                      ((QMSPI_INST_Type         *) QMSPI_INST_BASE)
#define TFDP_INST                       ((TFDP_INST_Type          *) TFDP_INST_BASE)
#define VCI_INST                        ((VCI_INST_Type           *) VCI_INST_BASE)
#define VBAT_RAM_INST                   ((VBAT_RAM_INST_Type      *) VBAT_RAM_INST_BASE)
#define VBAT_INST                       ((VBAT_INST_Type          *) VBAT_INST_BASE)
#define EC_REG_BANK_INST                ((EC_REG_BANK_INST_Type   *) EC_REG_BANK_INST_BASE)
#define EFUSE_INST                      ((EFUSE_INST_Type         *) EFUSE_INST_BASE)


/** @} */ /* End of group Device_Peripheral_Registers */
/** @} */ /* End of group MCHP_CEC1702_C0 */
/** @} */ /* End of group Microchip Technology Inc. */

#ifdef __cplusplus
}
#endif


#endif  /* MCHP_CEC1702_C0_H */

